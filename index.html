<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSA problems </title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: rgba(255, 255, 255, 0.997);
            line-height: 1.6;
            margin: 0;
            padding: 0;
            
        }
        #myBtn {
      display: none;
      position: fixed;
      bottom: 15px;
      right: 20px;
      z-index: 99;
      font-size: 18px;
      border: none;
      outline: none;
      background-color: rgb(255, 0, 0);
      color: rgb(255, 255, 255);
      cursor: pointer;
      padding: 5px;
      border-radius: 4px;
    }

    #myBtn:hover {
      background-color: #ffd3d3;
    }
    
        header {
            /* background: #000000; 
            color: #fff;
            padding: 288.5px 0;
            text-align: center; */
            background-image: url("background.jpg");
            background-size: cover;
            background-position: center;
            height: 700px; /* Set the desired height of your header */
            color: rgb(0, 0, 0); /* Text color on top of the background image */
            text-align: center;
            padding: 20px; /* Add padding to the header content */

        }
        nav ul {
            list-style-type: none;
            padding: 0;
        }
        nav ul li {
            display: inline;
            margin-right: 40px;
        }
        nav ul li a {
            color: #000000;
            text-decoration: underline;
            text-decoration-color: red; /* Change the color of the underline */
          text-decoration-style: dotted; /* Change the style of the underline */
        }
        section {
            padding: 20px;
            text-align: center;
        }
        
        footer {
            background: #333;
            color: #fff;
            text-align: center;
            padding: 10px 0;
            position: absolute;
            bottom: 0;
            width: 100%;
            
        }
        /* Applying text decorations */
.text-underline {
  text-decoration: underline;
}

.text-overline {
  text-decoration: overline;
}

.text-line-through {
  text-decoration: line-through;
}

.text-multiple-decorations {
  text-decoration: underline overline line-through;
}

/* Customizing text decoration color and style */
.custom-text-decoration {
  text-decoration: underline;
  text-decoration-color: red; /* Change the color of the underline */
  text-decoration-style: wavy; /* Change the style of the underline */
}
a {
            text-decoration: none;
            color: #333;
            font-weight: bold;
        }

        a:hover {
            text-decoration: underline;
        }
    
        p {
            text-decoration: none;
            color: #333;
            font-weight: bold;
        }

        p:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>

    <button onclick="topFunction()" id="myBtn" title="Go to top">Top</button>

<script>
    // When the user scrolls down 20px from the top of the document, show the button
    window.onscroll = function() {scrollFunction()};

    function scrollFunction() {
        if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
            document.getElementById("myBtn").style.display = "block";
        } else {
            document.getElementById("myBtn").style.display = "none";
        }
    }

    // When the user clicks on the button, scroll to the top of the document
    function topFunction() {
        document.body.scrollTop = 0; // For Safari
        document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
    }
    
</script>

    <header>
        <h1>DSA QUESTION SHEET</h1>
        <nav>
            <ul>
                <li><a href="#arrays">ARRAYS</a></li>
                <li><a href="#2darrays">2D-ARRAYS</a></li>
                <li><a href="#string">STRING</a></li>
                <li><a href="#stack">STACK</a></li>
                <li><a href="#queue">QUEUE</a></li>
                <li><a href="#linkedlist">LINKEDLIST</a></li>
                <li><a href="#trees">TREES</a></li>
                <li><a href="#graphs">GRAPHS</a></li>
                <li><a href="#searching">SEARCHING</a></li>
                <li><a href="#sorting">SORTING</a></li>
            </ul>
        </nav>
        <img src="DSA.jpg" alt="DSA Logo" width="400" height="400">
    </header>
    
    <!-- MAIN SECTIONID -->

    <section id="arrays">
        <h2>ARRAY PROBLEMS</h2>
        <ul>
            <li><a href="#arr1">Q-1:Enter an array from user and display all the value ?</a></li>
            <li><a href="#arr2">Q-2:Enter an array from user and print the array in reverse order?</a></li>
            <li><a href="#arr3">Q-3:Enter an array from user and copy the array into second array ?</a></li>
            <li><a href="#arr4">Q-4:Enter an array from user and copy it into another array in reverse order ?</a></li>
            <li><a href="#arr5">Q-5:Enter an array from user and print the number which is even ?</a></li>
            <li><a href="#arr6">Q-6:Enter an array from user and print the number which is positive ?</a></li>
            <li><a href="#arr7">Q-7:Enter an array from user and square all the values of array ?</a></li>
            <li><a href="#arr8">Q-8:Enter an array from user and find maximum and minimum value?</a></li>
            <li><a href="#arr9">Q-9:Enter an array from user and find the k-th smallest value?</a></li>
            <li><a href="#arr10">Q-10:Enter an array from user and add all values ?</a></li>
            <li><a href="#arr11">Q-11:Enter an array from user and find the duplicate values?</a></li>
            <li><a href="#arr12">Q-12:Enter an array from user and remove the duplicate values and fill with zero?</a></li>
            <li><a href="#arr13">Q-13:Enter an array from user and count the duplicate values?</a></li>
            <li><a href="#arr14">Q-14:Enter an array from user and print all possible combinations of the elements?</a></li>
            <li><a href="#arr15">Q-15:Enter an array from user and print all the palindrone numbers?</a></li>
            <li><a href="#arr16">Q-16: Enter two arrays from the user and check they are same or not?</a></li>
            <li><a href="#arr17">Q-17:Merge the two sorted arrays into one array but in sorted order?</a></li>
            <li><a href="#arr18">Q-18:Find the local minima in the array? (An element in an array is a local minima if it less than the element after it, and the element before it)</a></li>
            <li><a href="#arr19">Q-19:Find the local maxima in the array? (An element in an array is a local maxima if it greater than the element after it, and the element before it)</a></li>
            <li><a href="#arr20">Q-20:Trapping Rain Water Problem: Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.</a></li>
                

                <section id="arr1">
                    <p>Q-1:Enter an array from user and display all the value ? </p>
                    <pre>
                    <code >
#include <stdio.h>

    int main() {
    int n, i;
                            
    printf("Enter the number of elements: ");
    scanf("%d", &n);
                            
    int arr[n];
                            
    printf("Enter the elements:\n");
    for (i = 0; i &lt n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
        }
                            
    printf("The elements you entered are: ");
    for (i = 0; i &lt n; i++) {
        printf("%d ", arr[i]);
        }
    printf("\n");
                            
    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
Enter the number of elements: 5
    Enter the elements:
    Enter element 1: 10
    Enter element 2: 20
    Enter element 3: 30
    Enter element 4: 40
    Enter element 5: 50
    The elements you entered are: 10 20 30 40 50

                    </code>
                    </pre>

                </section>
                <section id="arr2">
                    <p>Q-2:Enter an array from user and print the array in reverse order ?</p>
                    <pre>
                        <code>            
#include <stdio.h>

    int main() {
        int n, i;
    
        printf("Enter the number of elements: ");
        scanf("%d", &n);
    
        int arr[n];
    
        printf("Enter the elements:\n");
        for (i = 0; i < n; i++) {
            printf("Enter element %d: ", i + 1);
            scanf("%d", &arr[i]);
        }
    
        printf("The array in reverse order is: ");
        for (i = n - 1; i >= 0; i--) {
            printf("%d ", arr[i]);
        }
        printf("\n");
    
        return 0;
    } 
                        </code>
                        <p>OUTPUT</p>
                    <code>
Enter the number of elements: 5
Enter the elements:
Enter element 1: 10
Enter element 2: 20
Enter element 3: 30
Enter element 4: 40
Enter element 5: 50
The array in reverse order is: 50 40 30 20 10
                    </code>

                        </pre>
    
                </section>
                <section id="arr3">
                    <p>Q-3:Enter an array from user and copy the array into second array ?</p>
                    <pre>
                        <code>
#include <stdio.h>

int main() {
    int n, i;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int firstArray[n], secondArray[n];

    printf("Enter the elements of the first array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &firstArray[i]);
        secondArray[i] = firstArray[i];
    }

    printf("Elements of the second array (copy): ");
    for (i = 0; i < n; i++) {
        printf("%d ", secondArray[i]);
    }
    printf("\n");

    return 0;
}                         
    
    
                        </code>
                        <p>OUTPUT</p>
                    <code>
Enter the number of elements: 4
Enter the elements of the first array:
Enter element 1: 10
Enter element 2: 20
Enter element 3: 30
Enter element 4: 40
Elements of the second array (copy): 10 20 30 40
                    </code>
                        </pre>
    
                </section>
                <section id="arr4">
                    <p>Q-4:Enter an array from user and copy it into another array in reverse order ?</p>
                    <pre>
                        <code>
#include <stdio.h>

int main() {
    int n, i;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int firstArray[n], secondArray[n];

    printf("Enter the elements of the first array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &firstArray[i]);
    }

    printf("Copying the array in reverse order...\n");
    for (i = 0; i < n; i++) {
        secondArray[i] = firstArray[n - 1 - i];
    }

    printf("Elements of the second array (copy in reverse order): ");
    for (i = 0; i < n; i++) {
        printf("%d ", secondArray[i]);
    }
    printf("\n");

    return 0;
}
                        </code>
                        <p>OUTPUT</p>
                    <code>
Enter the number of elements: 5
Enter the elements of the first array:
Enter element 1: 10
Enter element 2: 20
Enter element 3: 30
Enter element 4: 40
Enter element 5: 50
Copying the array in reverse order...
Elements of the second array (copy in reverse order): 50 40 30 20 10                        
                    </code>
                        </pre>
                </section>
                <section id="arr5">
                    <p>Q-5:Enter an array from user and print the number which is even ?</p>
                    <pre>
                        <code>
#include <stdio.h>

int main() {
    int n, i;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("Even numbers in the array are: ");
    for (i = 0; i < n; i++) {
        if (arr[i] % 2 == 0) {
            printf("%d ", arr[i]);
        }
    }
    printf("\n");

    return 0;
}   
                        </code>
                        <p>OUTPUT</p>
                    <code>
Enter the number of elements: 5
Enter the elements of the array:
Enter element 1: 10
Enter element 2: 25
Enter element 3: 12
Enter element 4: 7
Enter element 5: 16
Even numbers in the array are: 10 12 16
                    </code>

                        </pre>
    
                </section>
                <section id="arr6">
                    <p>Q-6:Enter an array from user and print the number which is positive ?</p>
                    <pre>
                        <code>
#include <stdio.h>

int main() {
    int n, i;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("Positive numbers in the array are: ");
    for (i = 0; i < n; i++) {
        if (arr[i] > 0) {
            printf("%d ", arr[i]);
        }
    }
    printf("\n");

    return 0;
}
                        </code>
                        <p>OUTPUT</p>
                    <code>
Enter the number of elements: 6
Enter the elements of the array:
Enter element 1: 10
Enter element 2: -5
Enter element 3: 0
Enter element 4: 12
Enter element 5: -8
Enter element 6: 7
Positive numbers in the array are: 10 12 7
                    </code>

                        </pre>
                </section>
                <section id="arr7">
                    <p>Q-7:Enter an array from user and square all the values of array ?</p>
                    <pre>
                        <code>
#include <stdio.h>

int main() {
    int n, i;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("Square of all values of the array: ");
    for (i = 0; i < n; i++) {
        printf("%d ", arr[i] * arr[i]);
    }
    printf("\n");

    return 0;
}
                        </code>
                        <p>OUTPUT</p>
                    <code>
Enter the number of elements: 4
Enter the elements of the array:
Enter element 1: 5
Enter element 2: -3
Enter element 3: 2
Enter element 4: 8
Square of all values of the array: 25 9 4 64
                    </code>

                        </pre>
    
                </section>
                <section id="arr8">
                    <p>Q-8:Enter an array from user and find maximum and minimum value?</p>
                    <pre>
                        <code>
#include <stdio.h>

int main() {
    int n, i;
    int max, min;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    max = arr[0];
    min = arr[0];

    for (i = 1; i < n; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
        if (arr[i] < min) {
            min = arr[i];
        }
    }

    printf("Maximum value: %d\n", max);
    printf("Minimum value: %d\n", min);

    return 0;
}
                        </code>
                        <p>OUTPUT</p>
                    <code>
Enter the number of elements: 5
Enter the elements of the array:
Enter element 1: 10
Enter element 2: 25
Enter element 3: 7
Enter element 4: 14
Enter element 5: 3
Maximum value: 25
Minimum value: 3
                    </code>
                        </pre>
    
                </section>
                <section id="arr9">
                    <p>Q-9:Enter an array from user and find the k-th smallest value?</p>
                    <pre>
                        <code>
#include <stdio.h>

int main() {
    int n, i, k;
    int temp;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("Enter the value of k: ");
    scanf("%d", &k);

    // Using bubble sort to sort the array
    for (i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }

    printf("The %dth smallest value is: %d\n", k, arr[k - 1]);

    return 0;
}
                        </code>
                        <p>OUTPUT</p>
                    <code>
Enter the number of elements: 6
Enter the elements of the array:
Enter element 1: 10
Enter element 2: 5
Enter element 3: 8
Enter element 4: 3
Enter element 5: 12
Enter element 6: 7
Enter the value of k: 3
The 3th smallest value is: 7
                    </code>
                        </pre>
    
                </section>
                <section id="arr10">
                    <p>-Q-10:Enter an array from user and add all values ?</p>
                    <pre>
                        <code>
   #include <stdio.h>

int main() {
    int n, i, sum = 0;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
        sum += arr[i];
    }

    printf("Sum of all values in the array: %d\n", sum);

    return 0;
}
                        </code>
                        <p>OUTPUT</p>
                    <code>
Enter the number of elements: 4
Enter the elements of the array:
Enter element 1: 5
Enter element 2: 10
Enter element 3: 15
Enter element 4: 20
Sum of all values in the array: 50
                    </code>

                        </pre>
    
                </section>
                <section id="arr11">
                    <p>Q-11:Enter an array from user and find the duplicate values?</p>
                    <pre>
                        <code>
#include <stdio.h>

int main() {
    int n, i, j;
    int count;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("Duplicate values in the array are: ");
    for (i = 0; i < n; i++) {
        count = 0;
        for (j = i + 1; j < n; j++) {
            if (arr[i] == arr[j]) {
                count++;
                break;
            }
        }
        if (count > 0) {
            printf("%d ", arr[i]);
        }
    }
    printf("\n");

    return 0;
}
                        </code>
                        <p>OUTPUT</p>
                    <code>
                        
                    </code>
Enter the number of elements: 8
Enter the elements of the array:
Enter element 1: 4
Enter element 2: 2
Enter element 3: 6
Enter element 4: 8
Enter element 5: 2
Enter element 6: 6
Enter element 7: 4
Enter element 8: 10
Duplicate values in the array are: 4 2 6
                        </pre>
    
                </section>
                <section id="arr12">
                    <p>Q-12:Enter an array from user and remove the duplicate values and fill with zero?</p>
                    <pre>
                        <code>
#include <stdio.h>

int main() {
    int n, i, j;
    int count;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    for (i = 0; i < n - 1; i++) {
        for (j = i + 1; j < n; j++) {
            if (arr[i] == arr[j]) {
                arr[j] = 0;
            }
        }
    }

    printf("Array after removing duplicates and filling with zeros: ");
    for (i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    return 0;
}
                        </code>
                        <p>OUTPUT</p>
                        <code>
Enter the number of elements: 7
Enter the elements of the array:
Enter element 1: 3
Enter element 2: 4
Enter element 3: 5
Enter element 4: 3
Enter element 5: 6
Enter element 6: 4
Enter element 7: 5
Array after removing duplicates and filling with zeros: 3 4 5 0 6 0 0
                        </code>
                        </pre>
    
                </section>
                <section id="arr13">
                    <p>Q-13:Enter an array from user and count the duplicate values?</p>
                    <pre>
                        <code>
#include <stdio.h>

int main() {
    int n, i, j;
    int count, total_count = 0;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    for (i = 0; i < n - 1; i++) {
        count = 0;
        for (j = i + 1; j < n; j++) {
            if (arr[i] == arr[j]) {
                count++;
                break;
            }
        }
        if (count > 0) {
            total_count++;
        }
    }

    printf("Total number of duplicate values in the array: %d\n", total_count);

    return 0;
}  
    
    
                        </code>
                        <p>OUTPUT</p>
                        <code>
Enter the number of elements: 6
Enter the elements of the array:
Enter element 1: 5
Enter element 2: 3
Enter element 3: 5
Enter element 4: 2
Enter element 5: 7
Enter element 6: 3
Total number of duplicate values in the array: 2                            
                        </code>
                        </pre>
    
                </section>
                <section id="arr14">
                    <p>Q-14:Enter an array from user and print all possible combinations of the elements?</p>
                    <pre>
                        <code>

    
    
                        </code>
                        <p>OUTPUT</p>
                        <code>
 
                        </code>
                        </pre>
    
                </section>
                <section id="arr15">
                    <p>Q-15:Enter an array from user and print all the palindrone numbers?</p>
                    <pre>
                        <code>
#include <stdio.h>

int isPalindrome(int num) {
    int reversed = 0;
    int original = num;

    while (num > 0) {
        int remainder = num % 10;
        reversed = reversed * 10 + remainder;
        num /= 10;
    }

    return original == reversed;
}

int main() {
    int n, i;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("Palindrome numbers in the array are: ");
    for (i = 0; i < n; i++) {
        if (isPalindrome(arr[i])) {
            printf("%d ", arr[i]);
        }
    }
    printf("\n");

    return 0;
}
    
    
    
                        </code>
                        <p>OUTPUT</p>
                        <code>
Enter the number of elements: 5
Enter element 1: 121
Enter element 2: 34
Enter element 3: 1551
Enter element 4: 67
Enter element 5: 12321
Palindrome numbers in the array are: 121 1551 12321                            
                        </code>
                        </pre>
    
                </section>
                <section id="arr16">
                    <p>Q-16:Enter two arrays from the user and check they are same or not?</p>
                    <pre>
                        <code>
#include <stdio.h>
#include <stdbool.h>

bool areEqual(int arr1[], int arr2[], int n) {
    for (int i = 0; i < n; i++) {
        if (arr1[i] != arr2[i]) {
            return false;
        }
    }
    return true;
}

int main() {
    int n, i;

    printf("Enter the number of elements in the arrays: ");
    scanf("%d", &n);

    int arr1[n], arr2[n];

    printf("Enter the elements of the first array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr1[i]);
    }

    printf("Enter the elements of the second array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr2[i]);
    }

    if (areEqual(arr1, arr2, n)) {
        printf("The arrays are the same.\n");
    } else {
        printf("The arrays are not the same.\n");
    }

    return 0;
}   
                        </code>
                        <p>OUTPUT</p>
                        <code>
Enter the number of elements in the arrays: 4
Enter the elements of the first array:
Enter element 1: 2
Enter element 2: 5
Enter element 3: 3
Enter element 4: 8
Enter the elements of the second array:
Enter element 1: 2
Enter element 2: 5
Enter element 3: 3
Enter element 4: 8
The arrays are the same.                           
                        </code>
                        </pre>
    
                </section>
                <section id="arr17">
                    <p>-Q-17:Merge the two sorted arrays into one array but in sorted order?</p>
                    <pre>
                        <code>
    #include <stdio.h>

int main() {
    int n, m, i, j, k;

    printf("Enter the number of elements in the first array: ");
    scanf("%d", &n);

    int arr1[n];

    printf("Enter the elements of the first array in sorted order:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr1[i]);
    }

    printf("Enter the number of elements in the second array: ");
    scanf("%d", &m);

    int arr2[m];

    printf("Enter the elements of the second array in sorted order:\n");
    for (i = 0; i < m; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr2[i]);
    }

    int merged[n + m];
    i = 0,j = 0,k = 0;

    while (i < n && j < m) {
        if (arr1[i] < arr2[j]) {
            merged[k] = arr1[i];
            i++;
        } else {
            merged[k] = arr2[j];
            j++;
        }
        k++;
    }

    while (i < n) {
        merged[k] = arr1[i];
        i++;
        k++;
    }

    while (j < m) {
        merged[k] = arr2[j];
        j++;
        k++;
    }

    printf("Merged array in sorted order: ");
    for (i = 0; i < n + m; i++) {
        printf("%d ", merged[i]);
    }
    printf("\n");

    return 0;
}
                        </code>
Enter the number of elements in the first array: 4
Enter the elements of the first array in sorted order:
Enter element 1: 2
Enter element 2: 4
Enter element 3: 6
Enter element 4: 8
Enter the number of elements in the second array: 3
Enter the elements of the second array in sorted order:
Enter element 1: 1
Enter element 2: 3
Enter element 3: 7
Merged array in sorted order: 1 2 3 4 6 7 8
                        </pre>
                    
                </section>
                <section id="arr18">
                    <p>Q-18:Find the local minima in the array? (An element in an array is a local minima if it less than the element after it, and the element before it)</p>
                    <pre>
                        <code>
   #include <stdio.h>

void findLocalMinima(int arr[], int n) {
    if (n == 0) {
        return;
    }

    if (arr[0] < arr[1]) {
        printf("%d ", arr[0]);
    }

    for (int i = 1; i < n - 1; i++) {
        if (arr[i] < arr[i - 1] && arr[i] < arr[i + 1]) {
            printf("%d ", arr[i]);
        }
    }

    if (arr[n - 1] < arr[n - 2]) {
        printf("%d ", arr[n - 1]);
    }
}

int main() {
    int n, i;

    printf("Enter the number of elements in the array: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("Local minima in the array: ");
    findLocalMinima(arr, n);
    printf("\n");

    return 0;
}
                        </code>
                        <p>OUTPUT</p>
                        <code>
Enter the number of elements in the array: 7
Enter the elements of the array:
Enter element 1: 3
Enter element 2: 2
Enter element 3: 4
Enter element 4: 1
Enter element 5: 6
Enter element 6: 5
Enter element 7: 3
Local minima in the array: 2 1 3                         
                        </code>
                        </pre>
                </section>
                <section id="arr19">
                    <p>Q-19:Find the local maxima in the array? (An element in an array is a local maxima if it greater than the element after it, and the element before it)</p>
                    <pre>
                        <code>
#include <stdio.h>

void findLocalMaxima(int arr[], int n) {
    if (n == 0) {
        return;
    }

    if (arr[0] > arr[1]) {
        printf("%d ", arr[0]);
    }

    for (int i = 1; i &lt n - 1; i++) {
        if (arr[i] > arr[i - 1] && arr[i] > arr[i + 1]) {
            printf("%d ", arr[i]);
        }
    }

    if (arr[n - 1] > arr[n - 2]) {
        printf("%d ", arr[n - 1]);
    }
}

int main() {
    int n, i;

    printf("Enter the number of elements in the array: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i&lt n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("Local maxima in the array: ");
    findLocalMaxima(arr, n);
    printf("\n");

    return 0;
}
                        </code>
                        <p>OUTPUT</p>
                        <code>
   Enter the number of elements in the array: 6
Enter the elements of the array:
Enter element 1: 2
Enter element 2: 4
Enter element 3: 3
Enter element 4: 6
Enter element 5: 5
Enter element 6: 1
Local maxima in the array: 4 6 5                         
                        </code>
                        </pre>
                </section>
                <section id="arr20">
                    <p>Q-20:Trapping Rain Water Problem</p>
                    <pre>
                        <code>
 
    
    
                        </code>
                        <p>OUTPUT</p>
                        <code>
                            
                        </code>
                        </pre>
                </section>
        </ul>
    </section>

    <section id="2darrays">
        <h2>2D-ARRAY PROBLEMS</h2>
        <ul>
        <li><a href="#2darr1">Q-1:Enter a matrix of 4 rows and 2 columns from the user display it in matrix format?</a></li>
        <li><a href="#2darr2">Q-2:Enter two Matrices from user, add the matrices and display the answer?</a></li>
        <li><a href="#2darr3">Q-3:Enter two Matrices from user, subtract the matrices and display the answer?</a></li>
        <li><a href="#2darr4">Q-4:Enter two Matrices from user, multiply the matrices and display the answer?</a></li>
        <li><a href="#2darr5">Q-5:Enter a Matrix from user, copy it in another matrix of same size?</a></li>
        <li><a href="#2darr6">Q-6:Enter the Matrix from user, multiply it with a scalar value and display the answer?</a></li>
        <li><a href="#2darr7">Q-7:Create a tic tac toe game using 2D Arrays.</a></li>

        <section id="2darr1">
            <p>Q-1:Enter a matrix of 4 rows and 2 columns from the user display it in matrix format?</p>
            <pre>
            <code >
#include<stdio.h>
void main()
{
    int rows=4,cols=2;
    int arr1[rows][cols],arr2[rows][cols],i,j;
    printf("Enter the matrix\n");
    for(i=0;i &lt rows;i++){
        for(j=0;j &lt cols;j++){
            printf("Enter element at matrix[%d][%d]",i,j);
            scanf("%d",&arr1[i][j]);
        }
    }
        for(j=0;j &lt cols;j++){
            arr2[i][j]=arr1[i][j];
        }
    }

    printf("Elements in copied array\n");
    for(i=0;i &lt rows;i++){
        for(j=0;j &lt cols;j++){
            printf("%d ",arr2[i][j]);

        }
        printf("\n");
    }
    
} 
            </code>
            <p>OUTPUT</p>
            <code>
Enter the matrix
Enter element at matrix[0][0]1
Enter element at matrix[0][1]1
Enter element at matrix[1][0]2
Enter element at matrix[1][1]2
Enter element at matrix[2][0]3
Enter element at matrix[2][1]3
Enter element at matrix[3][0]4
Enter element at matrix[3][1]4
Elements in copied array
1 1 
2 2 
3 3 
4 4
            </code>
            </pre>

            </section>

            <section id="2darr2">
                <p>Q-2:Enter two Matrices from user, add the matrices and display the answer?</p>
                <pre>
                <code >
#include<stdio.h>
void main(){
    int arr1[3][3],arr2[3][3],res[3][3],i,j;
    printf("Enter the first matrix");
    for(i=0;i &lt 3;i++){
        for(j=0;j &lt 3;j++){
            printf("Enter element at matrix1[%d][%d]",i,j);
            scanf("%d",&arr1[i][j]);
        }
    }
    printf("Enter the second matrix");
    for(i=0;i &lt 3;i++){
        for(j=0;j &lt 3;j++){
            printf("Enter element at matrix2[%d][%d]",i,j);
            scanf("%d",&arr2[i][j]);
        }
    }
    for(i=0;i &lt 3;i++){
        for(j=0;j &lt 3;j++){
            res[i][j]=arr1[i][j]+arr2[i][j];
        }
    }
    for(i=0;i &lt 3;i++){
        for(j=0;j &lt 3;j++){
            printf("%d  ",res[i][j]);
        }
        printf("\n");
    }
}
                </code>
                <p>OUTPUT</p>
                <code>
Enter the first matrix
Enter element at matrix1[0][0]: 1
Enter element at matrix1[0][1]: 2
Enter element at matrix1[0][2]: 3
Enter element at matrix1[1][0]: 4
Enter element at matrix1[1][1]: 5
Enter element at matrix1[1][2]: 6
Enter element at matrix1[2][0]: 7
Enter element at matrix1[2][1]: 8
Enter element at matrix1[2][2]: 9
Enter the second matrix
Enter element at matrix2[0][0]: 9
Enter element at matrix2[0][1]: 8
Enter element at matrix2[0][2]: 7
Enter element at matrix2[1][0]: 6
Enter element at matrix2[1][1]: 5
Enter element at matrix2[1][2]: 4
Enter element at matrix2[2][0]: 3
Enter element at matrix2[2][1]: 2
Enter element at matrix2[2][2]: 1
Resultant matrix after addition is:
10  10  10  
10  10  10  
10  10  10
                </code>
                </pre>

                </section>

                <section id="2darr3">
                    <p>Q-3:Enter two Matrices from user, subtract the matrices and display the answer?</p>
                    <pre>
                    <code >
#include<stdio.h>
void main(){
    
    int arr1[3][3],arr2[3][3],res[3][3],i,j;
    printf("Enter the first matrix");
    for(i=0;i &lt 3;i++){
        for(j=0;j &lt 3;j++){
            printf("Enter element at matrix1[%d][%d]",i,j);
            scanf("%d",&arr1[i][j]);
        }
    }
    printf("Enter the second matrix");
    for(i=0;i &lt 3;i++){
        for(j=0;j &lt 3;j++){
            printf("Enter element at matrix2[%d][%d]",i,j);
            scanf("%d",&arr2[i][j]);
        }
    }
    for(i=0;i &lt 3;i++){
        for(j=0;j &lt 3;j++){
            res[i][j]=arr1[i][j]-arr2[i][j];
        }
    }
    for(i=0;i &lt 3;i++){
        for(j=0;j &lt 3;j++){
            printf("%d  ",res[i][j]);
        }
        printf("\n");
    }
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
Enter the first matrix:
Enter element at matrix1[0][0]: 4
Enter element at matrix1[0][1]: 6
Enter element at matrix1[0][2]: 8
Enter element at matrix1[1][0]: 2
Enter element at matrix1[1][1]: 3
Enter element at matrix1[1][2]: 5
Enter element at matrix1[2][0]: 9
Enter element at matrix1[2][1]: 7
Enter element at matrix1[2][2]: 1
Enter the second matrix:
Enter element at matrix2[0][0]: 1
Enter element at matrix2[0][1]: 2
Enter element at matrix2[0][2]: 3
Enter element at matrix2[1][0]: 4
Enter element at matrix2[1][1]: 5
Enter element at matrix2[1][2]: 6
Enter element at matrix2[2][0]: 7
Enter element at matrix2[2][1]: 8
Enter element at matrix2[2][2]: 9
Resultant matrix after subtraction is:
3  4  5  
-2  -2  -1  
2  -1  -8
                    </code>
                    </pre>

                    </section>

                    <section id="2darr4">
                    <p>Q-4:Enter two Matrices from user, multiply the matrices and display the answer?</p>
                    <pre>
                    <code >
#include<stdio.h>
void main(){
int arr1[3][3],arr2[3][3],res[3][3]={0},i,j,k,size;
    printf("Enter the number of rows and columns");
    scanf("%d",&size);
    printf("Enter the first matrix");
    for(i=0;i &lt size;i++){
        for(j=0;j &lt size;j++){
            printf("Enter element at matrix1[%d][%d]",i,j);
            scanf("%d",&arr1[i][j]);
        }
    }
    printf("Enter the second matrix");
    for(i=0;i &lt size;i++){
        for(j=0;j &lt size;j++){
            printf("Enter element at matrix1[%d][%d]",i,j);
            scanf("%d",&arr2[i][j]);
        }
    }
     for ( i = 0; i &lt size; i++)
    {
        for(j=0;j &lt size;j++){
           
            for(k=0;k &lt size;k++){
                res[i][j]+=arr1[i][k] * arr2[k][j];
            }
        }
    }
    printf("Product of matrices\n");
    for(i=0;i &lt size;i++){
        for(j=0;j &lt size;j++){
            printf("%d ",res[i][j]);    
        }
        printf("\n");
    }

}
                    </code>
                    <p>OUTPUT</p>
                    <code>
Enter elements of the first matrix:
Enter element at matrix1[0][0]: 1
Enter element at matrix1[0][1]: 2
Enter element at matrix1[0][2]: 3
Enter element at matrix1[1][0]: 4
Enter element at matrix1[1][1]: 5
Enter element at matrix1[1][2]: 6
Enter element at matrix1[2][0]: 7
Enter element at matrix1[2][1]: 8
Enter element at matrix1[2][2]: 9
Enter elements of the second matrix:
Enter element at matrix2[0][0]: 9
Enter element at matrix2[0][1]: 8
Enter element at matrix2[0][2]: 7
Enter element at matrix2[1][0]: 6
Enter element at matrix2[1][1]: 5
Enter element at matrix2[1][2]: 4
Enter element at matrix2[2][0]: 3
Enter element at matrix2[2][1]: 2
Enter element at matrix2[2][2]: 1
Product of the matrices is:
30  24  18 
84  69  54 
138  114  90
                    </code>
                    </pre>

                    </section>

                    <section id="2darr5">
                        <p>Q-5:Enter a Matrix from user, copy it in another matrix of same size?</p>
                        <pre>
                        <code >
   #include<stdio.h>
void main()
{
    int rows,cols;
    printf("Enter the no. of rows");
    scanf("%d",&rows);
    printf("Enter the no. of cols");
    scanf("%d",&cols);
    int arr1[rows][cols],arr2[rows][cols],i,j;
    printf("Enter the matrix");
    for(i=0;i &lt rows;i++){
        for(j=0;j &lt cols;j++){
            printf("Enter element at matrix[%d][%d]",i,j);
            scanf("%d",&arr1[i][j]);
        }
    }
    for(i=0;i &lt rows;i++){
        for(j=0;j &lt cols;j++){
            arr2[i][j]=arr1[i][j];
        }
    }
    printf("Elements in copied array\n");
    for(i=0;i &lt rows;i++){
        for(j=0;j &lt cols;j++){
            printf("%d ",arr2[i][j]);

        }
        printf("\n");
    }
    
}
                        </code>
                        <p>OUTPUT</p>
                        <code>
Enter the no. of rows2
Enter the no. of cols3
Enter the matrixEnter element at matrix[0][0]1
Enter element at matrix[0][1]2
Enter element at matrix[0][2]3
Enter element at matrix[1][0]4
Enter element at matrix[1][1]5
Enter element at matrix[1][2]6
Elements in copied array
1 2 3 
4 5 6  
                        </code>
                        </pre>
    
                        </section>

                        <section id="2darr6">
                            <p>Q-6:Enter the Matrix from user, multiply it with a scalar value and display the answer?</p>
                            <pre>
                            <code >
#include<stdio.h>
void main(){
    int rows=4,cols=2;
    printf("Enter the number of rows ");
    scanf("%d",&rows);
    printf("Enter the number of columns");
    scanf("%d",&cols);
    int arr1[rows][cols],res[rows][cols],i,j,scalar;
    printf("Enter the scalar value");
    scanf("%d",&scalar);
    printf("Enter the matrix\n");
    for(i=0;i &lt rows;i++){
        for(j=0;j &lt cols;j++){
            printf("Enter element at matrix[%d][%d]",i,j);
            scanf("%d",&arr1[i][j]);
        }
    }
    for(i=0;i &lt rows;i++){
        for(j=0;j &lt cols;j++){
            res[i][j]=arr1[i][j]*scalar;
        }
    }
    for(i=0;i &lt rows;i++){
        for(j=0;j &lt cols;j++){
            printf("%d ",res[i][j]);
        }
        printf("\n");
    }
}        
                            </code>
                            <p>OUTPUT</p>
                            <code>
Enter the number of rows 2
Enter the number of columns2
Enter the scalar value3
Enter the matrix
Enter element at matrix[0][0]1
Enter element at matrix[0][1]2
Enter element at matrix[1][0]3
Enter element at matrix[1][1]1
3 6 
9 3       
                            </code>
                            </pre>
        
                            </section>

                            <section id="2darr7">
                                <p>Q-7:Create a tic tac toe game using 2D Arrays.</p>
                                <pre>
                                <code >
            
                                </code>
                                <p>OUTPUT</p>
                                <code>
            
                                </code>
                                </pre>
            
                                </section>

        </ul>
        </section>

    <section id="string">
        <h2>STRING PROBLEMS</h2>
        <ul>
            <li><a href="#st1">Q-1:Convert in uppercase ?</a></li>
            <li><a href="#st2">Q-2:Convert into lowercase ?</a></li>
            <li><a href="#st3">Q-3:Convert into sentence case ?</a></li>
            <li><a href="#st4">Q-4:Convert into title case ?</a></li>
            <li><a href="#st5">Q-5:Convert into toggle case ?</a></li>
            <li><a href="#st6">Q-6:Final length of the string ?</a></li>
            <li><a href="#st7">Q-7:Compare those string ?</a></li>
            <li><a href="#st8">Q-8:Concatenate the string ?</a></li>
            <li><a href="#st9">Q-9:Copy that string into another string ?</a></li>
            <li><a href="#st10">Q-10:Enter bound number and print character on that bound ?</a></li>
            <li><a href="#st11">Q-11:Check its palindrome or not?</a></li>
            <li><a href="#st12">Q-12:Print each character in new line ?</a></li>
            <li><a href="#st13">Q-13:Copy reverse order into another string ?</a></li>
            <li><a href="#st14">Q-14:ENTER THE STRING FROM THE USER AND PRINT THE DIFFERENCE OF ASCII VALUE OF EACH CHARACTER ?</a></li>
            <li><a href="#st15">Q-15:ENTER THE STRING FROM THE USER, ENTER A CHARACTER ALSO AND SEARCH THE CHARACTER IN THE STRING?</a></li>
            <li><a href="#st16">Q-16:ENTER THE STRING FROM THE USER, ALSO ENTER A CHARACTER AND PRINT THE INDEX OF THE CHARACTER IF IT IS EXIST IN THE STRING ELSE PRINT -1.</a></li>
            <li><a href="#st17">Q-17:ENTER THE STRING FROM THE USER, AND COUNT THE NUMBER OF VOWELS.</a></li>
            <li><a href="#st18">Q-18:ENTER THE STRING FROM THE USER AND CONVERT INTO AN INTEGER VALUE?</a></li>
            <li><a href="#st19">Q-19:ENTER THE STRING FROM THE USER AND CONVERT INTO A FLOAT VALUE?</a></li>
            <li><a href="#st20">Q-20:ENTER THE STRING FROM THE USER AND COUNT THE NUMBER OF CHARACTERS, WORDS, SPACES AND LINES</a></li>
            <li><a href="#st21">Q-21:PRINT ALL THE PERMUTATION OF A STRING I.E. "ABCDE".</a></li>
            <li><a href="#st22">Q-22:ENTER THE STRING FROM THE USER, SORT THE STRING IN ASCENDING ORDER AND PRINT IT.</a></li>
            <li><a href="#st23">Q-23:ENTER A SENTENCE FROM USER AND THEN ENTER THE WORD AND COUNT THE OCCURENCE OF THAT WORD IN THE SENTENCE.</a></li>
            <li><a href="#st24">Q-24:ENTER A SENTENCE FROM USER AND THEN ENTER THE WORD AND REPLACE THAT WORD BY ANOTHER WORD.</a></li>
            <li><a href="#st25">Q-25:ENTER THE STRING FROM THE USER AND TRIM/ ELIMINATE THE SPACES FROM BOTH ENDS (IF ANY).</a></li>
            <li><a href="#st26">Q-26:ENTER THE STRING FROM USER AND SPLITS THE FIRST WORD AND SECOND WORD AND RETURN THE START INDEX OF THE SECOND WORD.</a></li>
            <li><a href="#st27">Q-27:DISPLAY THE STRING ON THE OUTPUT SCREEN BUT ASK THE TEXT ALIGNMENT OPTION GIVEN BY THE USER (1 FOR LEFT, 2 FOR CENTER, 3 RIGHT)</a></li>
            <li><a href="#st28">Q-28:CREATE A DICTIONARY HAVING 10 WORDS AND THEIR MEANING WITH FOLLOWING OPERATIONS. [CREATE, DELETE, SEARCH].</a></li>
            <li><a href="#st29">Q-29:ENTER THE STRING FROM USER AND CONVERT CHARACTERS INTO THEIR ASCII VALUES IN THE INTEGER ARRAY. [FOR EXAMPLE TAKE 10 CHARACTERS]</a></li>
        <section id="st1">
            <p>Q-1:ENTER THE STRING FROM USER AND CONVERT IN UPPERCASE ?</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
void changeInUpper(char * str,int size){
    for(int i=0;i &lt size;i++){
        if(str[i]>='a' && str[i] &lt='z'){
            str[i]=str[i]-32;
        }
    }
}
void main(){
    char str[10];
    printf("Enter the string - \n");
    gets(str);
    changeInUpper(str,strlen(str));
    printf("After changing in Uppercase - %s",str);

}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
hello world
After changing in Uppercase - HELLO WORLD
            </code>
            </pre>

            </section>
        <section id="st2">
            <p>Q-2:ENTER THE STRING FROM USER AND CONVERT IN LOWERCASE ?</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
void changeInLower(char * str,int size){
    for(int i=0;i &lt size;i++){
        if(str[i]>='A' && str[i] &lt ='Z'){
            str[i]=str[i]+32;
        }
    }
}
void main(){
    char str[10];
    printf("Enter the string - \n");
    gets(str);
    changeInLower(str,strlen(str));
    printf("After changing in lowercase - %s",str);

}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
Hello WORLD
After changing in lowercase - hello world
            </code>
            </pre>

            </section>
        <section id="st3">
            <p>Q-3:ENTER THE STRING FROM USER AND CONVERT INTO SENTENCE CASE ?</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
void changeInSentenceCase(char * str,int size){
    if(str[0]>='a' && str[0] &lt='z'){
            str[0]=str[0]-32;
        }
    for(int i=1;i &lt size;i++){
        if(str[i]>='A' && str[i] &lt='Z'){
            str[i]=str[i]+32;
        }
    }
}
void main(){
    char str[10];
    printf("Enter the string - \n");
    gets(str);
    changeInSentenceCase(str,strlen(str));
    printf("After changing in Sentence case - %s",str);

}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
This is a SentENCE aS INpUT.      
After changing in Sentence case - This is a sentence as input
            </code>
            </pre>

            </section>
        <section id="st4">
            <p>Q-4:</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
void changeInTitleCase(char * str,int size){
    if(str[0]>='a' && str[0]&lt='z'){
            str[0]=str[0]-32;
        }
    for(int i=1;i &lt size;i++){
        if(str[i-1]==' '){
            if(str[i]>='a' && str[i]&lt='z'){
                str[i]=str[i]-32;
            }
        }
        else{
            if(str[i]>='A' && str[i]&lt='Z'){
                str[i]=str[i]+32;
            }
        }
    }
}
void main(){
    char str[10];
    printf("Enter the string - \n");
    gets(str);
    changeInTitleCase(str,strlen(str));
    printf("After changing in Sentence case - %s",str);

}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
coVERT thiS to TITLEcase.
After changing in Sentence case - Covert This To Titlecase.
            </code>
            </pre>

            </section>
        <section id="st5">
            <p>Q-5:</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
void changeInTitleCase(char * str,int size){
    if(str[0]>='A' && str[0]&lt='Z'){
            str[0]=str[0]+32;
        }
    for(int i=1;i &lt size;i++){
        if(str[i-1]==' '){
            if(str[i]>='A' && str[i]&lt='Z'){
                str[i]=str[i]+32;
            }
        }
        else{
            if(str[i]>='a' && str[i]&lt='z'){
                str[i]=str[i]-32;
            }
        }
    }
}
void main(){
    char str[10];
    printf("Enter the string - \n");
    gets(str);
    changeInTitleCase(str,strlen(str));
    printf("After changing in Sentence case - %s",str);

}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
Covert this to toggle case
After changing in Sentence case - cOVERT tHIS tO tOGGLE cASE
            </code>
            </pre>

            </section>
        <section id="st6">
            <p>Q-6:</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
int finalLength(char * str){
    int i=0,len = 0;
    while(str[i]!='\0'){
        len++;
        i++;
    }
    return len;
}
void main(){
    char str[10];
    printf("Enter the string - \n");
    gets(str);   
    printf("Final length of the string is - %d",finalLength(str));

}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
hello world
Final length of the string is - 11
            </code>
            </pre>

            </section>
        <section id="st7">
            <p>Q-7:</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
int finalLength(char * str){
    int i=0,len = 0;
    while(str[i]!='\0'){
        len++;
        i++;
    }
    return len;
}
int compareString(char * str,char * str2){
    int i=0;
    if(finalLength(str)!=finalLength(str2))
        return 0;
    while(str[i]){
        if(str[i]!=str2[i]){
            return 0;
        }
        i++;
    }
    return 1;
}
void main(){
    char str[20];
    char str2[20];
    printf("Enter the string1 - \n");
    gets(str);   
    printf("Enter the string2 - \n");
    gets(str2);   
    if(compareString(str,str2))
        printf("Strings are equal");
    else
        printf("Strings are not equal");
}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string1 - 
hello
Enter the string2 - 
world
Strings are not equal
            </code>
            </pre>

            </section>
        <section id="st8">
            <p>Q-8:</p>
            <pre>
            <code >
#include<stdio.h>
#include<stdlib.h>
int finalLength(char * str){
    int i=0,len = 0;
    while(str[i]!='\0'){
        len++;
        i++;
    }
    return len;
}
char * concatenateString(char * str,char * str2){
    int size = finalLength(str)+ finalLength(str2);
    char * strcat= (char *)malloc(size * sizeof(char));
    int i=0;
    while(str[i]){
        strcat[i]=str[i];
        i++;
    }
    int j=0;
    while(str2[j]){
        strcat[i]=str2[j];
        j++;
        i++;
    }
    return strcat;
}
void main(){
    char str[20];
    char str2[20];
    char * str3;
    printf("Enter the string1 - \n");
    gets(str);   
    printf("Enter the string2 - \n");
    gets(str2);   
    str3 = concatenateString(str,str2);
    printf("%s",str3);
    free(str3);
}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string1 - 
hello 
Enter the string2 -
world
hello world
            </code>
            </pre>

            </section>
        <section id="st9">
            <p>Q-9:</p>
            <pre>
            <code >
#include<stdio.h>
#include<stdlib.h>
int finalLength(char * str){
    int i=0,len = 0;
    while(str[i]!='\0'){
        len++;
        i++;
    }
    return len;
}
char * copyString(char * str){
    int size = finalLength(str)+1;
    char * strcopied= (char *)malloc(size * sizeof(char));
    int i=0;
    while(str[i]){
        strcopied[i]=str[i];
        i++;
    }
    strcopied[i]='\0';
    return strcopied;
}
void main(){
    char str[20];
    char * str2;
    printf("Enter the string - \n");
    gets(str);    
    str2 = copyString(str);
    printf("Original string - %s\n",str);
    printf("Copied string - %s",str2);
    free(str2);
} 
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
helloo world 
Original string - helloo world
Copied string - helloo world
            </code>
            </pre>

            </section>
        <section id="st10">
            <p>Q-10:</p>
            <pre>
            <code >
#include<stdio.h>
#include<stdlib.h>

void main(){
    char str[20];
    int index;
    printf("Enter the string - \n");
    gets(str); 
    printf("Enter the index number - \n");
    scanf("%d",&index);
    printf("Character at index %d is %c.",index,str[index]);
}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
hello world
Enter the index number -
6
Character at index 6 is w.
            </code>
            </pre>

            </section>
        <section id="st11">
            <p>Q-11:Check its palindrome or not?</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
int finalLength(char * str){
    int i=0,len = 0;
    while(str[i]!='\0'){
        len++;
        i++;
    }
    return len;
}
int checkPalindrome(char * str){
    int size = finalLength(str);
    for(int i=0;i&lt(size+1)/2;i++){
        if(str[i]!=str[size - i -1])
            return 0;
    }
    return 1;
}
void main(){
    char str[20];
    char * str2;
    printf("Enter the string - \n");
    gets(str);    
    if(checkPalindrome(str))
        printf("%s is pallindrome.",str);
    else
        printf("%s is not pallindrome.",str);
}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
level
level is pallindrome
            </code>
            </pre>

            </section>
        <section id="st12">
            <p>Q-12:Print each character in new line ?</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
char * printNewlines(char * str){
    int i=0;
    char * str2 = (char *)malloc(strlen(str)*sizeof(char));
    strcpy(str2,str);
    while(str2[i]){
        if(str2[i]==' ')
            str2[i]='\n';
        i++;
    }
    return str2;
}
void main(){
    char str[20];
    char * str2;
    printf("Enter the string - \n");
    gets(str);    
    str2= printNewlines(str);
    printf("%s",str2);
}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
this is a string
this
is
a
string
            </code>
            </pre>

            </section>
        <section id="st13">
            <p>Q-13:Copy reverse order into another string ?</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
char * copyReverse(char * str){
    int i= strlen(str) - 1,j=0;
    char * str2 = (char *)malloc(strlen(str)*sizeof(char));
    for(;i>=0;i--){
        str2[j++]= str[i];
    }
    str2[j]='\0';
    return str2;
}
void main(){
    char str[20];
    char * str2;
    printf("Enter the string - \n");
    gets(str);    
    str2= copyReverse(str);
    printf("%s",str2);
    free(str2);
}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
hello world
dlrow olle
            </code>
            </pre>

            </section>
        <section id="st14">
            <p>Q-14:ENTER THE STRING FROM THE USER AND PRINT THE DIFFERENCE OF ASCII VALUE OF EACH CHARACTER ?</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
int * diffOfAsciiValues(char * str1,char * str2){
    if(strlen(str1)!=strlen(str2))
        return NULL;
    int size= strlen(str1) + strlen(str2);
    int * str = (int *)malloc(size*sizeof(int));
    for(int i=0;i&ltstrlen(str1);i++){
        str[i]= str1[i] - str2[i];
    }
    return str;
}
void main(){
    char str1[20];
    char str2[20];
    int * str;
    printf("Enter the string1 - \n");
    gets(str1);    
    printf("Enter the string2 - \n");
    gets(str2);    
    str= diffOfAsciiValues(str1,str2);
    for(int i=0;i&ltstrlen(str1);i++){
        printf("%d ",str[i]);
    }
    free(str);
}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string1 - 
hello
Enter the string2 - 
world
-15 -10 -6 0 11
            </code>
            </pre>

            </section>
        <section id="st15">
            <p>Q-15:ENTER THE STRING FROM THE USER, ENTER A CHARACTER ALSO AND SEARCH THE CHARACTER IN THE STRING?</p>
            <pre>
            <code >

          #include<stdio.h>
#include<string.h>
#include<stdlib.h>
int findChar(char * str1,char x){
    int i=0;
    while(str1[i]){
        if(str1[i]==x)
            return i+1;
            i++;
    }
    return 0;
}
void main(){
    char str1[20];
    char str2;
    printf("Enter the string - \n");
    gets(str1);    
    printf("Enter the character - \n");
    scanf("%c",&str2);   
    int pos = findChar(str1,str2);
    if(pos)
        printf("%c is present at position %d",str2,pos);
    else
        printf("%c is not found");
        
}  </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
hello world
Enter the character -
o
o is present at position 5
            </code>
            </pre>

            </section>
        <section id="st16">
            <p>Q-16:ENTER THE STRING FROM THE USER, ALSO ENTER A CHARACTER AND PRINT THE INDEX OF THE CHARACTER IF IT IS EXIST IN THE STRING ELSE PRINT -1.</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
int findChar(char * str1,char x){
    int i=0;
    while(str1[i]){
        if(str1[i]==x)
            return i+1;
            i++;
    }
    return -1;
}
void main(){
    char str1[20];
    char str2;
    printf("Enter the string - \n");
    gets(str1);    
    printf("Enter the character - \n");
    scanf("%c",&str2);   
    int pos = findChar(str1,str2);
    if(pos!=-1)
        printf("%c is present at index %d",str2,pos);
    else
        printf("%d",pos);
        
} 
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
Hello world.
Enter the character - 
d
d is present at index 11
            </code>
            </pre>

            </section>
        <section id="st17">
            <p>Q-17:ENTER THE STRING FROM THE USER, AND COUNT THE NUMBER OF VOWELS.</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
int countVowels(char * str1){
    int i=0,count=0;
    while(str1[i]){
        if(str1[i]=='a'||str1[i]=='e'||str1[i]=='i'||str1[i]=='o'||str1[i]=='u'||str1[i]=='A'||str1[i]=='E'||str1[i]=='I'||str1[i]=='O'||str1[i]=='U')
            count++;
            i++;
    }
    return count;
}
void main(){
    char str1[20];char str2;
    printf("Enter the string - \n");
    gets(str1);    
    printf("No. of vowels = %d",countVowels(str1));  
    
        
} 
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
THis is a sentence. 
No. of vowels = 6
            </code>
            </pre>

            </section>
        <section id="st18">
            <p>Q-18:ENTER THE STRING FROM THE USER AND CONVERT INTO AN INTEGER VALUE?</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
void printStringInInt(char * arr){
    int i=0;
while(arr[i]){
    printf("%d ",arr[i++]);
}
}

void main(){
    char str[30]; 
    printf("Enter the string.\n");
    gets(str);
    printStringInInt(str);
}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string.
this is a string.
116 104 105 115 32 105 115 32 97 32 115 116 114 105 110 103 46
            </code>
            </pre>

            </section>
        <section id="st20">
            <p>Q-20:ENTER THE STRING FROM THE USER AND COUNT THE NUMBER OF CHARACTERS, WORDS, SPACES AND LINES</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
int countchar(char * str1){
    int i=0,countchar=0;
    while(str1[i]){
        if(str1[i]>='a' && str1[i]&lt='z'|| str1[i]>='A'&& str1[i]&lt='Z')
            countchar++;
    i++;
    }
    return countchar;
}
int countspaces(char * str1){
    int i=0,spaces=0;
    while(str1[i]){
        if(str1[i]==' ')
            spaces++;
    i++;
    }
    return spaces;
}
int countlines(char * str1){
    int i=0,countlines=0;
    while(str1[i]){
        if(str1[i]=='.')
            countlines++;
    i++;
    }
    return countlines;
}
void main(){
    char str1[20];char str2;
    printf("Enter the string - \n");
    gets(str1);    
    printf("No. of character = %d\n",countchar(str1));  
    printf("No. of words = %d\n",countspaces(str1)+1);  
    printf("No. of spaces = %d\n",countspaces(str1));  
    printf("No. of lines = %d\n",countlines(str1));          
}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
This is first line.This is second line. 
No. of character = 31
No. of words = 7
No. of spaces = 6
No. of lines = 2
            </code>
            </pre>

            </section>
        <section id="st21">
            <p>Q-21:PRINT ALL THE PERMUTATION OF A STRING I.E. "ABCDE".</p>
            <pre>
            <code >
#include <stdio.h>
#include <string.h>

void swap(char *x, char *y) {
    char temp = *x;
    *x = *y;
    *y = temp;
}

void permute(char *str, int l, int r) {
    if (l == r) {
        printf("%s\n", str);
    } else {
        for (int i = l; i &lt= r; i++) {
            swap((str + l), (str + i));
            permute(str, l + 1, r);
            swap((str + l), (str + i)); 
        }
    }
}

int main() {
    char str[] = "abcde";
    int n = strlen(str);
    printf("Printing all combinations-\n");
    permute(str, 0, n - 1);
    return 0;
}
            </code>
            <p>OUTPUT</p>
            <code>
Printing all combinations-
abcde
abced
abdce
abdec
abedc
abecd
acbde
acbed
acdbe
acdeb
acedb
acebd
adcbe
adceb
adbce
adbec
adebc
adecb
aecdb
aecbd
aedcb
aedbc
aebdc
aebcd
bacde
baced
badce
badec
baedc
baecd
bcade
bcaed
bcdae
bcdea
bceda
bcead
bdcae
bdcea
bdace
bdaec
bdeac
bdeca
becda
becad
bedca
bedac
beadc
beacd
cbade
cbaed
cbdae
cbdea
cbeda
cbead
cabde
cabed
cadbe
cadeb
caedb
caebd
cdabe
cdaeb
cdbae
cdbea
cdeba
cdeab
ceadb
ceabd
cedab
cedba
cebda
cebad
dbcae
dbcea
dbace
dbaec
dbeac
dbeca
dcbae
dcbea
dcabe
dcaeb
dceab
dceba
dacbe
daceb
dabce
dabec
daebc
daecb
decab
decba
deacb
deabc
debac
debca
ebcda
ebcad
ebdca
ebdac
ebadc
ebacd
ecbda
ecbad
ecdba
ecdab
ecadb
ecabd
edcba
edcab
edbca
edbac
edabc
edacb
eacdb
eacbd
eadcb
eadbc
eabdc
eabcd
            </code>
            </pre>

            </section>
        <section id="st22">
            <p>Q-22:ENTER THE STRING FROM THE USER, SORT THE STRING IN ASCENDING ORDER AND PRINT IT.</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
char * sortString( char * arr){
        int size = strlen(arr);
        int i,j;
        char temp;
        for(i=0;i &lt size;i++){
            for(j=0;j&ltsize - i -1;j++){
                if(arr[j]>arr[j+1]){
                    temp = arr[j];
                    arr[j]= arr[j+1];
                    arr[j+1] = temp; 
                }
            }
        }
return arr;
}
void main(){
    char str[50];
    printf("Enter the string.\n");
    gets(str);
    int i=0;
    char * str1 = sortString(str);
    while(i&ltstrlen(str1)){
        if(str1[i]!=' ' && str1[i]!='.')
            printf("%c ",str1[i]);
        i++;
    }
}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string.
hello world.this is a string.
a d e g h h i i i l l l n o o r r s s s t t w
            </code>
            </pre>

            </section>
        <section id="st23">
            <p>Q-23:ENTER A SENTENCE FROM USER AND THEN ENTER THE WORD AND COUNT THE OCCURENCE OF THAT WORD IN THE SENTENCE.</p>
            <pre>
            <code >
#include<stdio.h>

int countOccurence(char * arr,char * word){
    int i=0,count =0;
    while(arr[i]){
        int j =0,flag=1;
        while(arr[i]!=' '&& arr[i]!='.'){
            if(arr[i]==word[j]){
                i++;
                j++;
            }
            else{
                flag =0;
                while(arr[i]!=' '&& arr[i]!='.'){
                    i++;
                }
            }
        }
        if(flag==1)
            count++;
    
    i++;
    }
    
return count;
}
void main(){
    char str[30];
    char word[15];
    printf("Enter the string");
    gets(str);
    printf("Enter the word");
    gets(word);
    printf("%s occurs %d times",word, countOccurence(str,word));
}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string
This is a word that is - is. 
Enter the word
is
is occurs 3 times
            </code>
            </pre>

            </section>
        <section id="st24">
            <p>Q-24:Enter a sentence from user and then enter the word and replace that word by another word.</p>
            <pre>
            <code >
#include<stdio.h>
#include<stblib.h>
#include<string.h>
char * replaceWord(char * arr,char * word,char * replacingword){
    int i=0,count =0,k;
    int newsize = strlen(arr)+strlen(replacingword);
    int initial;
    char * newarr = (char *)malloc(newsize*sizeof(char));
    while(arr[i]){
        int j =0,flag=1;
        while(arr[i]!=' '&& arr[i]!='.'){
            initial = i-1;
            if(arr[i]==word[j]){
                i++;
                j++;
            }
            else{
                flag =0;
                while(arr[i]!=' '&& arr[i]!='.'){
                    i++;
                    initial = -1;
                }
            }
        }
        if(flag==1){
            i =j=k  = 0;
            while(arr[i]){
                if(i!=initial){
                    newarr[j] = arr[i];
                    i++;
                    j++;
                }
                else{
                    while(replacingword[k]){
                        newarr[j]=replacingword[k];
                        k++;
                        j++;
                    }
                    while(arr[i]!=' ' && arr[i]!='.'){
                        i++;
                    }
                }
            }
        }
    
    i++;
    }
    
return newarr;
}
void main(){
    char str[30];
    char word[15];
    char replaceby[15];
    printf("Enter the string");
    gets(str);
    printf("Enter the  word to replace");
    gets(word);
    printf("Enter the word by which word will be replaced. ");
    gets(replaceby);
    char * new;
    new = replaceWord(str,word,replaceby);
    printf("%s",new);
} 
            </code>
            <p>OUTPUT</p>
            <code>

            </code>
            </pre>

            </section>
        <section id="st25">
            <p>Q-25:ENTER THE STRING FROM THE USER AND TRIM/ ELIMINATE THE SPACES FROM BOTH ENDS (IF ANY).</p>
            <pre>
            <code >
#include <stdio.h>
#include <string.h>

char *trimString(char *str) {
    int i = 0, j = strlen(str) - 1;

    while (str[i] == ' ') {
        i++;
    }

    while (j > i && str[j] == ' ') {
        j--;
    }

    for (int k = 0; k &lt= j - i; k++) {
        str[k] = str[i + k];
    }

    str[j - i + 1] = '\0';
    return str;
}

int main() {
    char str[100];
    printf("Enter a string: ");
    gets(str);

    char *trimmedString = trimString(str);
    printf("Trimmed string: %s\n", trimmedString);

    return 0;
}

            </code>
            <p>OUTPUT</p>
            <code>
Enter a string:            this is a string
Trimmed string: this is a string
            </code>
            </pre>

            </section>
        <section id="st26">
            <p>Q-26:ENTER THE STRING FROM USER AND SPLITS THE FIRST WORD AND SECOND WORD AND RETURN THE START INDEX OF THE SECOND WORD.</p>
            <pre>
            <code >

            </code>
            <p>OUTPUT</p>
            <code>

            </code>
            </pre>

            </section>
        <section id="st27">
            <p>Q-27:Display the string with text alignment option (1 for left, 2 for center, 3 right)</p>
            <pre>
            <code >
#include <stdio.h>
#include <string.h>

int split(char *str, char *firstWord, char *secondWord) {
    int i, j = 0, startIndexOfSecond = -1;
    int len = strlen(str);

    for (i = 0; i &lt len && str[i] != ' ' && str[i] != '\t' && str[i] != '\n'; i++) {
        firstWord[i] = str[i];
    }
    firstWord[i] = '\0';

    while (i &lt len && (str[i] == ' ' || str[i] == '\t' || str[i] == '\n')) {
        i++;
    }

    startIndexOfSecond = i;
    for (; i &lt len; i++) {
        secondWord[j++] = str[i];
    }
    secondWord[j] = '\0';

    return startIndexOfSecond;
}

int main() {
    char str[100], firstWord[50], secondWord[50];
    printf("Enter a string: ");
    fgets(str, sizeof(str), stdin);

    int startIndexOfSecond = split(str, firstWord, secondWord);

    printf("First word: %s\n", firstWord);
    printf("Second word: %s\n", secondWord);
    printf("Start index of the second word: %d\n", startIndexOfSecond);

    return 0;
}
            </code>
            <p>OUTPUT</p>
            <code>
Enter a string: hello world
First word: hello
Second word: world

Start index of the second word: 6 
            </code>
            </pre>

            </section>
        <section id="st28">
            <p>Q-28:Create a dictionary having 10 words and their meaning with following operations. [create, delete,search]</p>
            <pre>
            <code >
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define SIZE 10

struct Dictionary {
    char word[20];
    char meaning[100];
};

void create(struct Dictionary dict[], int *count) {
    if (*count >= SIZE) {
        printf("Dictionary is full. Cannot add more words.\n");
        return;
    }

    printf("Enter word: ");
    scanf("%s", dict[*count].word);

    printf("Enter meaning: ");
    scanf(" %[^\n]s", dict[*count].meaning);

    (*count)++;
}

void search(struct Dictionary dict[], int count, char *word) {
    int found = 0;
    for (int i = 0; i &lt count; i++) {
        if (strcmp(dict[i].word, word) == 0) {
            printf("Meaning: %s\n", dict[i].meaning);
            found = 1;
            break;
        }
    }
    if (!found) {
        printf("Word not found in the dictionary.\n");
    }
}

void delete (struct Dictionary dict[], int *count, char *word) {
    for (int i = 0; i &lt *count; i++) {
        if (strcmp(dict[i].word, word) == 0) {
            for (int j = i; j &lt *count - 1; j++) {
                strcpy(dict[j].word, dict[j + 1].word);
                strcpy(dict[j].meaning, dict[j + 1].meaning);
            }
            (*count)--;
            printf("Word deleted from the dictionary.\n");
            return;
        }
    }
    printf("Word not found in the dictionary.\n");
}

int main() {
    struct Dictionary dict[SIZE];
    int count = 0;
    int choice;
    char word[20];

    while (1) {
        printf("\n1. Create\n2. Delete\n3. Search\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                create(dict, &count);
                break;
            case 2:
                printf("Enter word to delete: ");
                scanf("%s", word);
                delete(dict, &count, word);
                break;
            case 3:
                printf("Enter word to search: ");
                scanf("%s", word);
                search(dict, count, word);
                break;
            case 4:
                exit(0);
            default:
                printf("Invalid choice! Please select a valid option.\n");
        }
    }

    return 0;
}
            </code>
            <p>OUTPUT</p>
            <code>
1. Create
2. Delete
3. Search
4. Exit
Enter your choice: 1
Enter word: apple
Enter meaning: A fruit

1. Create
2. Delete
3. Search
4. Exit
Enter your choice: 1
Enter word: orange
Enter meaning: A citrus fruit

1. Create
2. Delete
3. Search
4. Exit
Enter your choice: 3
Enter word to search: apple
Meaning: A fruit

1. Create
2. Delete
3. Search
4. Exit
Enter your choice: 2
Enter word to delete: orange
Word deleted from the dictionary.

1. Create
2. Delete
3. Search
4. Exit
Enter your choice: 3
Enter word to search: orange
Word not found in the dictionary.

1. Create
2. Delete
3. Search
4. Exit
Enter your choice: 4
            </code>
            </pre>

            </section>
        <section id="st29">
            <p>Q-29:ENTER THE STRING FROM USER AND CONVERT CHARACTERS INTO THEIR ASCII VALUES IN THE INTEGER ARRAY. [FOR EXAMPLE TAKE 10 CHARACTERS]</p>
            <pre>
            <code >
                #include <stdio.h>
                    #include <string.h>
                    
                    int main() {
                        char str[100];
                        int asciiValues[100];
                        int i, length;
                    
                        printf("Enter a string: ");
                        fgets(str, sizeof(str), stdin);
                    
                        length = strlen(str);
                    
                        for (i = 0; i &lt length - 1; i++) {
                            asciiValues[i] = (int)str[i];
                        }
                    
                        printf("ASCII values of the characters: ");
                        for (i = 0; i &lt length - 1; i++) {
                            printf("%d ", asciiValues[i]);
                        }
                        printf("\n");
                    
                        return 0;
                    }
            </code>
            <p>OUTPUT</p>
            <code>
Enter a string: Hello, world!
ASCII values of characters: 72 101 108 108 111 44 32 119 111 114 108 100 33
            </code>
            </pre>

            </section>

    <section id="stack">
        <h2>STACK PROBLEMS</h2>
        <ul>
            <li><a href="#stack1">Q-1:CREATE A STACK IMPLEMENTING THE OPERATIONS ON AN INTEGER ARRAY (PUSH, POP, PEEK, ISEMPTY, ISFULL)</a></li>
            <li><a href="#stack2">Q-2:CREATE A STACK IMPLEMENTING THE OPERATIONS ON THE CHARACTERS ARRAY (PUSH, POP, PEEK, ISEMPTY, ISFULL)</a></li>
            <li><a href="#stack3">Q-3:CREATE A STACK IMPLEMENTING THE OPERATIONS ON AN INTEGER NODES (DYNAMICALLY) (PUSH, POP, PEEK, ISEMPTY, ISFULL) </a></li>
            <li><a href="#stack4">Q-4:CREATE A STACK IMPLEMENTING THE OPERATIONS ON THE CHARACTERS NODES (DYNAMICALLY) (PUSH, POP, PEEK, ISEMPTY, ISFULL)</a></li>
            <li><a href="#stack5">Q-5:ENTE R THE STRING FROM THE USER AND REVERSE THE STRING USING STACKS.</a></li>
            <li><a href="#stack6">Q-6:CREATE THE PROGRAM TO MATCH THE SINGLE BRACKET USING STACKS.</a></li>
            <li><a href="#stack7">Q-7:CREATE TWO INTEGER STACKS IN A SINGLE ARRAY.</a></li>
            <li><a href="#stack8">Q-8:SORT THE STACK IN ASCENDING ORDER USING INTEGER ARRAY.</a></li>
            <li><a href="#stack9">Q-9:ENTER THE INFIX EXPRESSION FROM USER AND CONVERT INTO PREFIX EXPRESSION.</a></li>
            <li><a href="#stack10">Q-10:ENTER THE INFIX EXPRESSION FROM USER AND CONVERT INTO POSTFIX EXPRESSION.</a></li>
            <li><a href="#stack11">Q-11:CREATE A PROGRAM TO EVALUATE THE PREFIX EXPRESSION.</a></li>
            <li><a href="#stack12">Q-12:CREATE A PROGRAM TO EVALUATE THE POSTFIX EXPRESSION.</a></li>
            <li><a href="#stack13">Q-13:IMPLEMENT THE TOWER OF HANOI USING STACKS.</a></li>
            
            <section id="stack1">
                <p>Q-1:CREATE A STACK IMPLEMENTING THE OPERATIONS ON AN INTEGER ARRAY (PUSH, POP, PEEK, ISEMPTY, ISFULL)</p>
                <pre>
                <code >
#include <stdio.h>

const int MAX_SIZE = 5;

struct Stack {
    int items[5];
    int top;
};

int isEmpty(struct Stack *stack) {
    return stack->top == -1;
}

int isFull(struct Stack *stack) {
    return stack->top == MAX_SIZE - 1;
}

void push(struct Stack *stack, int value) {
    if (isFull(stack)) {
        printf("Stack is full. Cannot push more elements.\n");
    } else {
        stack->top++;
        stack->items[stack->top] = value;
        printf("%d pushed to the stack.\n", value);
    }
}

int pop(struct Stack *stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return -1;
    } else {
        int item = stack->items[stack->top];
        stack->top--;
        return item;
    }
}

int peek(struct Stack *stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty.\n");
        return -1;
    } else {
        return stack->items[stack->top];
    }
}

int main() {
    struct Stack stack;
    stack.top = -1;

    int choice, value;

    while (1) {
        printf("\n1. Push\n");
        printf("2. Pop\n");
        printf("3. Peek\n");
        printf("4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to push: ");
                scanf("%d", &value);
                push(&stack, value);
                break;
            case 2:
                printf("%d popped from the stack\n", pop(&stack));
                break;
            case 3:
                printf("Top element is %d\n", peek(&stack));
                break;
            case 4:
                return 0;
            default:
                printf("Invalid choice! Please select a valid option.\n");
        }
    }
}
                </code>
                <p>OUTPUT</p>
                <code>
1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter value to push: 10
10 pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter value to push: 20
20 pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 3
Top element is 20

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 2
20 popped from the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 2
10 popped from the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 3
Stack is empty.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 4
                </code>
                </pre>

                </section>
                
                <section id="stack2">
                    <p>Q-2:CREATE A STACK IMPLEMENTING THE OPERATIONS ON THE CHARACTERS ARRAY (PUSH, POP, PEEK, ISEMPTY, ISFULL)</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <stdbool.h>

#define MAX_SIZE 5

struct Stack {
    char items[MAX_SIZE];
    int top;
};

void initializeStack(struct Stack* stack) {
    stack->top = -1;
}

bool isFull(struct Stack* stack) {
    return stack->top == MAX_SIZE - 1;
}

bool isEmpty(struct Stack* stack) {
    return stack->top == -1;
}

void push(struct Stack* stack, char value) {
    if (isFull(stack)) {
        printf("Stack is full. Cannot push more elements.\n");
    } else {
        stack->top++;
        stack->items[stack->top] = value;
        printf("%c pushed to the stack.\n", value);
    }
}

char pop(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return '\0';
    } else {
        char value = stack->items[stack->top];
        stack->top--;
        return value;
    }
}

char peek(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty.\n");
        return '\0';
    } else {
        return stack->items[stack->top];
    }
}

int main() {
    struct Stack stack;
    initializeStack(&stack);

    int choice;
    char value;

    while (1) {
        printf("\n1. Push\n");
        printf("2. Pop\n");
        printf("3. Peek\n");
        printf("4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter character to push: ");
                scanf(" %c", &value);
                push(&stack, value);
                break;
            case 2:
                printf("%c popped from the stack.\n", pop(&stack));
                break;
            case 3:
                printf("Top element is %c\n", peek(&stack));
                break;
            case 4:
                return 0;
            default:
                printf("Invalid choice! Please select a valid option.\n");
        }
    }
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter character to push: a
a pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter character to push: b
b pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter character to push: c
c pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 3
Top element is c

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 2
c popped from the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 2
b popped from the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 3
Top element is a

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 4
                    </code>
                    </pre>

                    </section>
                    
                    <section id="stack3">
                        <p>Q-3:CREATE A STACK IMPLEMENTING THE OPERATIONS ON AN INTEGER NODES (DYNAMICALLY) (PUSH, POP, PEEK, ISEMPTY, ISFULL)</p>
                        <pre>
                        <code >
#include <stdio.h>
#include <string.h>
#define MAX_SIZE 50

struct Stack {
    char items[MAX_SIZE];
    int top;
};

void initializeStack(struct Stack* stack) {
    stack->top = -1;
}

void push(struct Stack* stack, char value) {
    if (stack->top == MAX_SIZE - 1) {
        printf("Stack is full. Cannot push more elements.\n");
    } else {
        stack->top++;
        stack->items[stack->top] = value;
    }
}

char pop(struct Stack* stack) {
    if (stack->top == -1) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return '\0';
    } else {
        char value = stack->items[stack->top];
        stack->top--;
        return value;
    }
}

void reverseString(char* str) {
    struct Stack stack;
    initializeStack(&stack);

    int i;
    for (i = 0; str[i] != '\0'; i++) {
        push(&stack, str[i]);
    }

    for (i = 0; stack.top != -1; i++) {
        str[i] = pop(&stack);
    }
}

int main() {
    char str[MAX_SIZE];

    printf("Enter a string: ");
    gets(str);

    printf("Original string: %s\n", str);
    reverseString(str);
    printf("Reversed string: %s\n", str);

    return 0;
}  
                        </code>
                        <p>OUTPUT</p>
                        <code>
 Enter a string: Hello, world!
Original string: Hello, world!
Reversed string: !dlrow ,olleH   
                        </code>
                        </pre>
    
                        </section>
                        
                    <section id="stack4">
                        <p>Q-4:CREATE A STACK IMPLEMENTING THE OPERATIONS ON THE CHARACTERS NODES (DYNAMICALLY) (PUSH, POP, PEEK, ISEMPTY, ISFULL)</p>
                        <pre>
                        <code >
 #include <stdio.h>
#include <stdbool.h>
#define MAX_SIZE 50

struct Stack {
    char items[MAX_SIZE];
    int top;
};

void initializeStack(struct Stack* stack) {
    stack->top = -1;
}

void push(struct Stack* stack, char value) {
    if (stack->top == MAX_SIZE - 1) {
        printf("Stack is full. Cannot push more elements.\n");
    } else {
        stack->top++;
        stack->items[stack->top] = value;
    }
}

char pop(struct Stack* stack) {
    if (stack->top == -1) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return '\0';
    } else {
        char value = stack->items[stack->top];
        stack->top--;
        return value;
    }
}

bool isMatchingPair(char character1, char character2) {
    if (character1 == '(' && character2 == ')')
        return true;
    else if (character1 == '{' && character2 == '}')
        return true;
    else if (character1 == '[' && character2 == ']')
        return true;
    else
        return false;
}

bool checkBalanced(char exp[]) {
    struct Stack stack;
    initializeStack(&stack);

    for (int i = 0; exp[i] != '\0'; i++) {
        if (exp[i] == '(' || exp[i] == '{' || exp[i] == '[')
            push(&stack, exp[i]);
        else if (exp[i] == ')' || exp[i] == '}' || exp[i] == ']') {
            if (stack.top == -1 || !isMatchingPair(stack.items[stack.top], exp[i]))
                return false;
            else
                pop(&stack);
        }
    }
    return stack.top == -1; // Stack should be empty for balanced expression
}

int main() {
    char expression[MAX_SIZE];

    printf("Enter an expression: ");
    gets(expression);

    if (checkBalanced(expression))
        printf("The expression is balanced.\n");
    else
        printf("The expression is not balanced.\n");

    return 0;
}   
                        </code>
                        <p>OUTPUT</p>
                        <code>
Enter an expression: (a+b)*[c+d]
The expression is balanced.

Enter an expression: {a+(b*c]+d}
The expression is not balanced.   
                        </code>
                        </pre>
    
                        </section>
                        
                    <section id="stack5">
                        <p>Q-5:ENTER THE STRING FROM THE USER AND REVERSE THE STRING USING STACKS.</p>
                        <pre>
                        <code >
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdlib.h>

#define MAX_SIZE 100

struct Stack {
    char items[MAX_SIZE];
    int top;
};

void initializeStack(struct Stack* stack) {
    stack->top = -1;
}

void push(struct Stack* stack, char value) {
    if (stack->top == MAX_SIZE - 1) {
        printf("Stack is full. Cannot push more elements.\n");
    } else {
        stack->top++;
        stack->items[stack->top] = value;
    }
}

char pop(struct Stack* stack) {
    if (stack->top == -1) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return '\0';
    } else {
        char value = stack->items[stack->top];
        stack->top--;
        return value;
    }
}

int getPrecedence(char ch) {
    switch (ch) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        case '^':
            return 3;
    }
    return -1;
}

bool isOperator(char ch) {
    return (ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '^');
}

bool isOperand(char ch) {
    return ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'));
}

void infixToPrefix(char* infix, char* prefix) {
    struct Stack stack;
    initializeStack(&stack);
    int i, j = 0;

    for (i = strlen(infix) - 1; i >= 0; i--) {
        if (infix[i] == ')') {
            push(&stack, infix[i]);
        } else if (infix[i] == '(') {
            while (stack.items[stack.top] != ')') {
                prefix[j++] = pop(&stack);
            }
            pop(&stack);  // pop the ')'
        } else if (isOperand(infix[i])) {
            prefix[j++] = infix[i];
        } else if (isOperator(infix[i])) {
            while (getPrecedence(infix[i]) <= getPrecedence(stack.items[stack.top]) && stack.top != -1) {
                prefix[j++] = pop(&stack);
            }
            push(&stack, infix[i]);
        }
    }

    while (stack.top != -1) {
        prefix[j++] = pop(&stack);
    }

    prefix[j] = '\0';
    // Reverse the prefix expression
    int len = strlen(prefix);
    for (i = 0; i < len / 2; i++) {
        char temp = prefix[i];
        prefix[i] = prefix[len - i - 1];
        prefix[len - i - 1] = temp;
    }
}

int main() {
    char infix[MAX_SIZE], prefix[MAX_SIZE];
    printf("Enter an infix expression: ");
    gets(infix);

    infixToPrefix(infix, prefix);
    printf("Prefix expression: %s\n", prefix);
    return 0;
}   
                        </code>
                        <p>OUTPUT</p>
                        <code>
Enter an infix expression: (A+B)*C-D*E
Prefix expression: -*+ABC*DE  
                        </code>
                        </pre>
    
                        </section>
                        
                    <section id="stack6">
                        <p>Q-6:CREATE THE PROGRAM TO MATCH THE SINGLE BRACKET USING STACKS.</p>
                        <pre>
                        <code >
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAX_SIZE 100

struct Stack {
    char items[MAX_SIZE];
    int top;
};

void initializeStack(struct Stack* stack) {
    stack->top = -1;
}

void push(struct Stack* stack, char value) {
    if (stack->top == MAX_SIZE - 1) {
        printf("Stack is full. Cannot push more elements.\n");
    } else {
        stack->top++;
        stack->items[stack->top] = value;
    }
}

char pop(struct Stack* stack) {
    if (stack->top == -1) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return '\0';
    } else {
        char value = stack->items[stack->top];
        stack->top--;
        return value;
    }
}

int getPrecedence(char ch) {
    switch (ch) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        case '^':
            return 3;
    }
    return -1;
}

bool isOperator(char ch) {
    return (ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '^');
}

bool isOperand(char ch) {
    return ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'));
}

void infixToPostfix(char* infix, char* postfix) {
    struct Stack stack;
    initializeStack(&stack);
    int i, j = 0;

    for (i = 0; infix[i] != '\0'; i++) {
        if (isOperand(infix[i])) {
            postfix[j++] = infix[i];
        } else if (infix[i] == '(') {
            push(&stack, infix[i]);
        } else if (infix[i] == ')') {
            while (stack.items[stack.top] != '(') {
                postfix[j++] = pop(&stack);
            }
            pop(&stack);  // Pop the '('
        } else if (isOperator(infix[i])) {
            while (stack.top != -1 && getPrecedence(infix[i]) <= getPrecedence(stack.items[stack.top])) {
                postfix[j++] = pop(&stack);
            }
            push(&stack, infix[i]);
        }
    }

    while (stack.top != -1) {
        postfix[j++] = pop(&stack);
    }

    postfix[j] = '\0';
}

int main() {
    char infix[MAX_SIZE], postfix[MAX_SIZE];
    printf("Enter an infix expression: ");
    fgets(infix);

    infixToPostfix(infix, postfix);
    printf("Postfix expression: %s\n", postfix);
    return 0;
}    
                        </code>
                        <p>OUTPUT</p>
                        <code>
Enter an infix expression: A+B*C-(D+E)/F
Postfix expression: ABC*+DE+F/-   
                        </code>
                        </pre>
    
                        </section>
                        
                    <section id="stack7">
                        <p>Q-7:CREATE TWO INTEGER STACKS IN A SINGLE ARRAY.</p>
                        <pre>
                        <code >
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_SIZE 100

struct Stack {
    int items[MAX_SIZE];
    int top;
};

void initializeStack(struct Stack* stack) {
    stack->top = -1;
}

void push(struct Stack* stack, int value) {
    if (stack->top == MAX_SIZE - 1) {
        printf("Stack is full. Cannot push more elements.\n");
    } else {
        stack->top++;
        stack->items[stack->top] = value;
    }
}

int pop(struct Stack* stack) {
    if (stack->top == -1) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return -1;
    } else {
        int value = stack->items[stack->top];
        stack->top--;
        return value;
    }
}

int evaluatePrefix(char* expression) {
    struct Stack stack;
    initializeStack(&stack);
    int length = strlen(expression);

    for (int i = length - 1; i >= 0; i--) {
        if (isdigit(expression[i])) {
            push(&stack, expression[i] - '0');
        } else {
            int operand1 = pop(&stack);
            int operand2 = pop(&stack);
            switch (expression[i]) {
                case '+':
                    push(&stack, operand1 + operand2);
                    break;
                case '-':
                    push(&stack, operand1 - operand2);
                    break;
                case '*':
                    push(&stack, operand1 * operand2);
                    break;
                case '/':
                    push(&stack, operand1 / operand2);
                    break;
            }
        }
    }

    return pop(&stack);
}

int main() {
    char expression[MAX_SIZE];
    printf("Enter a prefix expression: ");
    fgets(expression);

    int result = evaluatePrefix(expression);
    printf("Result: %d\n", result);
    return 0;
}   
                        </code>
                        <p>OUTPUT</p>
                        <code>
Enter a prefix expression: -+7*45+20
Result: 25   
                        </code>
                        </pre>
    
                        </section>
                        
                    <section id="stack8">
                        <p>Q-8:SORT THE STACK IN ASCENDING ORDER USING INTEGER ARRAY.</p>
                        <pre>
                        <code >
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_SIZE 100

struct Stack {
    int items[MAX_SIZE];
    int top;
};

void initializeStack(struct Stack* stack) {
    stack->top = -1;
}

void push(struct Stack* stack, int value) {
    if (stack->top == MAX_SIZE - 1) {
        printf("Stack is full. Cannot push more elements.\n");
    } else {
        stack->top++;
        stack->items[stack->top] = value;
    }
}

int pop(struct Stack* stack) {
    if (stack->top == -1) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return -1;
    } else {
        int value = stack->items[stack->top];
        stack->top--;
        return value;
    }
}

int evaluatePostfix(char* expression) {
    struct Stack stack;
    initializeStack(&stack);
    int length = strlen(expression);

    for (int i = 0; i < length; i++) {
        if (isdigit(expression[i])) {
            push(&stack, expression[i] - '0');
        } else {
            int operand2 = pop(&stack);
            int operand1 = pop(&stack);
            switch (expression[i]) {
                case '+':
                    push(&stack, operand1 + operand2);
                    break;
                case '-':
                    push(&stack, operand1 - operand2);
                    break;
                case '*':
                    push(&stack, operand1 * operand2);
                    break;
                case '/':
                    push(&stack, operand1 / operand2);
                    break;
            }
        }
    }

    return pop(&stack);
}

int main() {
    char expression[MAX_SIZE];
    printf("Enter a postfix expression: ");
    fgets(expression);

    int result = evaluatePostfix(expression);
    printf("Result: %d\n", result);
    return 0;
}   
                        </code>
                        <p>OUTPUT</p>
                        <code>
Enter a postfix expression: 345*+2+
Result: 17    
                        </code>
                        </pre>
    
                        </section>
                        
                    <section id="stack9">
                        <p>Q-9:ENTER THE INFIX EXPRESSION FROM USER AND CONVERT INTO PREFIX EXPRESSION.</p>
                        <pre>
                        <code >
#include <stdio.h>

void towerOfHanoi(int n, char source, char auxiliary, char destination) {
    if (n == 1) {
        printf("Move disk 1 from %c to %c\n", source, destination);
        return;
    }
    towerOfHanoi(n - 1, source, destination, auxiliary);
    printf("Move disk %d from %c to %c\n", n, source, destination);
    towerOfHanoi(n - 1, auxiliary, source, destination);
}

int main() {
    int n = 3; // Number of disks
    towerOfHanoi(n, 'A', 'B', 'C');  // A, B, C are the names of the rods
    return 0;
}    
                        </code>
                        <p>OUTPUT</p>
                        <code>
Move disk 1 from A to C
Move disk 2 from A to B
Move disk 1 from C to B
Move disk 3 from A to C
Move disk 1 from B to A
Move disk 2 from B to C
Move disk 1 from A to C    
                        </code>
                        </pre>
    
                        </section>
                        
                    <section id="stack10">
                        <p>Q-10:ENTER THE INFIX EXPRESSION FROM USER AND CONVERT INTO POSTFIX EXPRESSION.</p>
                        <pre>
                        <code >
    
                        </code>
                        <p>OUTPUT</p>
                        <code>
    
                        </code>
                        </pre>
    
                        </section>
                        
                    <section id="stack11">
                        <p>Q-11:CREATE A PROGRAM TO EVALUATE THE PREFIX EXPRESSION.</p>
                        <pre>
                        <code >
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 10

struct TwoStacks {
    int* array;
    int top1;
    int top2;
    int capacity;
};

struct TwoStacks* createTwoStacks() {
    struct TwoStacks* twoStacks = (struct TwoStacks*)malloc(sizeof(struct TwoStacks));
    if (!twoStacks) {
        return NULL;
    }
    twoStacks->capacity = MAX_SIZE;
    twoStacks->array = (int*)malloc(twoStacks->capacity * sizeof(int));
    if (!twoStacks->array) {
        return NULL;
    }
    twoStacks->top1 = -1;
    twoStacks->top2 = twoStacks->capacity;
    return twoStacks;
}

int isFull(struct TwoStacks* twoStacks) {
    return twoStacks->top1 + 1 == twoStacks->top2;
}

int isEmpty1(struct TwoStacks* twoStacks) {
    return twoStacks->top1 == -1;
}

int isEmpty2(struct TwoStacks* twoStacks) {
    return twoStacks->top2 == twoStacks->capacity;
}

void push1(struct TwoStacks* twoStacks, int value) {
    if (isFull(twoStacks)) {
        printf("Stack Overflow\n");
        return;
    }
    twoStacks->array[++twoStacks->top1] = value;
}

void push2(struct TwoStacks* twoStacks, int value) {
    if (isFull(twoStacks)) {
        printf("Stack Overflow\n");
        return;
    }
    twoStacks->array[--twoStacks->top2] = value;
}

int pop1(struct TwoStacks* twoStacks) {
    if (isEmpty1(twoStacks)) {
        printf("Stack Underflow\n");
        return -1;
    }
    return twoStacks->array[twoStacks->top1--];
}

int pop2(struct TwoStacks* twoStacks) {
    if (isEmpty2(twoStacks)) {
        printf("Stack Underflow\n");
        return -1;
    }
    return twoStacks->array[twoStacks->top2++];
}

int main() {
    struct TwoStacks* twoStacks = createTwoStacks();
    int choice, value;

    do {
        printf("\n1. Push to Stack 1");
        printf("\n2. Push to Stack 2");
        printf("\n3. Pop from Stack 1");
        printf("\n4. Pop from Stack 2");
        printf("\n0. Exit");
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to push to Stack 1: ");
                scanf("%d", &value);
                push1(twoStacks, value);
                break;
            case 2:
                printf("Enter value to push to Stack 2: ");
                scanf("%d", &value);
                push2(twoStacks, value);
                break;
            case 3:
                printf("Popped element from Stack 1: %d\n", pop1(twoStacks));
                break;
            case 4:
                printf("Popped element from Stack 2: %d\n", pop2(twoStacks));
                break;
            case 0:
                break;
            default:
                printf("Invalid choice! Please try again.\n");
        }
    } while (choice != 0);

    free(twoStacks->array);
    free(twoStacks);
    return 0;
}   
                        </code>
                        <p>OUTPUT</p>
                        <code>
1. Push to Stack 1
2. Push to Stack 2
3. Pop from Stack 1
4. Pop from Stack 2
0. Exit
Enter your choice: 1
Enter value to push to Stack 1: 5

1. Push to Stack 1
2. Push to Stack 2
3. Pop from Stack 1
4. Pop from Stack 2
0. Exit
Enter your choice: 2
Enter value to push to Stack 2: 10

1. Push to Stack 1
2. Push to Stack 2
3. Pop from Stack 1
4. Pop from Stack 2
0. Exit
Enter your choice: 3
Popped element from Stack 1: 5

1. Push to Stack 1
2. Push to Stack 2
3. Pop from Stack 1
4. Pop from Stack 2
0. Exit
Enter your choice: 4
Popped element from Stack 2: 10

1. Push to Stack 1
2. Push to Stack 2
3. Pop from Stack 1
4. Pop from Stack 2
0. Exit
Enter your choice: 0   
                        </code>
                        </pre>
    
                        </section>
                        
                    <section id="stack12">
                        <p>Q-12:CREATE A PROGRAM TO EVALUATE THE POSTFIX EXPRESSION.</p>
                        <pre>
                        <code >
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

struct Node {
    int data;
    struct Node* next;
};

struct Stack {
    struct Node* top;
    int size;
    int capacity;
};

struct Stack* createStack(int capacity) {
    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));
    stack->top = NULL;
    stack->size = 0;
    stack->capacity = capacity;
    return stack;
}

bool isFull(struct Stack* stack) {
    return stack->size == stack->capacity;
}

bool isEmpty(struct Stack* stack) {
    return stack->size == 0;
}

void push(struct Stack* stack, int data) {
    if (isFull(stack)) {
        printf("Stack is full. Cannot push more elements.\n");
        return;
    }

    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = stack->top;
    stack->top = newNode;
    stack->size++;
}

int pop(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return -1;
    }

    int data = stack->top->data;
    struct Node* temp = stack->top;
    stack->top = stack->top->next;
    free(temp);
    stack->size--;
    return data;
}

int peek(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty.\n");
        return -1;
    }
    return stack->top->data;
}

int main() {
    struct Stack* stack = createStack(5);
    int choice, value;

    while (1) {
        printf("\n1. Push\n");
        printf("2. Pop\n");
        printf("3. Peek\n");
        printf("4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to push: ");
                scanf("%d", &value);
                push(stack, value);
                break;
            case 2:
                printf("%d popped from the stack\n", pop(stack));
                break;
            case 3:
                printf("Top element is %d\n", peek(stack));
                break;
            case 4:
                return 0;
            default:
                printf("Invalid choice! Please select a valid option.\n");
        }
    }
}   
                        </code>
                        <p>OUTPUT</p>
                        <code>
1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter value to push: 10
10 pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter value to push: 20
20 pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 3
Top element is 20

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 2
20 popped from the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 2
10 popped from the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 3
Stack is empty.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 4   
                        </code>
                        </pre>
    
                        </section>
                        
                    <section id="stack13">
                        <p>Q-13:IMPLEMENT THE TOWER OF HANOI USING STACKS.</p>
                        <pre>
                        <code >
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define MAX_SIZE 5
#define MAX_LENGTH 50

struct Stack {
    char** items;
    int top;
    int size;
};

struct Stack* createStack(int size) {
    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));
    stack->items = (char**)malloc(size * sizeof(char*));
    stack->top = -1;
    stack->size = size;
    return stack;
}

bool isFull(struct Stack* stack) {
    return stack->top == stack->size - 1;
}

bool isEmpty(struct Stack* stack) {
    return stack->top == -1;
}

void push(struct Stack* stack, char* str) {
    if (isFull(stack)) {
        printf("Stack is full. Cannot push more elements.\n");
    } else {
        stack->top++;
        stack->items[stack->top] = (char*)malloc(MAX_LENGTH * sizeof(char));
        strcpy(stack->items[stack->top], str);
        printf("%s pushed to the stack.\n", str);
    }
}

char* pop(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return NULL;
    } else {
        return stack->items[stack->top--];
    }
}

char* peek(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty.\n");
        return NULL;
    } else {
        return stack->items[stack->top];
    }
}

int main() {
    struct Stack* stack = createStack(MAX_SIZE);
    int choice;
    char str[MAX_LENGTH];

    while (1) {
        printf("\n1. Push\n");
        printf("2. Pop\n");
        printf("3. Peek\n");
        printf("4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter string to push: ");
                scanf("%s", str);
                push(stack, str);
                break;
            case 2: {
                char* popped = pop(stack);
                if (popped != NULL) {
                    printf("%s popped from the stack\n", popped);
                }
                break;
            }
            case 3: {
                char* top = peek(stack);
                if (top != NULL) {
                    printf("Top element is %s\n", top);
                }
                break;
            }
            case 4:
                return 0;
            default:
                printf("Invalid choice! Please select a valid option.\n");
        }
    }
}    
                        </code>
                        <p>OUTPUT</p>
                        <code>
1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter string to push: apple
apple pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter string to push: banana
banana pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter string to push: cherry
cherry pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 3
Top element is cherry

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 2
cherry popped from the stack

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 2
banana popped from the stack

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 3
Top element is apple

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 4   
                        </code>
                        </pre>

                        </section>
                
        </ul>
    </section>

    <section id="queue">
        <h2>QUEUE PROBLEMS</h2>
        <li><a href="#QUE1">Q-1:IMPLEMENT THE OPERATIONS OF SIMPLE QUEUE IN AN INTEGER ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
        <li><a href="#QUE2">Q-2:IMPLEMENT THE OPERATIONS OF SIMPLE QUEUE IN AN STRING ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
        <li><a href="#QUE3">Q-3:IMPLEMENT THE OPERATIONS OF QUEUE DYNAMICALLY OF INTEGERS (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
        <li><a href="#QUE4">Q-4:IMPLEMENT THE OPERATIONS OF QUEUE DYNAMICALLY OF STRING (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
        <li><a href="#QUE5">Q-5:IMPLEMENT THE OPERATIONS OF CIRCULAR QUEUE IN AN INTEGER ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
        <li><a href="#QUE6">Q-6:IMPLEMENT THE OPERATIONS OF CIRCULAR QUEUE IN AN STRING ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
        <li><a href="#QUE7">Q-7:IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE IN AN INTEGER ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
        <li><a href="#QUE8">Q-8:IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE IN AN STRING ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
        <li><a href="#QUE9">Q-9:IMPLEMENT THE OPERATIONS OF DOUBLE ENDED QUEUE IN AN INTEGER ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
        <li><a href="#QUE10">Q-10:IMPLEMENT THE OPERATIONS OF DOUBLE ENDED QUEUE IN AN STRING ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
        <li><a href="#QUE11">Q-11:IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE DYNAMICALLY OF INTEGERS (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
        <li><a href="#QUE12">Q-12:IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE DYNAMICALLY OF STRING (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
        <li><a href="#QUE13">Q-13: Find the first circular tour that visits all petrol pumps</a></li>
        <li><a href="#QUE14">Q-14:Length of the longest valid substring</a></li>
        <li><a href="#QUE15">Q-15:Find the Next Greater Element</a></li>
        <li><a href="#QUE16">Q-16:Find Next Smaller Element</a></li>
        <li><a href="#QUE17">Q-17:Queue based approach for first non-repeating character in a stream</a></li>
        <li><a href="#QUE18">Q-18:Reverse First K elements of Queue</a></li>
        <li><a href="#QUE19">Q-19:Queue Reversal</a></li>
        <li><a href="#QUE20">Q-20:Rotten Oranges</a></li>

        <section id="QUE1">
            <p>IMPLEMENT THE OPERATIONS OF SIMPLE QUEUE IN AN INTEGER ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</p>
            <pre>
            <code >
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 5

struct Queue {
    int* array;
    int front, rear;
    int capacity;
};

struct Queue* createQueue() {
    struct Queue* queue = (struct Queue*)malloc(sizeof(struct Queue));
    if (!queue) {
        return NULL;
    }
    queue->capacity = MAX_SIZE;
    queue->array = (int*)malloc(queue->capacity * sizeof(int));
    if (!queue->array) {
        return NULL;
    }
    queue->front = queue->rear = -1;
    return queue;
}

int isFull(struct Queue* queue) {
    return (queue->rear + 1) % queue->capacity == queue->front;
}

int isEmpty(struct Queue* queue) {
    return queue->front == -1;
}

void insert(struct Queue* queue, int value) {
    if (isFull(queue)) {
        printf("Queue is full. Insertion failed.\n");
        return;
    }
    if (isEmpty(queue)) {
        queue->front = queue->rear = 0;
    } else {
        queue->rear = (queue->rear + 1) % queue->capacity;
    }
    queue->array[queue->rear] = value;
}

int delete(struct Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Deletion failed.\n");
        return -1;
    }
    int value = queue->array[queue->front];
    if (queue->front == queue->rear) {
        queue->front = queue->rear = -1;
    } else {
        queue->front = (queue->front + 1) % queue->capacity;
    }
    return value;
}

int peek(struct Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Peek failed.\n");
        return -1;
    }
    return queue->array[queue->front];
}

int main() {
    struct Queue* queue = createQueue();
    int choice, value;

    do {
        printf("\n1. Insert");
        printf("\n2. Delete");
        printf("\n3. Peek");
        printf("\n0. Exit");
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%d", &value);
                insert(queue, value);
                break;
            case 2:
                printf("Deleted element: %d\n", delete(queue));
                break;
            case 3:
                printf("Element at front: %d\n", peek(queue));
                break;
            case 0:
                break;
            default:
                printf("Invalid choice! Please try again.\n");
        }
    } while (choice != 0);

    free(queue->array);
    free(queue);
    return 0;
}
            </code>
            <p>OUTPUT</p>
            <code>
Element at front: 10
Element at front: 30
            </code>
            </pre>

            </section>
            <section id="QUE2">
                <p>IMPLEMENT THE OPERATIONS OF SIMPLE QUEUE IN AN STRING ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</p>
                <pre>
                <code >
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SIZE 5
#define MAX_LENGTH 50

struct Queue {
    char** array;
    int front, rear;
    int capacity;
};

struct Queue* createQueue() {
    struct Queue* queue = (struct Queue*)malloc(sizeof(struct Queue));
    if (!queue) {
        return NULL;
    }
    queue->capacity = MAX_SIZE;
    queue->array = (char**)malloc(queue->capacity * sizeof(char*));
    for (int i = 0; i < queue->capacity; i++) {
        queue->array[i] = (char*)malloc(MAX_LENGTH * sizeof(char));
    }
    queue->front = queue->rear = -1;
    return queue;
}

int isFull(struct Queue* queue) {
    return (queue->rear + 1) % queue->capacity == queue->front;
}

int isEmpty(struct Queue* queue) {
    return queue->front == -1;
}

void insert(struct Queue* queue, char* value) {
    if (isFull(queue)) {
        printf("Queue is full. Insertion failed.\n");
        return;
    }
    if (isEmpty(queue)) {
        queue->front = queue->rear = 0;
    } else {
        queue->rear = (queue->rear + 1) % queue->capacity;
    }
    strcpy(queue->array[queue->rear], value);
}

char* delete(struct Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Deletion failed.\n");
        return "";
    }
    char* value = queue->array[queue->front];
    if (queue->front == queue->rear) {
        queue->front = queue->rear = -1;
    } else {
        queue->front = (queue->front + 1) % queue->capacity;
    }
    return value;
}

char* peek(struct Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Peek failed.\n");
        return "";
    }
    return queue->array[queue->front];
}

int main() {
    struct Queue* queue = createQueue();
    char value[MAX_LENGTH];
    int choice;

    do {
        printf("\n1. Insert");
        printf("\n2. Delete");
        printf("\n3. Peek");
        printf("\n0. Exit");
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%s", value);
                insert(queue, value);
                break;
            case 2:
                printf("Deleted element: %s\n", delete(queue));
                break;
            case 3:
                printf("Element at front: %s\n", peek(queue));
                break;
            case 0:
                break;
            default:
                printf("Invalid choice! Please try again.\n");
        }
    } while (choice != 0);

    for (int i = 0; i < queue->capacity; i++) {
        free(queue->array[i]);
    }
    free(queue->array);
    free(queue);
    return 0;
}
                </code>
                <p>OUTPUT</p>
                <code>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SIZE 5
#define MAX_LENGTH 50

struct Queue {
    char** array;
    int front, rear;
    int capacity;
};

struct Queue* createQueue() {
    struct Queue* queue = (struct Queue*)malloc(sizeof(struct Queue));
    if (!queue) {
        return NULL;
    }
    queue->capacity = MAX_SIZE;
    queue->array = (char**)malloc(queue->capacity * sizeof(char*));
    for (int i = 0; i < queue->capacity; i++) {
        queue->array[i] = (char*)malloc(MAX_LENGTH * sizeof(char));
    }
    queue->front = queue->rear = -1;
    return queue;
}

int isFull(struct Queue* queue) {
    return (queue->rear + 1) % queue->capacity == queue->front;
}

int isEmpty(struct Queue* queue) {
    return queue->front == -1;
}

void insert(struct Queue* queue, char* value) {
    if (isFull(queue)) {
        printf("Queue is full. Insertion failed.\n");
        return;
    }
    if (isEmpty(queue)) {
        queue->front = queue->rear = 0;
    } else {
        queue->rear = (queue->rear + 1) % queue->capacity;
    }
    strcpy(queue->array[queue->rear], value);
}

char* delete(struct Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Deletion failed.\n");
        return "";
    }
    char* value = queue->array[queue->front];
    if (queue->front == queue->rear) {
        queue->front = queue->rear = -1;
    } else {
        queue->front = (queue->front + 1) % queue->capacity;
    }
    return value;
}

char* peek(struct Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Peek failed.\n");
        return "";
    }
    return queue->array[queue->front];
}

int main() {
    struct Queue* queue = createQueue();
    char value[MAX_LENGTH];
    int choice;

    do {
        printf("\n1. Insert");
        printf("\n2. Delete");
        printf("\n3. Peek");
        printf("\n0. Exit");
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%s", value);
                insert(queue, value);
                break;
            case 2:
                printf("Deleted element: %s\n", delete(queue));
                break;
            case 3:
                printf("Element at front: %s\n", peek(queue));
                break;
            case 0:
                break;
            default:
                printf("Invalid choice! Please try again.\n");
        }
    } while (choice != 0);

    for (int i = 0; i < queue->capacity; i++) {
        free(queue->array[i]);
    }
    free(queue->array);
    free(queue);
    return 0;
}
                </code>
                </pre>

                </section>
                <section id="QUE3">
                    <p>IMPLEMENT THE OPERATIONS OF QUEUE DYNAMICALLY OF INTEGERS (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
};

struct Queue {
    struct Node *front, *rear;
};

struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    if (!newNode) {
        printf("Memory error\n");
        return NULL;
    }
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

struct Queue* createQueue() {
    struct Queue* queue = (struct Queue*)malloc(sizeof(struct Queue));
    if (!queue) {
        printf("Memory error\n");
        return NULL;
    }
    queue->front = queue->rear = NULL;
    return queue;
}

void insert(struct Queue* queue, int data) {
    struct Node* newNode = createNode(data);
    if (!newNode) {
        return;
    }
    if (!queue->rear) {
        queue->front = queue->rear = newNode;
        return;
    }
    queue->rear->next = newNode;
    queue->rear = newNode;
}

int delete(struct Queue* queue) {
    if (!queue->front) {
        printf("Queue is empty. Deletion failed.\n");
        return -1;
    }
    struct Node* temp = queue->front;
    int data = temp->data;
    queue->front = queue->front->next;
    if (!queue->front) {
        queue->rear = NULL;
    }
    free(temp);
    return data;
}

int peek(struct Queue* queue) {
    if (!queue->front) {
        printf("Queue is empty. Peek failed.\n");
        return -1;
    }
    return queue->front->data;
}

int main() {
    struct Queue* queue = createQueue();
    int data, choice;

    do {
        printf("\n1. Insert");
        printf("\n2. Delete");
        printf("\n3. Peek");
        printf("\n0. Exit");
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%d", &data);
                insert(queue, data);
                break;
            case 2:
                printf("Deleted element: %d\n", delete(queue));
                break;
            case 3:
                printf("Element at front: %d\n", peek(queue));
                break;
            case 0:
                break;
            default:
                printf("Invalid choice! Please try again.\n");
        }
    } while (choice != 0);

    // Free the memory
    struct Node* current = queue->front;
    struct Node* next;
    while (current != NULL) {
        next = current->next;
        free(current);
        current = next;
    }
    free(queue);
    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 1
Enter value to insert: 10

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 1
Enter value to insert: 20

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 1
Enter value to insert: 30

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 3
Element at front: 10

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Deleted element: 10

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Deleted element: 20

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 3
Element at front: 30

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Deleted element: 30

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Queue is empty. Deletion failed.

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 0
                    </code>
                    </pre>

                    </section>
                    <section id="QUE4">
                    <p>IMPLEMENT THE OPERATIONS OF QUEUE DYNAMICALLY OF STRING (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LENGTH 50

struct Node {
    char data[MAX_LENGTH];
    struct Node* next;
};

struct Queue {
    struct Node *front, *rear;
};

struct Node* createNode(char* data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    if (!newNode) {
        printf("Memory error\n");
        return NULL;
    }
    strcpy(newNode->data, data);
    newNode->next = NULL;
    return newNode;
}

struct Queue* createQueue() {
    struct Queue* queue = (struct Queue*)malloc(sizeof(struct Queue));
    if (!queue) {
        printf("Memory error\n");
        return NULL;
    }
    queue->front = queue->rear = NULL;
    return queue;
}

void insert(struct Queue* queue, char* data) {
    struct Node* newNode = createNode(data);
    if (!newNode) {
        return;
    }
    if (!queue->rear) {
        queue->front = queue->rear = newNode;
        return;
    }
    queue->rear->next = newNode;
    queue->rear = newNode;
}

char* delete(struct Queue* queue) {
    if (!queue->front) {
        printf("Queue is empty. Deletion failed.\n");
        return "";
    }
    struct Node* temp = queue->front;
    char* data = temp->data;
    queue->front = queue->front->next;
    if (!queue->front) {
        queue->rear = NULL;
    }
    free(temp);
    return data;
}

char* peek(struct Queue* queue) {
    if (!queue->front) {
        printf("Queue is empty. Peek failed.\n");
        return "";
    }
    return queue->front->data;
}

int isEmpty(struct Queue* queue) {
    return !queue->front;
}

int main() {
    struct Queue* queue = createQueue();
    char data[MAX_LENGTH];
    int choice;

    do {
        printf("\n1. Insert");
        printf("\n2. Delete");
        printf("\n3. Peek");
        printf("\n0. Exit");
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%s", data);
                insert(queue, data);
                break;
            case 2:
                printf("Deleted element: %s\n", delete(queue));
                break;
            case 3:
                printf("Element at front: %s\n", peek(queue));
                break;
            case 0:
                break;
            default:
                printf("Invalid choice! Please try again.\n");
        }
    } while (choice != 0);

    // Free the memory
    struct Node* current = queue->front;
    struct Node* next;
    while (current != NULL) {
        next = current->next;
        free(current);
        current = next;
    }
    free(queue);
    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 1
Enter value to insert: Hello

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 1
Enter value to insert: World

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 3
Element at front: Hello

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Deleted element: Hello

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Deleted element: World

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Queue is empty. Deletion failed.

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 0
                    </code>
                    </pre>

                    </section>                
                <section id="QUE5">
                    <p>IMPLEMENT THE OPERATIONS OF CIRCULAR QUEUE IN AN INTEGER ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 5

struct CircularQueue {
    int *arr;
    int front, rear;
};

struct CircularQueue *createQueue() {
    struct CircularQueue *queue = (struct CircularQueue *)malloc(sizeof(struct CircularQueue));
    if (!queue) {
        return NULL;
    }
    queue->arr = (int *)malloc(MAX_SIZE * sizeof(int));
    if (!(queue->arr)) {
        return NULL;
    }
    queue->front = queue->rear = -1;
    return queue;
}

int isEmpty(struct CircularQueue *queue) {
    return (queue->front == -1);
}

int isFull(struct CircularQueue *queue) {
    return ((queue->rear + 1) % MAX_SIZE == queue->front);
}

void insert(struct CircularQueue *queue, int data) {
    if (isFull(queue)) {
        printf("Queue is full. Insertion failed.\n");
        return;
    }
    if (isEmpty(queue)) {
        queue->front = queue->rear = 0;
    } else {
        queue->rear = (queue->rear + 1) % MAX_SIZE;
    }
    queue->arr[queue->rear] = data;
    printf("%d inserted successfully.\n", data);
}

int delete(struct CircularQueue *queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Deletion failed.\n");
        return -1;
    }
    int data = queue->arr[queue->front];
    if (queue->front == queue->rear) {
        queue->front = queue->rear = -1;
    } else {
        queue->front = (queue->front + 1) % MAX_SIZE;
    }
    return data;
}

int peek(struct CircularQueue *queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Peek failed.\n");
        return -1;
    }
    return queue->arr[queue->front];
}

int main() {
    struct CircularQueue *queue = createQueue();
    int data, choice;

    do {
        printf("\n1. Insert");
        printf("\n2. Delete");
        printf("\n3. Peek");
        printf("\n0. Exit");
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%d", &data);
                insert(queue, data);
                break;
            case 2:
                printf("Deleted element: %d\n", delete(queue));
                break;
            case 3:
                printf("Element at front: %d\n", peek(queue));
                break;
            case 0:
                break;
            default:
                printf("Invalid choice! Please try again.\n");
        }
    } while (choice != 0);

    free(queue->arr);
    free(queue);
    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
1 inserted successfully.
2 inserted successfully.
3 inserted successfully.
4 inserted successfully.
Queue is full. Insertion failed.
Deleted element: 1
Element at front: 2
                    </code>
                    </pre>

                    </section>                                                                
        <section id="QUE6">
                    <p>IMPLEMENT THE OPERATIONS OF CIRCULAR QUEUE IN AN STRING ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SIZE 5
#define MAX_LENGTH 50

struct CircularQueue {
    char **arr;
    int front, rear;
};

struct CircularQueue *createQueue() {
    struct CircularQueue *queue = (struct CircularQueue *)malloc(sizeof(struct CircularQueue));
    if (!queue) {
        return NULL;
    }
    queue->arr = (char **)malloc(MAX_SIZE * sizeof(char *));
    if (!(queue->arr)) {
        return NULL;
    }
    for (int i = 0; i < MAX_SIZE; i++) {
        queue->arr[i] = (char *)malloc(MAX_LENGTH * sizeof(char));
    }
    queue->front = queue->rear = -1;
    return queue;
}

int isEmpty(struct CircularQueue *queue) {
    return (queue->front == -1);
}

int isFull(struct CircularQueue *queue) {
    return ((queue->rear + 1) % MAX_SIZE == queue->front);
}

void insert(struct CircularQueue *queue, char *data) {
    if (isFull(queue)) {
        printf("Queue is full. Insertion failed.\n");
        return;
    }
    if (isEmpty(queue)) {
        queue->front = queue->rear = 0;
    } else {
        queue->rear = (queue->rear + 1) % MAX_SIZE;
    }
    strcpy(queue->arr[queue->rear], data);
    printf("%s inserted successfully.\n", data);
}

char *delete (struct CircularQueue *queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Deletion failed.\n");
        return "";
    }
    char *data = queue->arr[queue->front];
    if (queue->front == queue->rear) {
        queue->front = queue->rear = -1;
    } else {
        queue->front = (queue->front + 1) % MAX_SIZE;
    }
    return data;
}

char *peek(struct CircularQueue *queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Peek failed.\n");
        return "";
    }
    return queue->arr[queue->front];
}

int main() {
    struct CircularQueue *queue = createQueue();
    char data[MAX_LENGTH];
    int choice;

    do {
        printf("\n1. Insert");
        printf("\n2. Delete");
        printf("\n3. Peek");
        printf("\n0. Exit");
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%s", data);
                insert(queue, data);
                break;
            case 2:
                printf("Deleted element: %s\n", delete(queue));
                break;
            case 3:
                printf("Element at front: %s\n", peek(queue));
                break;
            case 0:
                break;
            default:
                printf("Invalid choice! Please try again.\n");
        }
    } while (choice != 0);

    for (int i = 0; i < MAX_SIZE; i++) {
        free(queue->arr[i]);
    }
    free(queue->arr);
    free(queue);
    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 1
Enter value to insert: Apple
Apple inserted successfully.

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 1
Enter value to insert: Banana
Banana inserted successfully.

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 3
Element at front: Apple

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Deleted element: Apple

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Deleted element: Banana

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Queue is empty. Deletion failed.

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 0
                    </code>
                    </pre>

                    </section>
        <section id="QUE7">
                    <p>IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE IN AN INTEGER ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 5

struct PriorityQueue {
    int *arr;
    int front, rear;
};

struct PriorityQueue *createQueue() {
    struct PriorityQueue *queue = (struct PriorityQueue *)malloc(sizeof(struct PriorityQueue));
    if (!queue) {
        return NULL;
    }
    queue->arr = (int *)malloc(MAX_SIZE * sizeof(int));
    if (!(queue->arr)) {
        return NULL;
    }
    queue->front = queue->rear = -1;
    return queue;
}

int isEmpty(struct PriorityQueue *queue) {
    return (queue->front == -1);
}

int isFull(struct PriorityQueue *queue) {
    return (queue->rear == MAX_SIZE - 1);
}

void insert(struct PriorityQueue *queue, int data) {
    if (isFull(queue)) {
        printf("Queue is full. Insertion failed.\n");
        return;
    }
    if (isEmpty(queue)) {
        queue->front = queue->rear = 0;
        queue->arr[queue->rear] = data;
    } else {
        int i, j;
        for (i = 0; i <= queue->rear; i++) {
            if (data >= queue->arr[i]) {
                for (j = queue->rear + 1; j > i; j--) {
                    queue->arr[j] = queue->arr[j - 1];
                }
                queue->arr[i] = data;
                break;
            }
        }
        if (i == queue->rear + 1) {
            queue->arr[i] = data;
        }
        queue->rear++;
    }
    printf("%d inserted successfully.\n", data);
}

int delete (struct PriorityQueue *queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Deletion failed.\n");
        return -1;
    }
    int data = queue->arr[queue->front];
    if (queue->front == queue->rear) {
        queue->front = queue->rear = -1;
    } else {
        queue->front++;
    }
    return data;
}

int peek(struct PriorityQueue *queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Peek failed.\n");
        return -1;
    }
    return queue->arr[queue->front];
}

int main() {
    struct PriorityQueue *queue = createQueue();

    insert(queue, 3);
    insert(queue, 5);
    insert(queue, 2);
    insert(queue, 1);
    insert(queue, 4);
    insert(queue, 6);

    printf("Deleted element: %d\n", delete(queue));
    printf("Element at front: %d\n", peek(queue));

    free(queue->arr);
    free(queue);
    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
3 inserted successfully.
5 inserted successfully.
2 inserted successfully.
1 inserted successfully.
4 inserted successfully.
Queue is full. Insertion failed.
Deleted element: 1
Element at front: 2

                    </code>
                    </pre>

                    </section>
<section id="QUE8">
                    <p>IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE IN AN STRING ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SIZE 5
#define MAX_LENGTH 50

struct PriorityQueue {
    char **arr;
    int front, rear;
};

struct PriorityQueue *createQueue() {
    struct PriorityQueue *queue = (struct PriorityQueue *)malloc(sizeof(struct PriorityQueue));
    if (!queue) {
        return NULL;
    }
    queue->arr = (char **)malloc(MAX_SIZE * sizeof(char *));
    if (!(queue->arr)) {
        return NULL;
    }
    for (int i = 0; i < MAX_SIZE; i++) {
        queue->arr[i] = (char *)malloc(MAX_LENGTH * sizeof(char));
    }
    queue->front = queue->rear = -1;
    return queue;
}

int isEmpty(struct PriorityQueue *queue) {
    return (queue->front == -1);
}

int isFull(struct PriorityQueue *queue) {
    return (queue->rear == MAX_SIZE - 1);
}

void insert(struct PriorityQueue *queue, char *data) {
    if (isFull(queue)) {
        printf("Queue is full. Insertion failed.\n");
        return;
    }
    if (isEmpty(queue)) {
        queue->front = queue->rear = 0;
        strcpy(queue->arr[queue->rear], data);
    } else {
        int i, j;
        for (i = 0; i <= queue->rear; i++) {
            if (strcmp(data, queue->arr[i]) >= 0) {
                for (j = queue->rear + 1; j > i; j--) {
                    strcpy(queue->arr[j], queue->arr[j - 1]);
                }
                strcpy(queue->arr[i], data);
                break;
            }
        }
        if (i == queue->rear + 1) {
            strcpy(queue->arr[i], data);
        }
        queue->rear++;
    }
    printf("%s inserted successfully.\n", data);
}

char *delete (struct PriorityQueue *queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Deletion failed.\n");
        return "";
    }
    char *data = queue->arr[queue->front];
    if (queue->front == queue->rear) {
        queue->front = queue->rear = -1;
    } else {
        queue->front++;
    }
    return data;
}

char *peek(struct PriorityQueue *queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Peek failed.\n");
        return "";
    }
    return queue->arr[queue->front];
}

int main() {
    struct PriorityQueue *queue = createQueue();

    insert(queue, "apple");
    insert(queue, "orange");
    insert(queue, "banana");
    insert(queue, "kiwi");
    insert(queue, "grapes");
    insert(queue, "cherry");

    printf("Deleted element: %s\n", delete(queue));
    printf("Element at front: %s\n", peek(queue));

    for (int i = 0; i < MAX_SIZE; i++) {
        free(queue->arr[i]);
    }
    free(queue->arr);
    free(queue);
    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
apple inserted successfully.
orange inserted successfully.
banana inserted successfully.
kiwi inserted successfully.
grapes inserted successfully.
Queue is full. Insertion failed.
Deleted element: apple
Element at front: banana
                    </code>
                    </pre>

                    </section>
<section id="QUE9">
                    <p>IMPLEMENT THE OPERATIONS OF DOUBLE ENDED QUEUE IN AN INTEGER ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 5

struct Deque {
    int *arr;
    int front, rear;
};

struct Deque *createDeque() {
    struct Deque *deque = (struct Deque *)malloc(sizeof(struct Deque));
    if (!deque) {
        return NULL;
    }
    deque->arr = (int *)malloc(MAX_SIZE * sizeof(int));
    if (!(deque->arr)) {
        return NULL;
    }
    deque->front = -1;
    deque->rear = 0;
    return deque;
}

int isEmpty(struct Deque *deque) {
    return (deque->front == -1);
}

int isFull(struct Deque *deque) {
    return ((deque->front == 0 && deque->rear == MAX_SIZE - 1) || deque->front == deque->rear + 1);
}

void insertFront(struct Deque *deque, int data) {
    if (isFull(deque)) {
        printf("Deque is full. Insertion at the front failed.\n");
        return;
    }
    if (deque->front == -1) {
        deque->front = deque->rear = 0;
    } else if (deque->front == 0) {
        deque->front = MAX_SIZE - 1;
    } else {
        deque->front--;
    }
    deque->arr[deque->front] = data;
    printf("%d inserted at the front successfully.\n", data);
}

void insertRear(struct Deque *deque, int data) {
    if (isFull(deque)) {
        printf("Deque is full. Insertion at the rear failed.\n");
        return;
    }
    if (deque->front == -1) {
        deque->front = deque->rear = 0;
    } else if (deque->rear == MAX_SIZE - 1) {
        deque->rear = 0;
    } else {
        deque->rear++;
    }
    deque->arr[deque->rear] = data;
    printf("%d inserted at the rear successfully.\n", data);
}

int deleteFront(struct Deque *deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty. Deletion from the front failed.\n");
        return -1;
    }
    int data = deque->arr[deque->front];
    if (deque->front == deque->rear) {
        deque->front = deque->rear = -1;
    } else if (deque->front == MAX_SIZE - 1) {
        deque->front = 0;
    } else {
        deque->front++;
    }
    return data;
}

int deleteRear(struct Deque *deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty. Deletion from the rear failed.\n");
        return -1;
    }
    int data = deque->arr[deque->rear];
    if (deque->front == deque->rear) {
        deque->front = deque->rear = -1;
    } else if (deque->rear == 0) {
        deque->rear = MAX_SIZE - 1;
    } else {
        deque->rear--;
    }
    return data;
}

int getFront(struct Deque *deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty. Peek from the front failed.\n");
        return -1;
    }
    return deque->arr[deque->front];
}

int getRear(struct Deque *deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty. Peek from the rear failed.\n");
        return -1;
    }
    return deque->arr[deque->rear];
}

int main() {
    struct Deque *deque = createDeque();

    insertFront(deque, 3);
    insertRear(deque, 5);
    insertFront(deque, 2);
    insertRear(deque, 4);

    printf("Deleted element from front: %d\n", deleteFront(deque));
    printf("Deleted element from rear: %d\n", deleteRear(deque));
    printf("Element at front: %d\n", getFront(deque));
    printf("Element at rear: %d\n", getRear(deque));

    free(deque->arr);
    free(deque);
    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
3 inserted at the front successfully.
5 inserted at the rear successfully.
2 inserted at the front successfully.
4 inserted at the rear successfully.
Deleted element from front: 2
Deleted element from rear: 4
Element at front: 3
Element at rear: 5
            
                    </code>
                    </pre>

                    </section>
<section id="QUE10">
                    <p>IMPLEMENT THE OPERATIONS OF DOUBLE ENDED QUEUE IN AN STRING ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SIZE 5
#define MAX_LENGTH 50

struct Deque {
    char **arr;
    int front, rear;
};

struct Deque *createDeque() {
    struct Deque *deque = (struct Deque *)malloc(sizeof(struct Deque));
    if (!deque) {
        return NULL;
    }
    deque->arr = (char **)malloc(MAX_SIZE * sizeof(char *));
    if (!(deque->arr)) {
        return NULL;
    }
    for (int i = 0; i < MAX_SIZE; i++) {
        deque->arr[i] = (char *)malloc(MAX_LENGTH * sizeof(char));
    }
    deque->front = -1;
    deque->rear = 0;
    return deque;
}

int isEmpty(struct Deque *deque) {
    return (deque->front == -1);
}

int isFull(struct Deque *deque) {
    return ((deque->front == 0 && deque->rear == MAX_SIZE - 1) || deque->front == deque->rear + 1);
}

void insertFront(struct Deque *deque, char *data) {
    if (isFull(deque)) {
        printf("Deque is full. Insertion at the front failed.\n");
        return;
    }
    if (deque->front == -1) {
        deque->front = deque->rear = 0;
    } else if (deque->front == 0) {
        deque->front = MAX_SIZE - 1;
    } else {
        deque->front--;
    }
    strcpy(deque->arr[deque->front], data);
    printf("%s inserted at the front successfully.\n", data);
}

void insertRear(struct Deque *deque, char *data) {
    if (isFull(deque)) {
        printf("Deque is full. Insertion at the rear failed.\n");
        return;
    }
    if (deque->front == -1) {
        deque->front = deque->rear = 0;
    } else if (deque->rear == MAX_SIZE - 1) {
        deque->rear = 0;
    } else {
        deque->rear++;
    }
    strcpy(deque->arr[deque->rear], data);
    printf("%s inserted at the rear successfully.\n", data);
}

char *deleteFront(struct Deque *deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty. Deletion from the front failed.\n");
        return "";
    }
    char *data = deque->arr[deque->front];
    if (deque->front == deque->rear) {
        deque->front = deque->rear = -1;
    } else if (deque->front == MAX_SIZE - 1) {
        deque->front = 0;
    } else {
        deque->front++;
    }
    return data;
}

char *deleteRear(struct Deque *deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty. Deletion from the rear failed.\n");
        return "";
    }
    char *data = deque->arr[deque->rear];
    if (deque->front == deque->rear) {
        deque->front = deque->rear = -1;
    } else if (deque->rear == 0) {
        deque->rear = MAX_SIZE - 1;
    } else {
        deque->rear--;
    }
    return data;
}

char *getFront(struct Deque *deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty. Peek from the front failed.\n");
        return "";
    }
    return deque->arr[deque->front];
}

char *getRear(struct Deque *deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty. Peek from the rear failed.\n");
        return "";
    }
    return deque->arr[deque->rear];
}

int main() {
    struct Deque *deque = createDeque();

    insertFront(deque, "apple");
    insertRear(deque, "banana");
    insertFront(deque, "orange");
    insertRear(deque, "cherry");

    printf("Deleted element from front: %s\n", deleteFront(deque));
    printf("Deleted element from rear: %s\n", deleteRear(deque));
    printf("Element at front: %s\n", getFront(deque));
    printf("Element at rear: %s\n", getRear(deque));

    for (int i = 0; i < MAX_SIZE; i++) {
        free(deque->arr[i]);
    }
    free(deque->arr);
    free(deque);
    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
apple inserted at the front successfully.
banana inserted at the rear successfully.
orange inserted at the front successfully.
cherry inserted at the rear successfully.
Deleted element from front: orange
Deleted element from rear: cherry
Element at front: apple
Element at rear: banana
                    </code>
                    </pre>

                    </section>
<section id="QUE11">
                    <p>IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE DYNAMICALLY OF INTEGERS (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    int priority;
    struct Node *next;
};

struct Node *front = NULL;

void insert(int data, int priority) {
    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->priority = priority;
    if (front == NULL || priority < front->priority) {
        newNode->next = front;
        front = newNode;
    } else {
        struct Node *temp = front;
        while (temp->next != NULL && temp->next->priority <= priority) {
            temp = temp->next;
        }
        newNode->next = temp->next;
        temp->next = newNode;
    }
}

void delete() {
    if (front == NULL) {
        printf("Priority queue is empty. Deletion failed.\n");
        return;
    }
    struct Node *temp = front;
    front = front->next;
    free(temp);
}

int peek() {
    if (front == NULL) {
        printf("Priority queue is empty. Peek failed.\n");
        return -1;
    }
    return front->data;
}

int isEmpty() {
    return front == NULL;
}

int isFull() {
    return 0;
}

int main() {
    insert(5, 2);
    insert(10, 1);
    insert(15, 0);

    printf("Element at front: %d\n", peek());
    delete();
    printf("Element at front after deletion: %d\n", peek());

    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
Element at front: 15
Element at front after deletion: 10
                    </code>
                    </pre>

                    </section>
                    <section id="QUE12">
                    <p>IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE DYNAMICALLY OF STRING (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    char *data;
    int priority;
    struct Node *next;
};

struct Node *front = NULL;

void insert(char *data, int priority) {
    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));
    newNode->data = strdup(data);
    newNode->priority = priority;
    if (front == NULL || priority < front->priority) {
        newNode->next = front;
        front = newNode;
    } else {
        struct Node *temp = front;
        while (temp->next != NULL && temp->next->priority <= priority) {
            temp = temp->next;
        }
        newNode->next = temp->next;
        temp->next = newNode;
    }
}

void delete() {
    if (front == NULL) {
        printf("Priority queue is empty. Deletion failed.\n");
        return;
    }
    struct Node *temp = front;
    front = front->next;
    free(temp->data);
    free(temp);
}

char *peek() {
    if (front == NULL) {
        printf("Priority queue is empty. Peek failed.\n");
        return "";
    }
    return front->data;
}

int isEmpty() {
    return front == NULL;
}

int isFull() {
    return 0;
}

int main() {
    insert("apple", 2);
    insert("banana", 1);
    insert("cherry", 0);

    printf("Element at front: %s\n", peek());
    delete();
    printf("Element at front after deletion: %s\n", peek());

    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
Element at front: cherry
Element at front after deletion: banana
                    </code>
                    </pre>

                    </section>
                    <section id="QUE13">
                    <p>Find the first circular tour that visits all petrol pumps</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <stdlib.h>
#define MAX 100

int stations = 0;
int graph[MAX][MAX];
int visited[MAX] = {0};
int queue[MAX], front = -1, rear = -1;

void enqueue(int item) {
    if (rear == MAX - 1) {
        printf("Queue Overflow\n");
    } else {
        if (front == -1)
            front = 0;
        rear++;
        queue[rear] = item;
    }
}

int dequeue() {
    int item;
    if (front == -1 || front > rear) {
        printf("Queue Underflow\n");
        exit(1);
    }
    item = queue[front];
    front++;
    return item;
}

void findTour() {
    int i, current;
    enqueue(0);
    visited[0] = 1;

    while (front <= rear) {
        current = dequeue();
        printf("%d ", current);

        for (i = 0; i < stations; i++) {
            if (!visited[i] && graph[current][i] == 1) {
                enqueue(i);
                visited[i] = 1;
            }
        }
    }
}

int main() {
    int i, j;
    printf("Enter the number of stations: ");
    scanf("%d", &stations);

    printf("Enter the adjacency matrix for the stations (0/1):\n");
    for (i = 0; i < stations; i++) {
        for (j = 0; j < stations; j++) {
            scanf("%d", &graph[i][j]);
        }
    }

    printf("The tour is: ");
    findTour();
    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
Enter the number of stations: 4
Enter the adjacency matrix for the stations (0/1):
0 1 1 0
1 0 1 0
1 1 0 1
0 0 1 0
The tour is: 0 1 2 3
                    </code>
                    </pre>

                    </section>
<section id="QUE14">
                    <p>Length of the longest valid substring</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node* next;
} Node;

typedef struct Queue {
    Node *front, *rear;
} Queue;

Queue* createQueue() {
    Queue* queue = (Queue*)malloc(sizeof(Queue));
    queue->front = queue->rear = NULL;
    return queue;
}

void enqueue(Queue* queue, int data) {
    Node* temp = (Node*)malloc(sizeof(Node));
    temp->data = data;
    temp->next = NULL;

    if (queue->rear == NULL) {
        queue->front = queue->rear = temp;
        return;
    }

    queue->rear->next = temp;
    queue->rear = temp;
}

int dequeue(Queue* queue) {
    if (queue->front == NULL)
        return -1;

    Node* temp = queue->front;
    queue->front = queue->front->next;

    if (queue->front == NULL)
        queue->rear = NULL;

    int data = temp->data;
    free(temp);
    return data;
}

int longestValidSubstring(char* s) {
    int n = strlen(s);
    Queue* queue = createQueue();
    int result = 0;

    enqueue(queue, -1);

    for (int i = 0; i < n; i++) {
        if (s[i] == '(')
            enqueue(queue, i);
        else {
            dequeue(queue);
            if (!queue->front)
                enqueue(queue, i);
            else
                result = result > (i - queue->front->data) ? result : (i - queue->front->data);
        }
    }
    return result;
}

int main() {
    char s[] = "((())()";
    printf("The length of the longest valid substring is: %d", longestValidSubstring(s));
    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
The length of the longest valid substring is: 4
                    </code>
                    </pre>

                    </section>
                    <section id="QUE15">
                    <p>Find the Next Greater Element</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <stdlib.h>

#define SIZE 100

typedef struct Node {
    int data;
    struct Node *next;
} Node;

typedef struct Queue {
    Node *front, *rear;
} Queue;

Queue *createQueue() {
    Queue *queue = (Queue *)malloc(sizeof(Queue));
    queue->front = queue->rear = NULL;
    return queue;
}

void enqueue(Queue *queue, int data) {
    Node *temp = (Node *)malloc(sizeof(Node));
    temp->data = data;
    temp->next = NULL;

    if (queue->rear == NULL) {
        queue->front = queue->rear = temp;
        return;
    }

    queue->rear->next = temp;
    queue->rear = temp;
}

int dequeue(Queue *queue) {
    if (queue->front == NULL)
        return -1;

    Node *temp = queue->front;
    queue->front = queue->front->next;

    if (queue->front == NULL)
        queue->rear = NULL;

    int data = temp->data;
    free(temp);
    return data;
}

void nextLargerElement(int arr[], int n) {
    Queue *queue = createQueue();

    enqueue(queue, arr[0]);

    for (int i = 1; i < n; i++) {
        int next = arr[i];

        if (queue->front == NULL) {
            enqueue(queue, next);
            continue;
        }

        while (queue->front != NULL) {
            int element = dequeue(queue);

            if (element < next)
                printf("%d -- %d\n", element, next);
            else {
                enqueue(queue, element);
                break;
            }
        }
        enqueue(queue, next);
    }

    while (queue->front != NULL) {
        int element = dequeue(queue);
        printf("%d -- %d\n", element, -1);
    }
}

int main() {
    int arr[] = {11, 13, 21, 3};
    int n = sizeof(arr) / sizeof(arr[0]);

    nextLargerElement(arr, n);
    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
11 -- 13
13 -- 21
21 -- -1
3 -- -1
                    </code>
                    </pre>

                    </section>
<section id="QUE16">
                    <p>Find Next Smaller Element</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <stdlib.h>

#define SIZE 100

typedef struct Node {
    int data;
    struct Node *next;
} Node;

typedef struct Queue {
    Node *front, *rear;
} Queue;

Queue *createQueue() {
    Queue *queue = (Queue *)malloc(sizeof(Queue));
    queue->front = queue->rear = NULL;
    return queue;
}

void enqueue(Queue *queue, int data) {
    Node *temp = (Node *)malloc(sizeof(Node));
    temp->data = data;
    temp->next = NULL;

    if (queue->rear == NULL) {
        queue->front = queue->rear = temp;
        return;
    }

    queue->rear->next = temp;
    queue->rear = temp;
}

int dequeue(Queue *queue) {
    if (queue->front == NULL)
        return -1;

    Node *temp = queue->front;
    queue->front = queue->front->next;

    if (queue->front == NULL)
        queue->rear = NULL;

    int data = temp->data;
    free(temp);
    return data;
}

void nextSmallerElement(int arr[], int n) {
    Queue *queue = createQueue();

    enqueue(queue, arr[0]);

    for (int i = 1; i < n; i++) {
        int next = arr[i];

        if (queue->front == NULL) {
            enqueue(queue, next);
            continue;
        }

        while (queue->front != NULL) {
            int element = dequeue(queue);

            if (element > next)
                printf("%d -- %d\n", element, next);
            else {
                enqueue(queue, element);
                break;
            }
        }
        enqueue(queue, next);
    }

    while (queue->front != NULL) {
        int element = dequeue(queue);
        printf("%d -- %d\n", element, -1);
    }
}

int main() {
    int arr[] = {4, 8, 5, 2, 25};
    int n = sizeof(arr) / sizeof(arr[0]);

    nextSmallerElement(arr, n);
    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
4 -- 2
8 -- 5
5 -- 2
2 -- -1
25 -- -1
                    </code>
                    </pre>

                    </section>     
                    <section id="QUE17">
                        <p>Queue based approach for first non repeating character in a stream</p>
                        <pre>
                        <code >
#include <stdio.h>
#include <stdlib.h>
#define MAX_CHAR 26

typedef struct Queue {
    int front, rear;
    unsigned capacity;
    char* array;
} Queue;

Queue* createQueue(unsigned capacity) {
    Queue* queue = (Queue*)malloc(sizeof(Queue));
    queue->capacity = capacity;
    queue->front = queue->rear = -1;
    queue->array = (char*)malloc(queue->capacity * sizeof(char));
    return queue;
}

int isFull(Queue* queue) {
    return (queue->rear + 1) % queue->capacity == queue->front;
}

int isEmpty(Queue* queue) {
    return queue->front == -1;
}

void enqueue(Queue* queue, char item) {
    if (isFull(queue))
        return;
    if (isEmpty(queue))
        queue->front = 0;
    queue->rear = (queue->rear + 1) % queue->capacity;
    queue->array[queue->rear] = item;
}

char dequeue(Queue* queue) {
    if (isEmpty(queue))
        return '\0';
    char item = queue->array[queue->front];
    if (queue->front == queue->rear)
        queue->front = queue->rear = -1;
    else
        queue->front = (queue->front + 1) % queue->capacity;
    return item;
}

void findFirstNonRepeating(char* stream) {
    Queue* queue = createQueue(MAX_CHAR);
    int charCount[MAX_CHAR] = {0};

    for (int i = 0; stream[i]; i++) {
        enqueue(queue, stream[i]);
        charCount[stream[i] - 'a']++;

        while (!isEmpty(queue)) {
            if (charCount[queue->array[queue->front] - 'a'] > 1)
                dequeue(queue);
            else {
                printf("First non-repeating character so far is %c\n", queue->array[queue->front]);
                break;
            }
        }
        if (isEmpty(queue))
            printf("No non-repeating character so far\n");
    }
}

int main() {
    char stream[] = "abacabad";
    findFirstNonRepeating(stream);
    return 0;
}   
                        </code>
                        <p>OUTPUT</p>
                        <code>
First non-repeating character so far is a
First non-repeating character so far is b
First non-repeating character so far is b
First non-repeating character so far is b
First non-repeating character so far is b
First non-repeating character so far is b
First non-repeating character so far is d   
                        </code>
                        </pre>
    
                        </section>                                  
    </section>
                    <section id="QUE18">
                        <p>Reverse First K elements of Queue</p>
                        <pre>
                        <code >
#include <stdio.h>
#include <stdlib.h>

typedef struct Queue {
    int front, rear, size;
    unsigned capacity;
    int* array;
} Queue;

Queue* createQueue(unsigned capacity) {
    Queue* queue = (Queue*)malloc(sizeof(Queue));
    queue->capacity = capacity;
    queue->front = queue->size = 0;
    queue->rear = capacity - 1;
    queue->array = (int*)malloc(queue->capacity * sizeof(int));
    return queue;
}

int isFull(Queue* queue) {
    return (queue->size == queue->capacity);
}

int isEmpty(Queue* queue) {
    return (queue->size == 0);
}

void enqueue(Queue* queue, int item) {
    if (isFull(queue))
        return;
    queue->rear = (queue->rear + 1) % queue->capacity;
    queue->array[queue->rear] = item;
    queue->size = queue->size + 1;
}

int dequeue(Queue* queue) {
    if (isEmpty(queue))
        return -1;
    int item = queue->array[queue->front];
    queue->front = (queue->front + 1) % queue->capacity;
    queue->size = queue->size - 1;
    return item;
}

void reverseKelements(Queue* queue, int k) {
    if (isEmpty(queue) || k > queue->size)
        return;

    int* temp = (int*)malloc(k * sizeof(int));

    for (int i = 0; i < k; i++)
        temp[i] = dequeue(queue);

    for (int i = k - 1; i >= 0; i--)
        enqueue(queue, temp[i]);

    for (int i = 0; i < queue->size - k; i++)
        enqueue(queue, dequeue(queue));

    free(temp);
}

void printQueue(Queue* queue) {
    for (int i = 0; i < queue->size; i++)
        printf("%d ", queue->array[(queue->front + i) % queue->capacity]);
    printf("\n");
}

int main() {
    Queue* queue = createQueue(10);
    for (int i = 1; i <= 10; i++)
        enqueue(queue, i);

    int k = 5;
    printf("Original queue: ");
    printQueue(queue);
    reverseKelements(queue, k);
    printf("Queue after reversing the first %d elements: ", k);
    printQueue(queue);

    return 0;
}    
                        </code>
                        <p>OUTPUT</p>
                        <code>
Original queue: 1 2 3 4 5 6 7 8 9 10
Queue after reversing the first 5 elements: 5 4 3 2 1 6 7 8 9 10   
                        </code>
                        </pre>
                        </section>                                  
    
                    <section id="QUE19">
                        <p>Queue Reversal</p>
                        <pre>
                        <code >
#include <stdio.h>
#include <stdlib.h>

#define SIZE 5

typedef struct Queue {
    int items[SIZE];
    int front;
    int rear;
} Queue;

void createQueue(Queue* q) {
    q->front = -1;
    q->rear = -1;
}

int isFull(Queue* q) {
    if ((q->front == q->rear + 1) || (q->front == 0 && q->rear == SIZE - 1))
        return 1;
    return 0;
}

int isEmpty(Queue* q) {
    if (q->front == -1)
        return 1;
    return 0;
}

void enQueue(Queue* q, int value) {
    if (isFull(q))
        printf("\nQueue is full!");
    else {
        if (q->front == -1)
            q->front = 0;
        q->rear = (q->rear + 1) % SIZE;
        q->items[q->rear] = value;
    }
}

int deQueue(Queue* q) {
    int item;
    if (isEmpty(q)) {
        printf("Queue is empty");
        item = -1;
    } else {
        item = q->items[q->front];
        if (q->front == q->rear) {
            q->front = -1;
            q->rear = -1;
        } else {
            q->front = (q->front + 1) % SIZE;
        }
    }
    return item;
}

void reverseQueue(Queue* q) {
    int temp;
    if (isEmpty(q)) {
        printf("Queue is empty");
        return;
    } else {
        while (q->front != q->rear) {
            temp = q->items[q->front];
            q->items[q->front] = q->items[q->rear];
            q->items[q->rear] = temp;
            q->front = (q->front + 1) % SIZE;
            q->rear = (q->rear - 1 + SIZE) % SIZE;
        }
    }
}

void printQueue(Queue* q) {
    int i;
    if (isEmpty(q)) {
        printf("Queue is empty");
    } else {
        printf("\nFront -> %d ", q->front);
        printf("\nItems -> ");
        for (i = q->front; i != q->rear; i = (i + 1) % SIZE) {
            printf("%d ", q->items[i]);
        }
        printf("%d ", q->items[i]);
        printf("\nRear -> %d", q->rear);
    }
}

int main() {
    Queue* q = (Queue*)malloc(sizeof(Queue));
    createQueue(q);
    enQueue(q, 1);
    enQueue(q, 2);
    enQueue(q, 3);
    enQueue(q, 4);
    enQueue(q, 5);
    printf("Original Queue: ");
    printQueue(q);
    reverseQueue(q);
    printf("\nReversed Queue: ");
    printQueue(q);

    return 0;
}   
                        </code>
                        <p>OUTPUT</p>
                        <code>
 Original Queue: 
Front -> 0 
Items -> 1 2 3 4 5 
Rear -> 4
Reversed Queue: 
Front -> 0 
Items -> 5 4 3 2 1 
Rear -> 4   
                        </code>
                        </pre>
    
                        </section>                                  
    
                    <section id="QUE20">
                        <p>Rotten Oranges</p>
                        <pre>
                        <code >
#include <stdio.h>

#define R 3
#define C 5

struct Node {
    int x;
    int y;
};

int isInsideGrid(int i, int j) {
    return (i >= 0 && i < R && j >= 0 && j < C);
}

int hasFreshOranges(int grid[R][C]) {
    int i, j;
    for (i = 0; i < R; i++) {
        for (j = 0; j < C; j++) {
            if (grid[i][j] == 1) {
                return 1;
            }
        }
    }
    return 0;
}

int findTime(int grid[R][C]) {
    struct Node queue[R * C];
    int front = 0, rear = 0;
    int row[] = {0, 0, 1, -1};
    int col[] = {1, -1, 0, 0};
    int timer = 0;

    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++) {
            if (grid[i][j] == 2) {
                queue[rear].x = i;
                queue[rear].y = j;
                rear++;
            }
        }
    }

    queue[rear].x = -1;
    queue[rear].y = -1;
    rear++;

    while (front < rear) {
        int flag = 0;
        while (queue[front].x != -1 && queue[front].y != -1) {
            for (int i = 0; i < 4; i++) {
                int newRow = queue[front].x + row[i];
                int newCol = queue[front].y + col[i];

                if (isInsideGrid(newRow, newCol) && grid[newRow][newCol] == 1) {
                    grid[newRow][newCol] = 2;
                    queue[rear].x = newRow;
                    queue[rear].y = newCol;
                    rear++;
                    if (flag == 0) {
                        flag = 1;
                        timer++;
                    }
                }
            }
            front++;
        }
        front++;
        if (flag == 1 && front < rear) {
            queue[rear].x = -1;
            queue[rear].y = -1;
            rear++;
        }
    }

    return hasFreshOranges(grid) ? -1 : timer;
}

int main() {
    int grid[R][C] = {{2, 1, 0, 2, 1},
                      {1, 0, 1, 2, 1},
                      {1, 0, 0, 2, 1}};

    int result = findTime(grid);
    if (result == -1) {
        printf("All oranges cannot rot");
    } else {
        printf("Time taken for all oranges to rot: %d", result);
    }
    return 0;
}    
                        </code>
                        <p>OUTPUT</p>
                        <code>
Time taken for all oranges to rot: 4  
                        </code>
                        </pre>
    
                        </section>                                  
    </section>

    <section id="linkedlist">
        <h2>LINKEDLIST PROBLEMS</h2>
        <ul>
            <li><a href="#ll1">Q-1:IMPLEMENT THE OPERATIONS OF SINGLE LINKED LIST STORING INTEGER VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</a></li>
            <li><a href="#ll2">Q-2:IMPLEMENT THE OPERATIONS OF SINGLE CIRCULAR LINKED LIST STORING INTEGER VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</a></li>
            <li><a href="#ll3">Q-3:IMPLEMENT THE OPERATIONS OF DOUBLY LINKED LIST STORING INTEGER VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</a></li>
            <li><a href="#ll4">Q-4:IMPLEMENT THE OPERATIONS OF DOUBLY CIRCULAR LINKED LIST STORING INTEGER VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</a></li>
            <li><a href="#ll5">Q-5:IMPLEMENT THE OPERATIONS OF SINGLE LINKED LIST STORING STRING VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</a></li>
            <li><a href="#ll6">Q-6:IMPLEMENT THE OPERATIONS OF SINGLE CIRCULAR LINKED LIST STORING STRING VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</a></li>
            <li><a href="#ll7">Q-7:IMPLEMENT THE OPERATIONS OF DOUBLY LINKED LIST STORING STRING VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</a></li>
            <li><a href="#ll8">Q-8:IMPLEMENT THE OPERATIONS OF DOUBLY CIRCULAR LINKED LIST STORING STRING VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</a></li>
            <li><a href="#ll9">Q-9:ENTER THE 2 POLYNOMIAL EQUATIONS DYNAMICALLY, ADD THEM AND DISPLAY THE ANSWER.</a></li>
            <li><a href="#ll10">Q-10:ENTER THE 2 POLYNOMIAL EQUATIONS DYNAMICALLY, SUBTRACT THEM AND DISPLAY THE ANSWER.</a></li>
            <li><a href="#ll11">Q-11:ENTER THE 2 POLYNOMIAL EQUATIONS DYNAMICALLY, MULTIPLY THEM AND DISPLAY THE ANSWER.</a></li>

            <section id="ll1">
                <p>Q-1:IMPLEMENT THE OPERATIONS OF SINGLE LINKED LIST STORING INTEGER VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</p>
                <pre>
                <code >
#include <stdio.h>
            #include <stdlib.h>
            
            struct Node {
                int data;
                struct Node* next;
            };
            
            struct LinkedList {
                struct Node* head;
            };
            
            struct Node* createNode(int data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                newNode->data = data;
                newNode->next = NULL;
                return newNode;
            }
            
            struct LinkedList* createLinkedList() {
                struct LinkedList* newList = (struct LinkedList*)malloc(sizeof(struct LinkedList));
                newList->head = NULL;
                return newList;
            }
            
            void insertAtBeginning(struct LinkedList* list, int data) {
                struct Node* newNode = createNode(data);
                newNode->next = list->head;
                list->head = newNode;
            }
            
            void insertAtEnd(struct LinkedList* list, int data) {
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                    return;
                }
                struct Node* current = list->head;
                while (current->next != NULL) {
                    current = current->next;
                }
                current->next = newNode;
            }
            
            void insertAtPosition(struct LinkedList* list, int data, int position) {
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    insertAtBeginning(list, data);
                    return;
                }
            
                struct Node* newNode = createNode(data);
                struct Node* current = list->head;
                int count = 1;
                while (current != NULL && count < position - 1) {
                    current = current->next;
                    count++;
                }
            
                if (current == NULL) {
                    printf("Position out of range\n");
                } else {
                    newNode->next = current->next;
                    current->next = newNode;
                }
            }
            
            void deleteAtBeginning(struct LinkedList* list) {
                if (list->head != NULL) {
                    struct Node* temp = list->head;
                    list->head = list->head->next;
                    free(temp);
                }
            }
            
            void deleteAtEnd(struct LinkedList* list) {
                if (list->head == NULL) {
                    return;
                }
                if (list->head->next == NULL) {
                    free(list->head);
                    list->head = NULL;
                    return;
                }
            
                struct Node* current = list->head;
                while (current->next->next != NULL) {
                    current = current->next;
                }
                free(current->next);
                current->next = NULL;
            }
            
            void deleteAtPosition(struct LinkedList* list, int position) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    struct Node* temp = list->head;
                    list->head = list->head->next;
                    free(temp);
                    return;
                }
            
                struct Node* current = list->head;
                int count = 1;
                while (current != NULL && count < position - 1) {
                    current = current->next;
                    count++;
                }
            
                if (current == NULL || current->next == NULL) {
                    printf("Position out of range\n");
                } else {
                    struct Node* temp = current->next;
                    current->next = current->next->next;
                    free(temp);
                }
            }
            
            int isEmpty(struct LinkedList* list) {
                return (list->head == NULL);
            }
            
            void display(struct LinkedList* list) {
                struct Node* current = list->head;
                while (current != NULL) {
                    printf("%d -> ", current->data);
                    current = current->next;
                }
                printf("NULL\n");
            }
            
            int search(struct LinkedList* list, int target) {
                struct Node* current = list->head;
                int position = 1;
                while (current != NULL) {
                    if (current->data == target) {
                        return position;
                    }
                    current = current->next;
                    position++;
                }
                return -1;
            }
            
            int main() {
                struct LinkedList* myList = createLinkedList();
                int choice, data, position, target;
            
                while (1) {
                    printf("\nSingly Linked List Operations:\n");
                    printf("1. Insert at Beginning\n");
                    printf("2. Insert at End\n");
                    printf("3. Insert at Position\n");
                    printf("4. Delete at Beginning\n");
                    printf("5. Delete at End\n");
                    printf("6. Delete at Position\n");
                    printf("7. Is Empty?\n");
                    printf("8. Display\n");
                    printf("9. Search\n");
                    printf("0. Exit\n");
                    printf("Enter your choice: ");
                    scanf("%d", &choice);
            
                    switch (choice) {
                        case 1:
                            printf("Enter data to insert at the beginning: ");
                            scanf("%d", &data);
                            insertAtBeginning(myList, data);
                            break;
                        case 2:
                            printf("Enter data to insert at the end: ");
                            scanf("%d", &data);
                            insertAtEnd(myList, data);
                            break;
                        case 3:
                            printf("Enter data to insert: ");
                            scanf("%d", &data);
                            printf("Enter the position: ");
                            scanf("%d", &position);
                            insertAtPosition(myList, data, position);
                            break;
                        case 4:
                            deleteAtBeginning(myList);
                            break;
                        case 5:
                            deleteAtEnd(myList);
                            break;
                        case 6:
                            printf("Enter the position to delete: ");
                            scanf("%d", &position);
                            deleteAtPosition(myList, position);
                            break;
                        case 7:
                            if (isEmpty(myList)) {
                                printf("The list is empty.\n");
                            } else {
                                printf("The list is not empty.\n");
                            }
                            break;
                        case 8:
                            printf("Linked List: ");
                            display(myList);
                            break;
                        case 9:
                            printf("Enter the element to search: ");
                            scanf("%d", &target);
                            position = search(myList, target);
                            if (position != -1) {
                                printf("Element %d found at position %d\n", target, position);
                            } else {
                                printf("Element %d not found\n", target);
                            }
                            break;
                        case 0:
                            exit(0);
                        default:
                            printf("Invalid choice. Please try again.\n");
                    }
                }
            
                return 0;
            }
                </code>
                <p>OUTPUT</p>
                <code>
 Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 1
            Enter data to insert at the beginning: 10
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 2
            Enter data to insert at the end: 20
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 3
            Enter data to insert: 15
            Enter the position: 2
            
            Singly Linked List: 10 -> 15 -> 20 -> NULL
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 4
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 5
            
            Singly Linked List: 10 -> 15 -> NULL
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 6
            Enter the position to delete: 2
            
            Singly Linked List: 10 -> NULL
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 7
            The list is not empty.
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 8
            Linked List: 10 -> NULL
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 9
            Enter the element to search: 20
            Element 20 not found
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 0
                </code>
                </pre>

                </section>
            <section id="ll2">
                <p>Q-2:IMPLEMENT THE OPERATIONS OF SINGLE CIRCULAR LINKED LIST STORING INTEGER VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</p>
                <pre>
                <code >
#include <stdio.h>
            #include <stdlib.h>
            
            struct Node {
                int data;
                struct Node* next;
            };
            
            struct CircularLinkedList {
                struct Node* head;
            };
            
            struct Node* createNode(int data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                newNode->data = data;
                newNode->next = NULL;
                return newNode;
            }
            
            struct CircularLinkedList* createCircularLinkedList() {
                struct CircularLinkedList* newList = (struct CircularLinkedList*)malloc(sizeof(struct CircularLinkedList));
                newList->head = NULL;
                return newList;
            }
            
            void insertAtBeginning(struct CircularLinkedList* list, int data) {
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    newNode->next = newNode;
                    list->head = newNode;
                } else {
                    struct Node* last = list->head;
                    while (last->next != list->head) {
                        last = last->next;
                    }
                    newNode->next = list->head;
                    last->next = newNode;
                    list->head = newNode;
                }
            }
            
            void insertAtEnd(struct CircularLinkedList* list, int data) {
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    newNode->next = newNode;
                    list->head = newNode;
                } else {
                    struct Node* last = list->head;
                    while (last->next != list->head) {
                        last = last->next;
                    }
                    newNode->next = list->head;
                    last->next = newNode;
                }
            }
            
            void insertAtPosition(struct CircularLinkedList* list, int data, int position) {
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    insertAtBeginning(list, data);
                    return;
                }
            
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    newNode->next = newNode;
                    list->head = newNode;
                } else {
                    struct Node* current = list->head;
                    int count = 1;
                    while (count < position - 1 && current->next != list->head) {
                        current = current->next;
                        count++;
                    }
                    newNode->next = current->next;
                    current->next = newNode;
                }
            }
            
            void deleteAtBeginning(struct CircularLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                } else {
                    struct Node* temp = list->head;
                    struct Node* last = list->head;
                    while (last->next != list->head) {
                        last = last->next;
                    }
                    if (list->head == list->head->next) {
                        list->head = NULL;
                    } else {
                        list->head = list->head->next;
                        last->next = list->head;
                    }
                    free(temp);
                }
            }
            
            void deleteAtEnd(struct CircularLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                } else {
                    struct Node* current = list->head;
                    struct Node* last = list->head;
                    struct Node* prev = NULL;
            
                    while (current->next != list->head) {
                        prev = last;
                        last = current;
                        current = current->next;
                    }
            
                    if (current == list->head) {
                        list->head = NULL;
                    } else {
                        prev->next = list->head;
                    }
                    free(current);
                }
            }
            
            void deleteAtPosition(struct CircularLinkedList* list, int position) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    deleteAtBeginning(list);
                    return;
                }
            
                struct Node* current = list->head;
                int count = 1;
                struct Node* prev = NULL;
                while (count < position && current->next != list->head) {
                    prev = current;
                    current = current->next;
                    count++;
                }
            
                if (current == list->head && count == position) {
                    deleteAtEnd(list);
                    return;
                }
            
                if (count != position) {
                    printf("Position out of range\n");
                } else {
                    prev->next = current->next;
                    free(current);
                }
            }
            
            int isEmpty(struct CircularLinkedList* list) {
                return (list->head == NULL);
            }
            
            void display(struct CircularLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty.\n");
                    return;
                }
                struct Node* current = list->head;
                do {
                    printf("%d -> ", current->data);
                    current = current->next;
                } while (current != list->head);
                printf(" (Head)\n");
            }
            
            int search(struct CircularLinkedList* list, int target) {
                if (list->head == NULL) {
                    return -1;
                }
                struct Node* current = list->head;
                int position = 1;
                do {
                    if (current->data == target) {
                        return position;
                    }
                    current = current->next;
                    position++;
                } while (current != list->head);
                return -1;
            }
            
            int main() {
                struct CircularLinkedList* myList = createCircularLinkedList();
                int choice, data, position, target;
            
                while (1) {
                    printf("\nSingle Circular Linked List Operations:\n");
                    printf("1. Insert at Beginning\n");
                    printf("2. Insert at End\n");
                    printf("3. Insert at Position\n");
                    printf("4. Delete at Beginning\n");
                    printf("5. Delete at End\n");
                    printf("6. Delete at Position\n");
                    printf("7. Is Empty?\n");
                    printf("8. Display\n");
                    printf("9. Search\n");
                    printf("0. Exit\n");
                    printf("Enter your choice: ");
                    scanf("%d", &choice);
            
                    switch (choice) {
                        case 1:
                            printf("Enter data to insert at the beginning: ");
                            scanf("%d", &data);
                            insertAtBeginning(myList, data);
                            break;
                        case 2:
                            printf("Enter data to insert at the end: ");
                            scanf("%d", &data);
                            insertAtEnd(myList, data);
                            break;
                        case 3:
                            printf("Enter data to insert: ");
                            scanf("%d", &data);
                            printf("Enter the position: ");
                            scanf("%d", &position);
                            insertAtPosition(myList, data, position);
                            break;
                        case 4:
                            deleteAtBeginning(myList);
                            break;
                        case 5:
                            deleteAtEnd(myList);
                            break;
                        case 6:
                            printf("Enter the position to delete: ");
                            scanf("%d", &position);
                            deleteAtPosition(myList, position);
                            break;
                        case 7:
                            if (isEmpty(myList)) {
                                printf("The list is empty.\n");
                            } else {
                                printf("The list is not empty.\n");
                            }
                            break;
                        case 8:
                            display(myList);
                            break;
                        case 9:
                            printf("Enter the element to search: ");
                            scanf("%d", &target);
                            position = search(myList, target);
                            if (position != -1) {
                                printf("Element %d found at position %d\n", target, position);
                            } else {
                                printf("Element %d not found\n", target);
                            }
                            break;
                        case 0:
                            exit(0);
                        default:
                            printf("Invalid choice. Please try again.\n");
                    }
                }
            
                return 0;
            }

                </code>
                <p>OUTPUT</p>
                <code>
Single Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 1
            Enter data to insert at the beginning: 10
            
            Single Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 2
            Enter data to insert at the end: 20
            
            Single Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 3
            Enter data to insert: 15
            Enter the position: 2
            
            Single Circular Linked List: 10 -> 15 -> 20 ->  (Head)
            
            Single Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 4
            
            Single Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 5
            
            Single Circular Linked List: 15 -> 20 ->  (Head)
            
            Single Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 6
            Enter the position to delete: 2
            
            Single Circular Linked List: 15 ->  (Head)
            
            Single Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 7
            The list is not empty.
            
            Single Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 8
            Single Circular Linked List: 15 ->  (Head)
            
            Single Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 9
            Enter the element to search: 20
            Element 20 not found
            
            Single Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 0
                </code>
                </pre>

                </section>
            <section id="ll3">
                <p>Q-3:IMPLEMENT THE OPERATIONS OF DOUBLY LINKED LIST STORING INTEGER VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</p>
                <pre>
                <code >
 #include <stdio.h>
            #include <stdlib.h>
            
            struct Node {
                int data;
                struct Node* prev;
                struct Node* next;
            };
            
            struct DoublyLinkedList {
                struct Node* head;
            };
            
            struct Node* createNode(int data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                newNode->data = data;
                newNode->prev = NULL;
                newNode->next = NULL;
                return newNode;
            }
            
            struct DoublyLinkedList* createDoublyLinkedList() {
                struct DoublyLinkedList* newList = (struct DoublyLinkedList*)malloc(sizeof(struct DoublyLinkedList));
                newList->head = NULL;
                return newList;
            }
            
            void insertAtBeginning(struct DoublyLinkedList* list, int data) {
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                } else {
                    newNode->next = list->head;
                    list->head->prev = newNode;
                    list->head = newNode;
                }
            }
            
            void insertAtEnd(struct DoublyLinkedList* list, int data) {
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                } else {
                    struct Node* current = list->head;
                    while (current->next != NULL) {
                        current = current->next;
                    }
                    current->next = newNode;
                    newNode->prev = current;
                }
            }
            
            void insertAtPosition(struct DoublyLinkedList* list, int data, int position) {
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    insertAtBeginning(list, data);
                    return;
                }
            
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                } else {
                    struct Node* current = list->head;
                    int count = 1;
                    while (count < position - 1 && current->next != NULL) {
                        current = current->next;
                        count++;
                    }
                    if (current->next != NULL) {
                        newNode->next = current->next;
                        current->next->prev = newNode;
                    }
                    current->next = newNode;
                    newNode->prev = current;
                }
            }
            
            void deleteAtBeginning(struct DoublyLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                struct Node* temp = list->head;
                list->head = list->head->next;
                if (list->head != NULL) {
                    list->head->prev = NULL;
                }
                free(temp);
            }
            
            void deleteAtEnd(struct DoublyLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                struct Node* current = list->head;
                while (current->next != NULL) {
                    current = current->next;
                }
                if (current->prev != NULL) {
                    current->prev->next = NULL;
                } else {
                    list->head = NULL;
                }
                free(current);
            }
            
            void deleteAtPosition(struct DoublyLinkedList* list, int position) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    deleteAtBeginning(list);
                    return;
                }
                struct Node* current = list->head;
                int count = 1;
                while (count < position && current->next != NULL) {
                    current = current->next;
                    count++;
                }
                if (current->prev != NULL) {
                    current->prev->next = current->next;
                } else {
                    list->head = current->next;
                }
                if (current->next != NULL) {
                    current->next->prev = current->prev;
                }
                free(current);
            }
            
            int isEmpty(struct DoublyLinkedList* list) {
                return (list->head == NULL);
            }
            
            void display(struct DoublyLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty.\n");
                    return;
                }
                struct Node* current = list->head;
                while (current != NULL) {
                    printf("%d -> ", current->data);
                    current = current->next;
                }
                printf("NULL\n");
            }
            
            int search(struct DoublyLinkedList* list, int target) {
                if (list->head == NULL) {
                    return -1;
                }
                struct Node* current = list->head;
                int position = 1;
                while (current != NULL) {
                    if (current->data == target) {
                        return position;
                    }
                    current = current->next;
                    position++;
                }
                return -1;
            }
            
            int main() {
                struct DoublyLinkedList* myList = createDoublyLinkedList();
                int choice, data, position, target;
            
                while (1) {
                    printf("\nDoubly Linked List Operations:\n");
                    printf("1. Insert at Beginning\n");
                    printf("2. Insert at End\n");
                    printf("3. Insert at Position\n");
                    printf("4. Delete at Beginning\n");
                    printf("5. Delete at End\n");
                    printf("6. Delete at Position\n");
                    printf("7. Is Empty?\n");
                    printf("8. Display\n");
                    printf("9. Search\n");
                    printf("0. Exit\n");
                    printf("Enter your choice: ");
                    scanf("%d", &choice);
            
                    switch (choice) {
                        case 1:
                            printf("Enter data to insert at the beginning: ");
                            scanf("%d", &data);
                            insertAtBeginning(myList, data);
                            break;
                        case 2:
                            printf("Enter data to insert at the end: ");
                            scanf("%d", &data);
                            insertAtEnd(myList, data);
                            break;
                        case 3:
                            printf("Enter data to insert: ");
                            scanf("%d", &data);
                            printf("Enter the position: ");
                            scanf("%d", &position);
                            insertAtPosition(myList, data, position);
                            break;
                        case 4:
                            deleteAtBeginning(myList);
                            break;
                        case 5:
                            deleteAtEnd(myList);
                            break;
                        case 6:
                            printf("Enter the position to delete: ");
                            scanf("%d", &position);
                            deleteAtPosition(myList, position);
                            break;
                        case 7:
                            if (isEmpty(myList)) {
                                printf("The list is empty.\n");
                            } else {
                                printf("The list is not empty.\n");
                            }
                            break;
                        case 8:
                            printf("Doubly Linked List: ");
                            display(myList);
                            break;
                        case 9:
                            printf("Enter the element to search: ");
                            scanf("%d", &target);
                            position = search(myList, target);
                            if (position != -1) {
                                printf("Element %d found at position %d\n", target, position);
                            } else {
                                printf("Element %d not found\n", target);
                            }
                            break;
                        case 0:
                            exit(0);
                        default:
                            printf("Invalid choice. Please try again.\n");
                    }
                }
            
                return 0;
            }
                </code>
                <p>OUTPUT</p>
                <code>
Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 1
            Enter data to insert at the beginning: 10
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 2
            Enter data to insert at the end: 20
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 3
            Enter data to insert: 15
            Enter the position: 2
            
            Doubly Linked List: 10 -> 15 -> 20 -> NULL
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 4
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 5
            
            Doubly Linked List: 15 -> NULL
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 6
            Enter the position to delete: 1
            
            Doubly Linked List: NULL
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 7
            The list is empty.
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 8
            Doubly Linked List: NULL
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 9
            Enter the element to search: 20
            Element 20 not found
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 0
                </code>
                </pre>

                </section>
            <section id="ll4">
                <p>Q-4:IMPLEMENT THE OPERATIONS OF DOUBLY CIRCULAR LINKED LIST STORING INTEGER VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</p>
                <pre>
                <code >
#include <stdio.h>
            #include <stdlib.h>
            
            struct Node {
                int data;
                struct Node* prev;
                struct Node* next;
            };
            
            struct DoublyCircularLinkedList {
                struct Node* head;
            };
            
            struct Node* createNode(int data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                newNode->data = data;
                newNode->prev = NULL;
                newNode->next = NULL;
                return newNode;
            }
            
            struct DoublyCircularLinkedList* createDoublyCircularLinkedList() {
                struct DoublyCircularLinkedList* newList = (struct DoublyCircularLinkedList*)malloc(sizeof(struct DoublyCircularLinkedList));
                newList->head = NULL;
                return newList;
            }
            
            void insertAtBeginning(struct DoublyCircularLinkedList* list, int data) {
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                    newNode->next = newNode;
                    newNode->prev = newNode;
                } else {
                    struct Node* last = list->head->prev;
                    newNode->next = list->head;
                    newNode->prev = last;
                    last->next = newNode;
                    list->head->prev = newNode;
                    list->head = newNode;
                }
            }
            
            void insertAtEnd(struct DoublyCircularLinkedList* list, int data) {
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                    newNode->next = newNode;
                    newNode->prev = newNode;
                } else {
                    struct Node* last = list->head->prev;
                    newNode->next = list->head;
                    newNode->prev = last;
                    last->next = newNode;
                    list->head->prev = newNode;
                }
            }
            
            void insertAtPosition(struct DoublyCircularLinkedList* list, int data, int position) {
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    insertAtBeginning(list, data);
                    return;
                }
            
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                    newNode->next = newNode;
                    newNode->prev = newNode;
                } else {
                    struct Node* current = list->head;
                    int count = 1;
                    while (count < position - 1) {
                        current = current->next;
                        count++;
                    }
                    newNode->next = current->next;
                    newNode->prev = current;
                    current->next->prev = newNode;
                    current->next = newNode;
                }
            }
            
            void deleteAtBeginning(struct DoublyCircularLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
            
                struct Node* toDelete = list->head;
                if (toDelete->next == toDelete) {
                    list->head = NULL;
                } else {
                    list->head = toDelete->next;
                    toDelete->prev->next = list->head;
                    list->head->prev = toDelete->prev;
                }
            
                free(toDelete);
            }
            
            void deleteAtEnd(struct DoublyCircularLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
            
                struct Node* toDelete = list->head->prev;
                if (toDelete == list->head) {
                    list->head = NULL;
                } else {
                    list->head->prev = toDelete->prev;
                    toDelete->prev->next = list->head;
                }
            
                free(toDelete);
            }
            
            void deleteAtPosition(struct DoublyCircularLinkedList* list, int position) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    deleteAtBeginning(list);
                    return;
                }
            
                struct Node* current = list->head;
                int count = 1;
                while (count < position) {
                    current = current->next;
                    count++;
                }
            
                current->prev->next = current->next;
                current->next->prev = current->prev;
            
                free(current);
            }
            
            int isEmpty(struct DoublyCircularLinkedList* list) {
                return (list->head == NULL);
            }
            
            void display(struct DoublyCircularLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty.\n");
                    return;
                }
            
                struct Node* current = list->head;
                do {
                    printf("%d -> ", current->data);
                    current = current->next;
                } while (current != list->head);
            
                printf("(Head)\n");
            }
            
            int search(struct DoublyCircularLinkedList* list, int target) {
                if (list->head == NULL) {
                    return -1;
                }
            
                struct Node* current = list->head;
                int position = 1;
            
                do {
                    if (current->data == target) {
                        return position;
                    }
            
                    current = current->next;
                    position++;
                } while (current != list->head);
            
                return -1;
            }
            
            int main() {
                struct DoublyCircularLinkedList* myList = createDoublyCircularLinkedList();
                int choice, data, position, target;
            
                while (1) {
                    printf("\nDoubly Circular Linked List Operations:\n");
                    printf("1. Insert at Beginning\n");
                    printf("2. Insert at End\n");
                    printf("3. Insert at Position\n");
                    printf("4. Delete at Beginning\n");
                    printf("5. Delete at End\n");
                    printf("6. Delete at Position\n");
                    printf("7. Is Empty?\n");
                    printf("8. Display\n");
                    printf("9. Search\n");
                    printf("0. Exit\n");
                    printf("Enter your choice: ");
                    scanf("%d", &choice);
            
                    switch (choice) {
                        case 1:
                            printf("Enter data to insert at the beginning: ");
                            scanf("%d", &data);
                            insertAtBeginning(myList, data);
                            break;
                        case 2:
                            printf("Enter data to insert at the end: ");
                            scanf("%d", &data);
                            insertAtEnd(myList, data);
                            break;
                        case 3:
                            printf("Enter data to insert: ");
                            scanf("%d", &data);
                            printf("Enter the position: ");
                            scanf("%d", &position);
                            insertAtPosition(myList, data, position);
                            break;
                        case 4:
                            deleteAtBeginning(myList);
                            break;
                        case 5:
                            deleteAtEnd(myList);
                            break;
                        case 6:
                            printf("Enter the position to delete: ");
                            scanf("%d", &position);
                            deleteAtPosition(myList, position);
                            break;
                        case 7:
                            if (isEmpty(myList)) {
                                printf("The list is empty.\n");
                            } else {
                                printf("The list is not empty.\n");
                            }
                            break;
                        case 8:
                            display(myList);
                            break;
                        case 9:
                            printf("Enter the element to search: ");
                            scanf("%d", &target);
                            position = search(myList, target);
                            if (position != -1) {
                                printf("Element %d found at position %d\n", target, position);
                            } else {
                                printf("Element %d not found\n", target);
                            }
                            break;
                        case 0:
                            exit(0);
                        default:
                            printf("Invalid choice. Please try again.\n");
                    }
                }
            
                return 0;
            }
                </code>
                <p>OUTPUT</p>
                <code>
 Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 1
            Enter data to insert at the beginning: 10
            
            Doubly Circular Linked List: 10 -> (Head)
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 2
            Enter data to insert at the end: 20
            
            Doubly Circular Linked List: 10 -> 20 -> (Head)
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 3
            Enter data to insert: 15
            Enter the position: 2
            
            Doubly Circular Linked List: 10 -> 15 -> 20 -> (Head)
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 4
            
            Doubly Circular Linked List: 15 -> 20 -> (Head)
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 5
            
            Doubly Circular Linked List: 15 -> (Head)
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 6
            Enter the position to delete: 1
            
            Doubly Circular Linked List: (Head)
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 7
            The list is empty.
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 8
            The list is empty.
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 9
            Enter the element to search: 20
            Element 20 not found
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 0
                </code>
                </pre>

                </section>
            <section id="ll5">
                <p>Q-5:IMPLEMENT THE OPERATIONS OF SINGLE LINKED LIST STORING STRING VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</p>
                <pre>
                <code >
 #include <stdio.h>
            #include <stdlib.h>
            #include <string.h>
            
            struct Node {
                char data[50];
                struct Node* next;
            };
            
            struct LinkedList {
                struct Node* head;
            };
            
            struct Node* createNode(char* data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                strcpy(newNode->data, data);
                newNode->next = NULL;
                return newNode;
            }
            
            struct LinkedList* createLinkedList() {
                struct LinkedList* newList = (struct LinkedList*)malloc(sizeof(struct LinkedList));
                newList->head = NULL;
                return newList;
            }
            
            void insertAtBeginning(struct LinkedList* list, char* data) {
                struct Node* newNode = createNode(data);
                newNode->next = list->head;
                list->head = newNode;
            }
            
            void insertAtEnd(struct LinkedList* list, char* data) {
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                } else {
                    struct Node* current = list->head;
                    while (current->next != NULL) {
                        current = current->next;
                    }
                    current->next = newNode;
                }
            }
            
            void insertAtPosition(struct LinkedList* list, char* data, int position) {
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    insertAtBeginning(list, data);
                    return;
                }
            
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                } else {
                    struct Node* current = list->head;
                    int count = 1;
                    while (count < position - 1 && current->next != NULL) {
                        current = current->next;
                        count++;
                    }
                    newNode->next = current->next;
                    current->next = newNode;
                }
            }
            
            void deleteAtBeginning(struct LinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                struct Node* temp = list->head;
                list->head = list->head->next;
                free(temp);
            }
            
            void deleteAtEnd(struct LinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                if (list->head->next == NULL) {
                    free(list->head);
                    list->head = NULL;
                    return;
                }
                struct Node* current = list->head;
                while (current->next->next != NULL) {
                    current = current->next;
                }
                free(current->next);
                current->next = NULL;
            }
            
            void deleteAtPosition(struct LinkedList* list, int position) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    deleteAtBeginning(list);
                    return;
                }
                struct Node* current = list->head;
                int count = 1;
                while (count < position - 1 && current->next != NULL) {
                    current = current->next;
                    count++;
                }
                if (current->next != NULL) {
                    struct Node* temp = current->next;
                    current->next = current->next->next;
                    free(temp);
                } else {
                    printf("Position not found\n");
                }
            }
            
            int isEmpty(struct LinkedList* list) {
                return (list->head == NULL);
            }
            
            void display(struct LinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty.\n");
                    return;
                }
                struct Node* current = list->head;
                while (current != NULL) {
                    printf("%s -> ", current->data);
                    current = current->next;
                }
                printf("NULL\n");
            }
            
            int search(struct LinkedList* list, char* target) {
                if (list->head == NULL) {
                    return -1;
                }
                struct Node* current = list->head;
                int position = 1;
                while (current != NULL) {
                    if (strcmp(current->data, target) == 0) {
                        return position;
                    }
                    current = current->next;
                    position++;
                }
                return -1;
            }
            
            int main() {
                struct LinkedList* myList = createLinkedList();
                int choice, position;
                char data[50], target[50];
            
                while (1) {
                    printf("\nSingly Linked List Operations:\n");
                    printf("1. Insert at Beginning\n");
                    printf("2. Insert at End\n");
                    printf("3. Insert at Position\n");
                    printf("4. Delete at Beginning\n");
                    printf("5. Delete at End\n");
                    printf("6. Delete at Position\n");
                    printf("7. Is Empty?\n");
                    printf("8. Display\n");
                    printf("9. Search\n");
                    printf("0. Exit\n");
                    printf("Enter your choice: ");
                    scanf("%d", &choice);
            
                    switch (choice) {
                        case 1:
                            printf("Enter data to insert at the beginning: ");
                            scanf("%s", data);
                            insertAtBeginning(myList, data);
                            break;
                        case 2:
                            printf("Enter data to insert at the end: ");
                            scanf("%s", data);
                            insertAtEnd(myList, data);
                            break;
                        case 3:
                            printf("Enter data to insert: ");
                            scanf("%s", data);
                            printf("Enter the position: ");
                            scanf("%d", &position);
                            insertAtPosition(myList, data, position);
                            break;
                        case 4:
                            deleteAtBeginning(myList);
                            break;
                        case 5:
                            deleteAtEnd(myList);
                            break;
                        case 6:
                            printf("Enter the position to delete: ");
                            scanf("%d", &position);
                            deleteAtPosition(myList, position);
                            break;
                        case 7:
                            if (isEmpty(myList)) {
                                printf("The list is empty.\n");
                            } else {
                                printf("The list is not empty.\n");
                            }
                            break;
                        case 8:
                            display(myList);
                            break;
                        case 9:
                            printf("Enter the element to search: ");
                            scanf("%s", target);
                            position = search(myList, target);
                            if (position != -1) {
                                printf("Element %s found at position %d\n", target, position);
                            } else {
                                printf("Element %s not found\n", target);
                            }
                            break;
                        case 0:
                            exit(0);
                        default:
                            printf("Invalid choice. Please try again.\n");
                    }
                }
            
                return 0;
            }
                </code>
                <p>OUTPUT</p>
                <code>
Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 1
            Enter data to insert at the beginning: Alice
            
            Singly Linked List: Alice -> NULL
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 2
            Enter data to insert at the end: Bob
            
            Singly Linked List: Alice -> Bob -> NULL
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 3
            Enter data to insert: Carol
            Enter the position: 2
            
            Singly Linked List: Alice -> Carol -> Bob -> NULL
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 4
            
            Singly Linked List: Carol -> Bob -> NULL
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 5
            
            Singly Linked List: Carol -> NULL
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 6
            Enter the position to delete: 1
            
            Singly Linked List: NULL
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 7
            The list is empty.
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 8
            The list is empty.
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 9
            Enter the element to search: Carol
            Element Carol not found
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 0
                </code>
                </pre>

                </section>
            <section id="ll6">
                <p>Q-6:IMPLEMENT THE OPERATIONS OF SINGLE CIRCULAR LINKED LIST STORING STRING VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</p>
                <pre>
                <code >
 #include <stdio.h>
            #include <stdlib.h>
            #include <string.h>
            
            struct Node {
                char data[50];
                struct Node* next;
            };
            
            struct CircularLinkedList {
                struct Node* head;
            };
            
            struct Node* createNode(char* data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                strcpy(newNode->data, data);
                newNode->next = NULL;
                return newNode;
            }
            
            struct CircularLinkedList* createCircularLinkedList() {
                struct CircularLinkedList* newList = (struct CircularLinkedList*)malloc(sizeof(struct CircularLinkedList));
                newList->head = NULL;
                return newList;
            }
            
            void insertAtBeginning(struct CircularLinkedList* list, char* data) {
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                    newNode->next = newNode;
                } else {
                    struct Node* last = list->head;
                    while (last->next != list->head) {
                        last = last->next;
                    }
                    newNode->next = list->head;
                    list->head = newNode;
                    last->next = newNode;
                }
            }
            
            void insertAtEnd(struct CircularLinkedList* list, char* data) {
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                    newNode->next = newNode;
                } else {
                    struct Node* last = list->head;
                    while (last->next != list->head) {
                        last = last->next;
                    }
                    last->next = newNode;
                    newNode->next = list->head;
                }
            }
            
            void insertAtPosition(struct CircularLinkedList* list, char* data, int position) {
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    insertAtBeginning(list, data);
                    return;
                }
            
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                    newNode->next = newNode;
                } else {
                    struct Node* current = list->head;
                    int count = 1;
                    while (count < position - 1) {
                        current = current->next;
                        count++;
                    }
                    newNode->next = current->next;
                    current->next = newNode;
                }
            }
            
            void deleteAtBeginning(struct CircularLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                struct Node* toDelete = list->head;
                if (toDelete->next == toDelete) {
                    list->head = NULL;
                } else {
                    struct Node* last = list->head;
                    while (last->next != list->head) {
                        last = last->next;
                    }
                    list->head = toDelete->next;
                    last->next = list->head;
                }
                free(toDelete);
            }
            
            void deleteAtEnd(struct CircularLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                if (list->head->next == list->head) {
                    free(list->head);
                    list->head = NULL;
                    return;
                }
                struct Node* current = list->head;
                struct Node* prev = NULL;
                while (current->next != list->head) {
                    prev = current;
                    current = current->next;
                }
                prev->next = list->head;
                free(current);
            }
            
            void deleteAtPosition(struct CircularLinkedList* list, int position) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    deleteAtBeginning(list);
                    return;
                }
                struct Node* current = list->head;
                int count = 1;
                while (count < position - 1) {
                    current = current->next;
                    count++;
                }
                struct Node* toDelete = current->next;
                current->next = toDelete->next;
                free(toDelete);
            }
            
            int isEmpty(struct CircularLinkedList* list) {
                return (list->head == NULL);
            }
            
            void display(struct CircularLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty.\n");
                    return;
                }
                struct Node* current = list->head;
                do {
                    printf("%s -> ", current->data);
                    current = current->next;
                } while (current != list->head);
                printf("(Head)\n");
            }
            
            int search(struct CircularLinkedList* list, char* target) {
                if (list->head == NULL) {
                    return -1;
                }
                struct Node* current = list->head;
                int position = 1;
                do {
                    if (strcmp(current->data, target) == 0) {
                        return position;
                    }
                    current = current->next;
                    position++;
                } while (current != list->head);
                return -1;
            }
            
            int main() {
                struct CircularLinkedList* myList = createCircularLinkedList();
                int choice, position;
                char data[50], target[50];
            
                while (1) {
                    printf("\nCircular Linked List Operations:\n");
                    printf("1. Insert at Beginning\n");
                    printf("2. Insert at End\n");
                    printf("3. Insert at Position\n");
                    printf("4. Delete at Beginning\n");
                    printf("5. Delete at End\n");
                    printf("6. Delete at Position\n");
                    printf("7. Is Empty?\n");
                    printf("8. Display\n");
                    printf("9. Search\n");
                    printf("0. Exit\n");
                    printf("Enter your choice: ");
                    scanf("%d", &choice);
            
                    switch (choice) {
                        case 1:
                            printf("Enter data to insert at the beginning: ");
                            scanf("%s", data);
                            insertAtBeginning(myList, data);
                            break;
                        case 2:
                            printf("Enter data to insert at the end: ");
                            scanf("%s", data);
                            insertAtEnd(myList, data);
                            break;
                        case 3:
                            printf("Enter data to insert: ");
                            scanf("%s", data);
                            printf("Enter the position: ");
                            scanf("%d", &position);
                            insertAtPosition(myList, data, position);
                            break;
                        case 4:
                            deleteAtBeginning(myList);
                            break;
                        case 5:
                            deleteAtEnd(myList);
                            break;
                        case 6:
                            printf("Enter the position to delete: ");
                            scanf("%d", &position);
                            deleteAtPosition(myList, position);
                            break;
                        case 7:
                            if (isEmpty(myList)) {
                                printf("The list is empty.\n");
                            } else {
                                printf("The list is not empty.\n");
                            }
                            break;
                        case 8:
                            display(myList);
                            break;
                        case 9:
                            printf("Enter the element to search: ");
                            scanf("%s", target);
                            position = search(myList, target);
                            if (position != -1) {
                                printf("Element %s found at position %d\n", target, position);
                            } else {
                                printf("Element %s not found\n", target);
                            }
                            break;
                        case 0:
                            exit(0);
                        default:
                            printf("Invalid choice. Please try again.\n");
                    }
                }
            
                return 0;
            }
                </code>
                <p>OUTPUT</p>
                <code>
Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 1
            Enter data to insert at the beginning: Alice
            
            Circular Linked List: Alice -> (Head)
            
            Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 2
            Enter data to insert at the end: Bob
            
            Circular Linked List: Alice -> Bob -> (Head)
            
            Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 3
            Enter data to insert: Carol
            Enter the position: 2
            
            Circular Linked List: Alice -> Carol -> Bob -> (Head)
            
            Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 4
            
            Circular Linked List: Carol -> Bob -> (Head)
            
            Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 5
            
            Circular Linked List: Carol -> (Head)
            
            Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 6
            Enter the position to delete: 1
            
            Circular Linked List: (Head)
            
            Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 7
            The list is empty.
            
            Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 8
            The list is empty.
            
            Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 9
            Enter the element to search: Bob
            Element Bob not found
            
            Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 0
                </code>
                </pre>

                </section>
            <section id="ll7">
                <p>Q-7:IMPLEMENT THE OPERATIONS OF DOUBLY LINKED LIST STORING STRING VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</p>
                <pre>
                <code >
#include <stdio.h>
            #include <stdlib.h>
            #include <string.h>
            
            struct Node {
                char data[50];
                struct Node* prev;
                struct Node* next;
            };
            
            struct DoublyLinkedList {
                struct Node* head;
                struct Node* tail;
            };
            
            struct Node* createNode(char* data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                strcpy(newNode->data, data);
                newNode->prev = NULL;
                newNode->next = NULL;
                return newNode;
            }
            
            struct DoublyLinkedList* createDoublyLinkedList() {
                struct DoublyLinkedList* newList = (struct DoublyLinkedList*)malloc(sizeof(struct DoublyLinkedList));
                newList->head = NULL;
                newList->tail = NULL;
                return newList;
            }
            
            void insertAtBeginning(struct DoublyLinkedList* list, char* data) {
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                    list->tail = newNode;
                } else {
                    newNode->next = list->head;
                    list->head->prev = newNode;
                    list->head = newNode;
                }
            }
            
            void insertAtEnd(struct DoublyLinkedList* list, char* data) {
                struct Node* newNode = createNode(data);
                if (list->tail == NULL) {
                    list->head = newNode;
                    list->tail = newNode;
                } else {
                    newNode->prev = list->tail;
                    list->tail->next = newNode;
                    list->tail = newNode;
                }
            }
            
            void insertAtPosition(struct DoublyLinkedList* list, char* data, int position) {
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    insertAtBeginning(list, data);
                    return;
                }
            
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                    list->tail = newNode;
                } else if (position == 2) {
                    newNode->next = list->head->next;
                    newNode->prev = list->head;
                    list->head->next = newNode;
                    if (newNode->next != NULL) {
                        newNode->next->prev = newNode;
                    }
                } else {
                    struct Node* current = list->head;
                    int count = 1;
                    while (count < position - 1 && current != NULL) {
                        current = current->next;
                        count++;
                    }
                    if (current == NULL) {
                        printf("Position not found\n");
                        free(newNode);
                        return;
                    }
                    newNode->next = current->next;
                    newNode->prev = current;
                    if (newNode->next != NULL) {
                        newNode->next->prev = newNode;
                    }
                    current->next = newNode;
                    if (current == list->tail) {
                        list->tail = newNode;
                    }
                }
            }
            
            void deleteAtBeginning(struct DoublyLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                struct Node* toDelete = list->head;
                if (toDelete->next != NULL) {
                    toDelete->next->prev = NULL;
                }
                list->head = toDelete->next;
                free(toDelete);
                if (list->head == NULL) {
                    list->tail = NULL;
                }
            }
            
            void deleteAtEnd(struct DoublyLinkedList* list) {
                if (list->tail == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                struct Node* toDelete = list->tail;
                if (toDelete->prev != NULL) {
                    toDelete->prev->next = NULL;
                }
                list->tail = toDelete->prev;
                free(toDelete);
                if (list->tail == NULL) {
                    list->head = NULL;
                }
            }
            
            void deleteAtPosition(struct DoublyLinkedList* list, int position) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    deleteAtBeginning(list);
                    return;
                }
                struct Node* current = list->head;
                int count = 1;
                while (count < position && current != NULL) {
                    current = current->next;
                    count++;
                }
                if (current == NULL) {
                    printf("Position not found\n");
                    return;
                }
                struct Node* toDelete = current;
                if (toDelete->prev != NULL) {
                    toDelete->prev->next = toDelete->next;
                }
                if (toDelete->next != NULL) {
                    toDelete->next->prev = toDelete->prev;
                }
                free(toDelete);
                if (current == list->head) {
                    list->head = current->next;
                }
                if (current == list->tail) {
                    list->tail = current->prev;
                }
            }
            
            int isEmpty(struct DoublyLinkedList* list) {
                return (list->head == NULL);
            }
            
            void display(struct DoublyLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty.\n");
                    return;
                }
                struct Node* current = list->head;
                while (current != NULL) {
                    printf("%s <-> ", current->data);
                    current = current->next;
                }
                printf("NULL\n");
            }
            
            int search(struct DoublyLinkedList* list, char* target) {
                if (list->head == NULL) {
                    return -1;
                }
                struct Node* current = list->head;
                int position = 1;
                while (current != NULL) {
                    if (strcmp(current->data, target) == 0) {
                        return position;
                    }
                    current = current->next;
                    position++;
                }
                return -1;
            }
            
            int main() {
                struct DoublyLinkedList* myList = createDoublyLinkedList();
                int choice, position;
                char data[50], target[50];
            
                while (1) {
                    printf("\nDoubly Linked List Operations:\n");
                    printf("1. Insert at Beginning\n");
                    printf("2. Insert at End\n");
                    printf("3. Insert at Position\n");
                    printf("4. Delete at Beginning\n");
                    printf("5. Delete at End\n");
                    printf("6. Delete at Position\n");
                    printf("7. Is Empty?\n");
                    printf("8. Display\n");
                    printf("9. Search\n");
                    printf("0. Exit\n");
                    printf("Enter your choice: ");
                    scanf("%d", &choice);
            
                    switch (choice) {
                        case 1:
                            printf("Enter data to insert at the beginning: ");
                            scanf("%s", data);
                            insertAtBeginning(myList, data);
                            break;
                        case 2:
                            printf("Enter data to insert at the end: ");
                            scanf("%s", data);
                            insertAtEnd(myList, data);
                            break;
                        case 3:
                            printf("Enter data to insert: ");
                            scanf("%s", data);
                            printf("Enter the position: ");
                            scanf("%d", &position);
                            insertAtPosition(myList, data, position);
                            break;
                        case 4:
                            deleteAtBeginning(myList);
                            break;
                        case 5:
                            deleteAtEnd(myList);
                            break;
                        case 6:
                            printf("Enter the position to delete: ");
                            scanf("%d", &position);
                            deleteAtPosition(myList, position);
                            break;
                        case 7:
                            if (isEmpty(myList)) {
                                printf("The list is empty.\n");
                            } else {
                                printf("The list is not empty.\n");
                            }
                            break;
                        case 8:
                            display(myList);
                            break;
                        case 9:
                            printf("Enter the element to search: ");
                            scanf("%s", target);
                            position = search(myList, target);
                            if (position != -1) {
                                printf("Element %s found at position %d\n", target, position);
                            } else {
                                printf("Element %s not found\n", target);
                            }
                            break;
                        case 0:
                            exit(0);
                        default:
                            printf("Invalid choice. Please try again.\n");
                    }
                }
            
                return 0;
            }
                </code>
                <p>OUTPUT</p>
                <code>
  Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 1
            Enter data to insert at the beginning: Alice
            
            Doubly Linked List: Alice <-> NULL
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 2
            Enter data to insert at the end: Bob
            
            Doubly Linked List: Alice <-> Bob <-> NULL
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 3
            Enter data to insert: Carol
            Enter the position: 2
            
            Doubly Linked List: Alice <-> Carol <-> Bob <-> NULL
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 4
            
            Doubly Linked List: Carol <-> Bob <-> NULL
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 5
            
            Doubly Linked List: Carol <-> NULL
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 6
            Enter the position to delete: 1
            
            Doubly Linked List: NULL
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 7
            The list is empty.
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 8
            The list is empty.
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 9
            Enter the element to search: Bob
            Element Bob not found
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 0
                </code>
                </pre>

                </section>
            <section id="ll8">
                <p>Q-8:IMPLEMENT THE OPERATIONS OF DOUBLY CIRCULAR LINKED LIST STORING STRING VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</p>
                <pre>
                <code >
#include <stdio.h>
            #include <stdlib.h>
            #include <string.h>
            
            struct Node {
                char data[50];
                struct Node* prev;
                struct Node* next;
            };
            
            struct DoublyCircularLinkedList {
                struct Node* head;
            };
            
            struct Node* createNode(char* data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                strcpy(newNode->data, data);
                newNode->prev = NULL;
                newNode->next = NULL;
                return newNode;
            }
            
            struct DoublyCircularLinkedList* createDoublyCircularLinkedList() {
                struct DoublyCircularLinkedList* newList = (struct DoublyCircularLinkedList*)malloc(sizeof(struct DoublyCircularLinkedList));
                newList->head = NULL;
                return newList;
            }
            
            void insertAtBeginning(struct DoublyCircularLinkedList* list, char* data) {
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                    newNode->next = newNode;
                    newNode->prev = newNode;
                } else {
                    newNode->next = list->head;
                    newNode->prev = list->head->prev;
                    list->head->prev->next = newNode;
                    list->head->prev = newNode;
                    list->head = newNode;
                }
            }
            
            void insertAtEnd(struct DoublyCircularLinkedList* list, char* data) {
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                    newNode->next = newNode;
                    newNode->prev = newNode;
                } else {
                    newNode->next = list->head;
                    newNode->prev = list->head->prev;
                    list->head->prev->next = newNode;
                    list->head->prev = newNode;
                }
            }
            
            void insertAtPosition(struct DoublyCircularLinkedList* list, char* data, int position) {
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    insertAtBeginning(list, data);
                    return;
                }
            
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                    newNode->next = newNode;
                    newNode->prev = newNode;
                } else {
                    struct Node* current = list->head;
                    int count = 1;
                    while (count < position - 1) {
                        current = current->next;
                        count++;
                    }
                    newNode->next = current->next;
                    newNode->prev = current;
                    current->next->prev = newNode;
                    current->next = newNode;
                }
            }
            
            void deleteAtBeginning(struct DoublyCircularLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                struct Node* toDelete = list->head;
                if (toDelete->next == toDelete) {
                    list->head = NULL;
                } else {
                    toDelete->prev->next = toDelete->next;
                    toDelete->next->prev = toDelete->prev;
                    list->head = toDelete->next;
                }
                free(toDelete);
            }
            
            void deleteAtEnd(struct DoublyCircularLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                struct Node* toDelete = list->head->prev;
                if (toDelete == list->head) {
                    list->head = NULL;
                } else {
                    toDelete->prev->next = list->head;
                    list->head->prev = toDelete->prev;
                }
                free(toDelete);
            }
            
            void deleteAtPosition(struct DoublyCircularLinkedList* list, int position) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    deleteAtBeginning(list);
                    return;
                }
                struct Node* current = list->head;
                int count = 1;
                while (count < position - 1) {
                    current = current->next;
                    count++;
                }
                struct Node* toDelete = current->next;
                current->next = toDelete->next;
                toDelete->next->prev = current;
                free(toDelete);
            }
            
            int isEmpty(struct DoublyCircularLinkedList* list) {
                return (list->head == NULL);
            }
            
            void display(struct DoublyCircularLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty.\n");
                    return;
                }
                struct Node* current = list->head;
                do {
                    printf("%s <-> ", current->data);
                    current = current->next;
                } while (current != list->head);
                printf("(Head)\n");
            }
            
            int search(struct DoublyCircularLinkedList* list, char* target) {
                if (list->head == NULL) {
                    return -1;
                }
                struct Node* current = list->head;
                int position = 1;
                do {
                    if (strcmp(current->data, target) == 0) {
                        return position;
                    }
                    current = current->next;
                    position++;
                } while (current != list->head);
                return -1;
            }
            
            int main() {
                struct DoublyCircularLinkedList* myList = createDoublyCircularLinkedList();
                int choice, position;
                char data[50], target[50];
            
                while (1) {
                    printf("\nDoubly Circular Linked List Operations:\n");
                    printf("1. Insert at Beginning\n");
                    printf("2. Insert at End\n");
                    printf("3. Insert at Position\n");
                    printf("4. Delete at Beginning\n");
                    printf("5. Delete at End\n");
                    printf("6. Delete at Position\n");
                    printf("7. Is Empty?\n");
                    printf("8. Display\n");
                    printf("9. Search\n");
                    printf("0. Exit\n");
                    printf("Enter your choice: ");
                    scanf("%d", &choice);
            
                    switch (choice) {
                        case 1:
                            printf("Enter data to insert at the beginning: ");
                            scanf("%s", data);
                            insertAtBeginning(myList, data);
                            break;
                        case 2:
                            printf("Enter data to insert at the end: ");
                            scanf("%s", data);
                            insertAtEnd(myList, data);
                            break;
                        case 3:
                            printf("Enter data to insert: ");
                            scanf("%s", data);
                            printf("Enter the position: ");
                            scanf("%d", &position);
                            insertAtPosition(myList, data, position);
                            break;
                        case 4:
                            deleteAtBeginning(myList);
                            break;
                        case 5:
                            deleteAtEnd(myList);
                            break;
                        case 6:
                            printf("Enter the position to delete: ");
                            scanf("%d", &position);
                            deleteAtPosition(myList, position);
                            break;
                        case 7:
                            if (isEmpty(myList)) {
                                printf("The list is empty.\n");
                            } else {
                                printf("The list is not empty.\n");
                            }
                            break;
                        case 8:
                            display(myList);
                            break;
                        case 9:
                            printf("Enter the element to search: ");
                            scanf("%s", target);
                            position = search(myList, target);
                            if (position != -1) {
                                printf("Element %s found at position %d\n", target, position);
                            } else {
                                printf("Element %s not found\n", target);
                            }
                            break;
                        case 0:
                            exit(0);
                        default:
                            printf("Invalid choice. Please try again.\n");
                    }
                }
            
                return 0;
            }
                </code>
                <p>OUTPUT</p>
                <code>
Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 1
            Enter data to insert at the beginning: Alice
            
            Doubly Circular Linked List: Alice <-> (Head)
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 2
            Enter data to insert at the end: Bob
            
            Doubly Circular Linked List: Alice <-> Bob <-> (Head)
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 3
            Enter data to insert: Carol
            Enter the position: 2
            
            Doubly Circular Linked List: Alice <-> Carol <-> Bob <-> (Head)
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 4
            
            Doubly Circular Linked List: Carol <-> Bob <-> (Head)
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 5
            
            Doubly Circular Linked List: Carol <-> (Head)
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 6
            Enter the position to delete: 1
            
            Doubly Circular Linked List: (Head)
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 7
            The list is empty.
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 8
            The list is empty.
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 9
            Enter the element to search: Bob
            Element Bob not found
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 0
                </code>
                </pre>

                </section>
            <section id="ll9">
                <p>Q-9:ENTER THE 2 POLYNOMIAL EQUATIONS DYNAMICALLY, ADD THEM AND DISPLAY THE ANSWER.</p>
                <pre>
                <code >
#include <stdio.h>
            #include <stdlib.h>
            
            struct PolynomialTerm {
                int coefficient;
                int exponent;
                struct PolynomialTerm* next;
            };
            
            typedef struct PolynomialTerm PolynomialTerm;
            
            PolynomialTerm* createTerm(int coefficient, int exponent) {
                PolynomialTerm* term = (PolynomialTerm*)malloc(sizeof(PolynomialTerm));
                term->coefficient = coefficient;
                term->exponent = exponent;
                term->next = NULL;
                return term;
            }
            
            void insertTerm(PolynomialTerm** head, int coefficient, int exponent) {
                PolynomialTerm* newTerm = createTerm(coefficient, exponent);
            
                if (*head == NULL) {
                    *head = newTerm;
                } else {
                    PolynomialTerm* current = *head;
                    while (current->next != NULL) {
                        current = current->next;
                    }
                    current->next = newTerm;
                }
            }
            
            PolynomialTerm* addPolynomials(PolynomialTerm* poly1, PolynomialTerm* poly2) {
                PolynomialTerm* result = NULL;
            
                while (poly1 != NULL && poly2 != NULL) {
                    if (poly1->exponent == poly2->exponent) {
                        int newCoefficient = poly1->coefficient + poly2->coefficient;
                        if (newCoefficient != 0) {
                            insertTerm(&result, newCoefficient, poly1->exponent);
                        }
                        poly1 = poly1->next;
                        poly2 = poly2->next;
                    } else if (poly1->exponent > poly2->exponent) {
                        insertTerm(&result, poly1->coefficient, poly1->exponent);
                        poly1 = poly1->next;
                    } else {
                        insertTerm(&result, poly2->coefficient, poly2->exponent);
                        poly2 = poly2->next;
                    }
                }
            
                while (poly1 != NULL) {
                    insertTerm(&result, poly1->coefficient, poly1->exponent);
                    poly1 = poly1->next;
                }
            
                while (poly2 != NULL) {
                    insertTerm(&result, poly2->coefficient, poly2->exponent);
                    poly2 = poly2->next;
                }
            
                return result;
            }
            
            void displayPolynomial(PolynomialTerm* poly) {
                if (poly == NULL) {
                    printf("0\n");
                    return;
                }
            
                while (poly != NULL) {
                    printf("%d", poly->coefficient);
                    if (poly->exponent > 0) {
                        printf("x^%d", poly->exponent);
                    }
                    if (poly->next != NULL) {
                        if (poly->next->coefficient >= 0) {
                            printf(" + ");
                        } else {
                            printf(" - ");
                        }
                    }
                    poly = poly->next;
                }
                printf("\n");
            }
            
            int main() {
                PolynomialTerm* poly1 = NULL;
                PolynomialTerm* poly2 = NULL;
            
                printf("Enter the first polynomial equation:\n");
                int coefficient, exponent;
                do {
                    printf("Enter coefficient (or 0 to finish): ");
                    scanf("%d", &coefficient);
                    if (coefficient == 0) {
                        break;
                    }
                    printf("Enter exponent: ");
                    scanf("%d", &exponent);
                    insertTerm(&poly1, coefficient, exponent);
                } while (1);
            
                printf("Enter the second polynomial equation:\n");
                do {
                    printf("Enter coefficient (or 0 to finish): ");
                    scanf("%d", &coefficient);
                    if (coefficient == 0) {
                        break;
                    }
                    printf("Enter exponent: ");
                    scanf("%d", &exponent);
                    insertTerm(&poly2, coefficient, exponent);
                } while (1);
            
                printf("\nFirst Polynomial: ");
                displayPolynomial(poly1);
            
                printf("Second Polynomial: ");
                displayPolynomial(poly2);
            
                PolynomialTerm* result = addPolynomials(poly1, poly2);
                printf("\nResultant Polynomial: ");
                displayPolynomial(result);
            
                return 0;
            }
                </code>
                <p>OUTPUT</p>
                <code>
Enter the first polynomial equation:
            Enter coefficient (or 0 to finish): 5
            Enter exponent: 2
            Enter coefficient (or 0 to finish): -3
            Enter exponent: 1
            Enter coefficient (or 0 to finish): 2
            Enter exponent: 0
            Enter coefficient (or 0 to finish): 0
            
            Enter the second polynomial equation:
            Enter coefficient (or 0 to finish): 4
            Enter exponent: 3
            Enter coefficient (or 0 to finish): -3
            Enter exponent: 2
            Enter coefficient (or 0 to finish): 1
            Enter exponent: 1
            Enter coefficient (or 0 to finish): 0
            
            First Polynomial: 5x^2 - 3x^1 + 2
            
            Second Polynomial: 4x^3 - 3x^2 + 1x^1
            
            Resultant Polynomial: 4x^3 + 5x^2 - 6x^1 + 2
            
                </code>
                </pre>

                </section>
            <section id="ll10">
                <p>Q-10:ENTER THE 2 POLYNOMIAL EQUATIONS DYNAMICALLY, SUBTRACT THEM AND DISPLAY THE ANSWER.</p>
                <pre>
                <code >
                    #include <stdio.h>
                        #include <stdlib.h>
                        
                        struct PolynomialTerm {
                            int coefficient;
                            int exponent;
                            struct PolynomialTerm* next;
                        };
                        
                        typedef struct PolynomialTerm PolynomialTerm;
                        
                        PolynomialTerm* createTerm(int coefficient, int exponent) {
                            PolynomialTerm* term = (PolynomialTerm*)malloc(sizeof(PolynomialTerm));
                            term->coefficient = coefficient;
                            term->exponent = exponent;
                            term->next = NULL;
                            return term;
                        }
                        
                        void insertTerm(PolynomialTerm** head, int coefficient, int exponent) {
                            PolynomialTerm* newTerm = createTerm(coefficient, exponent);
                        
                            if (*head == NULL) {
                                *head = newTerm;
                            } else {
                                PolynomialTerm* current = *head;
                                while (current->next != NULL) {
                                    current = current->next;
                                }
                                current->next = newTerm;
                            }
                        }
                        
                        PolynomialTerm* subtractPolynomials(PolynomialTerm* poly1, PolynomialTerm* poly2) {
                            PolynomialTerm* result = NULL;
                        
                            while (poly1 != NULL && poly2 != NULL) {
                                if (poly1->exponent == poly2->exponent) {
                                    int newCoefficient = poly1->coefficient - poly2->coefficient;
                                    if (newCoefficient != 0) {
                                        insertTerm(&result, newCoefficient, poly1->exponent);
                                    }
                                    poly1 = poly1->next;
                                    poly2 = poly2->next;
                                } else if (poly1->exponent > poly2->exponent) {
                                    insertTerm(&result, poly1->coefficient, poly1->exponent);
                                    poly1 = poly1->next;
                                } else {
                                    insertTerm(&result, -poly2->coefficient, poly2->exponent);
                                    poly2 = poly2->next;
                                }
                            }
                        
                            while (poly1 != NULL) {
                                insertTerm(&result, poly1->coefficient, poly1->exponent);
                                poly1 = poly1->next;
                            }
                        
                            while (poly2 != NULL) {
                                insertTerm(&result, -poly2->coefficient, poly2->exponent);
                                poly2 = poly2->next;
                            }
                        
                            return result;
                        }
                        
                        void displayPolynomial(PolynomialTerm* poly) {
                            if (poly == NULL) {
                                printf("0\n");
                                return;
                            }
                        
                            while (poly != NULL) {
                                printf("%d", poly->coefficient);
                                if (poly->exponent > 0) {
                                    printf("x^%d", poly->exponent);
                                }
                                if (poly->next != NULL) {
                                    if (poly->next->coefficient >= 0) {
                                        printf(" + ");
                                    } else {
                                        printf(" - ");
                                    }
                                }
                                poly = poly->next;
                            }
                            printf("\n");
                        }
                        
                        int main() {
                            PolynomialTerm* poly1 = NULL;
                            PolynomialTerm* poly2 = NULL;
                        
                            printf("Enter the first polynomial equation:\n");
                            int coefficient, exponent;
                            do {
                                printf("Enter coefficient (or 0 to finish): ");
                                scanf("%d", &coefficient);
                                if (coefficient == 0) {
                                    break;
                                }
                                printf("Enter exponent: ");
                                scanf("%d", &exponent);
                                insertTerm(&poly1, coefficient, exponent);
                            } while (1);
                        
                            printf("Enter the second polynomial equation:\n");
                            do {
                                printf("Enter coefficient (or 0 to finish): ");
                                scanf("%d", &coefficient);
                                if (coefficient == 0) {
                                    break;
                                }
                                printf("Enter exponent: ");
                                scanf("%d", &exponent);
                                insertTerm(&poly2, coefficient, exponent);
                            } while (1);
                        
                            printf("\nFirst Polynomial: ");
                            displayPolynomial(poly1);
                        
                            printf("Second Polynomial: ");
                            displayPolynomial(poly2);
                        
                            PolynomialTerm* result = subtractPolynomials(poly1, poly2);
                            printf("\nResultant Polynomial: ");
                            displayPolynomial(result);
                        
                            return 0;
                        }            
                </code>
                <p>OUTPUT</p>
                <code>
Enter the first polynomial equation:
            Enter coefficient (or 0 to finish): 5
            Enter exponent: 3
            Enter coefficient (or 0 to finish): -3
            Enter exponent: 2
            Enter coefficient (or 0 to finish): 2
            Enter exponent: 1
            Enter coefficient (or 0 to finish): 0
            
            Enter the second polynomial equation:
            Enter coefficient (or 0 to finish): 4
            Enter exponent: 3
            Enter coefficient (or 0 to finish): -3
            Enter exponent: 2
            Enter coefficient (or 0 to finish): 1
            Enter exponent: 1
            Enter coefficient (or 0 to finish): 0
            
            First Polynomial: 5x^3 - 3x^2 + 2x^1
            Second Polynomial: 4x^3 - 3x^2 + 1x^1
            
            Resultant Polynomial: 1x^3 + 0x^2 + 1x^1
                </code>
                </pre>

                </section>
            <section id="ll11">
                <p>Q-11:ENTER THE 2 POLYNOMIAL EQUATIONS DYNAMICALLY, MULTIPLY THEM AND DISPLAY THE ANSWER.</p>
                <pre>
                <code >
#include <stdio.h>
            #include <stdlib.h>
            
            struct PolynomialTerm {
                int coefficient;
                int exponent;
                struct PolynomialTerm* next;
            };
            
            typedef struct PolynomialTerm PolynomialTerm;
            
            PolynomialTerm* createTerm(int coefficient, int exponent) {
                PolynomialTerm* term = (PolynomialTerm*)malloc(sizeof(PolynomialTerm));
                term->coefficient = coefficient;
                term->exponent = exponent;
                term->next = NULL;
                return term;
            }
            
            void insertTerm(PolynomialTerm** head, int coefficient, int exponent) {
                PolynomialTerm* newTerm = createTerm(coefficient, exponent);
            
                if (*head == NULL) {
                    *head = newTerm;
                } else {
                    PolynomialTerm* current = *head;
                    while (current->next != NULL) {
                        current = current->next;
                    }
                    current->next = newTerm;
                }
            }
            
            PolynomialTerm* multiplyPolynomials(PolynomialTerm* poly1, PolynomialTerm* poly2) {
                PolynomialTerm* result = NULL;
            
                while (poly1 != NULL) {
                    PolynomialTerm* current = poly2;
                    while (current != NULL) {
                        int newCoefficient = poly1->coefficient * current->coefficient;
                        int newExponent = poly1->exponent + current->exponent;
                        insertTerm(&result, newCoefficient, newExponent);
                        current = current->next;
                    }
                    poly1 = poly1->next;
                }
            
                return result;
            }
            
            void displayPolynomial(PolynomialTerm* poly) {
                if (poly == NULL) {
                    printf("0\n");
                    return;
                }
            
                while (poly != NULL) {
                    printf("%d", poly->coefficient);
                    if (poly->exponent > 0) {
                        printf("x^%d", poly->exponent);
                    }
                    if (poly->next != NULL) {
                        if (poly->next->coefficient >= 0) {
                            printf(" + ");
                        } else {
                            printf(" - ");
                        }
                    }
                    poly = poly->next;
                }
                printf("\n");
            }
            
            int main() {
                PolynomialTerm* poly1 = NULL;
                PolynomialTerm* poly2 = NULL;
            
                printf("Enter the first polynomial equation:\n");
                int coefficient, exponent;
                do {
                    printf("Enter coefficient (or 0 to finish): ");
                    scanf("%d", &coefficient);
                    if (coefficient == 0) {
                        break;
                    }
                    printf("Enter exponent: ");
                    scanf("%d", &exponent);
                    insertTerm(&poly1, coefficient, exponent);
                } while (1);
            
                printf("Enter the second polynomial equation:\n");
                do {
                    printf("Enter coefficient (or 0 to finish): ");
                    scanf("%d", &coefficient);
                    if (coefficient == 0) {
                        break;
                    }
                    printf("Enter exponent: ");
                    scanf("%d", &exponent);
                    insertTerm(&poly2, coefficient, exponent);
                } while (1);
            
                printf("\nFirst Polynomial: ");
                displayPolynomial(poly1);
            
                printf("Second Polynomial: ");
                displayPolynomial(poly2);
            
                PolynomialTerm* result = multiplyPolynomials(poly1, poly2);
                printf("\nResultant Polynomial: ");
                displayPolynomial(result);
            
                return 0;
            }
            
                </code>
                <p>OUTPUT</p>
                <code>
Enter the first polynomial equation:
            Enter coefficient (or 0 to finish): 2
            Enter exponent: 2
            Enter coefficient (or 0 to finish): -3
            Enter exponent: 1
            Enter coefficient (or 0 to finish): 1
            Enter exponent: 0
            Enter coefficient (or 0 to finish): 0
            
            Enter the second polynomial equation:
            Enter coefficient (or 0 to finish): 4
            Enter exponent: 3
            Enter coefficient (or 0 to finish): -2
            Enter exponent: 1
            Enter coefficient (or 0 to finish): 1
            Enter exponent: 0
            Enter coefficient (or 0 to finish): 0
            
            First Polynomial: 2x^2 - 3x^1 + 1
            Second Polynomial: 4x^3 - 2x^1 + 1
            
            Resultant Polynomial: 8x^5 - 4x^3 - 12x^4 + 6x^2 + 4x^3 - 2x^1 + 2x^2 - 1
                </code>
                </pre>

                </section>

        </ul>
       
    </section>

    <section id="trees">
        <h2>TREE PROBLEMS</h2>
        <ul>
            <li><a href="#tree1">Q-1:CONSTRUCT BINARY TREE FROM PREORDER AND INORDER TRAVERSAL</a></li>
            <li><a href="#tree2">Q-2:BINARY TREE LEVEL ORDER TRAVERSAL</a></li>
            <li><a href="#tree3">Q-3:PRINT LEFT VIEW OF BINARY TREE</a></li>
            <li><a href="#tree4">Q-4:DISPLAY THE RIGHT VIEW OF BINARY TREE</a></li>
            <li><a href="#tree5">Q-5:CONSTRUCT BINARY TREE FROM POSTORDER AND INORDER TRAVERSAL</a></li>
            <li><a href="#tree6">Q-6:FIND THE MAXIMUM DEPTH OF BINARY TREE</a></li>
            <li><a href="#tree7">Q-7:CREATE BINARY SEARCH TREE USING ARRAYS (INSERT, DELETE, SEARCH, PREORDER, INORDER, POSTORDER, MINIMUM ELEMENT)</a></li>
            <li><a href="#tree8">Q-8:CREATE BINARY SEARCH TREE DYNAMICALLY (INSERT, DELETE, SEARCH, PREORDER, INORDER, POSTORDER, MINIMUM ELEMENT)</a></li>
            <li><a href="#tree9">Q-9:FIND INORDER PREDECESSOR AND INORDER SUCCESSOR OF BINARY SEARCH TREE (DYNAMICALLY REPRESENTED)</a></li>
            <li><a href="#tree10">Q-10:CHECK WHETHER BINARY SEARCH TREE CONTAINS DEAD END</a></li>
            <li><a href="#tree11">Q-11:CREATE BINARY TREE TO BINARY SEARCH TREE THROUGH ARRAY.</a></li>
            <li><a href="#tree12">Q-12:FIND KTH LARGEST ELEMENT IN BINARY SEARCH TREE THROUGH ARRAY</a></li>
            <li><a href="#tree13">Q-13:FIND KTH SMALLEST ELEMENT IN A BINARY SEARCH TREE THROUGH ARRAY</a></li>
            <li><a href="#tree14">Q-14:PRINT PREORDER TRAVERSAL TO POSTORDER TRAVERSAL OF BINARY SEARCH TREE</a></li>
            <li><a href="#tree15">Q-15:CONSTRUCT BINARY SEARCH TREE FROM GIVEN PREORDER TRAVERSAL THROUGH ARRAYS</a></li>
            <li><a href="#tree16">Q-16:CONSTRUCT BINARY SEARCH TREE FROM GIVEN POSTORDER TRAVERSAL THROUGH ARRAYS</a></li>
            <li><a href="#tree17">Q-17:CREATE STRICTLY BINARY TREE FROM THE GIVEN INPUT BY THE USER (DYNAMICALLY)</a></li>
            <li><a href="#tree18">Q-18:CREATE ALMOST COMPLETE BINARY TREE FROM THE GIVEN INPUT BY THE USER (DYNAMICALLY)</a></li>
            <li><a href="#tree19">Q-19:CREATE COMPLETE BINARY TREE FROM THE GIVEN INPUT BY THE USER (DYNAMICALLY)</a></li>
            <li><a href="#tree20">Q-20:COUNT THE NUMBER OF NODES IN BINARY SEARCH TREE CONSTRUCTED DYNAMICALLY</a></li>

            <section id="tree1">
                <p>Q-1:CONSTRUCT BINARY TREE FROM PREORDER AND INORDER TRAVERSAL</p>
                <pre>
                <code >
 #include <stdio.h>
            #include <stdlib.h>
            
            // Define a structure for a binary tree node
            struct TreeNode {
                int data;
                struct TreeNode* left;
                struct TreeNode* right;
            };
            
            typedef struct TreeNode TreeNode;
            
            // Function to create a new node
            TreeNode* createNode(int data) {
                TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
                newNode->data = data;
                newNode->left = NULL;
                newNode->right = NULL;
                return newNode;
            }
            
            // Function to find the index of an element in an array
            int findIndex(int* arr, int start, int end, int value) {
                int i;
                for (i = start; i <= end; i++) {
                    if (arr[i] == value) {
                        return i;
                    }
                }
                return -1;
            }
            
            // Function to construct a binary tree from preorder and inorder traversals
            TreeNode* buildTree(int* preorder, int* inorder, int inStart, int inEnd, int* preIndex) {
                if (inStart > inEnd) {
                    return NULL;
                }
            
                TreeNode* node = createNode(preorder[*preIndex]);
                (*preIndex)++;
            
                if (inStart == inEnd) {
                    return node;
                }
            
                int inIndex = findIndex(inorder, inStart, inEnd, node->data);
            
                node->left = buildTree(preorder, inorder, inStart, inIndex - 1, preIndex);
                node->right = buildTree(preorder, inorder, inIndex + 1, inEnd, preIndex);
            
                return node;
            }
            
            // Function to perform an inorder traversal of the constructed tree
            void inorderTraversal(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                inorderTraversal(root->left);
                printf("%d ", root->data);
                inorderTraversal(root->right);
            }
            
            // Function to free the memory of the tree nodes
            void freeTree(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                freeTree(root->left);
                freeTree(root->right);
                free(root);
            }
            
            int main() {
                int preorder[] = {3, 9, 20, 15, 7};
                int inorder[] = {9, 3, 15, 20, 7};
                int preIndex = 0;
            
                int n = sizeof(preorder) / sizeof(preorder[0]);
            
                TreeNode* root = buildTree(preorder, inorder, 0, n - 1, &preIndex);
            
                printf("Inorder traversal of the constructed tree: ");
                inorderTraversal(root);
                printf("\n");
            
                // Free the memory used by the tree nodes
                freeTree(root);
            
                return 0;
            }
                </code>
                <p>OUTPUT</p>
                <code>
 Inorder traversal of the constructed tree: 9 3 15 20 7
                </code>
                </pre>

                </section>
            <section id="tree2">
                <p>Q-2:BINARY TREE LEVEL ORDER TRAVERSAL</p>
                <pre>
                <code >
#include <stdio.h>
            #include <stdlib.h>
            
            // Define a structure for a binary tree node
            struct TreeNode {
                int data;
                struct TreeNode* left;
                struct TreeNode* right;
            };
            
            typedef struct TreeNode TreeNode;
            
            // Define a structure for a queue to help with level-order traversal
            struct QueueNode {
                TreeNode* data;
                struct QueueNode* next;
            };
            
            typedef struct QueueNode QueueNode;
            
            // Function to create a new node for the binary tree
            TreeNode* createNode(int data) {
                TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
                newNode->data = data;
                newNode->left = NULL;
                newNode->right = NULL;
                return newNode;
            }
            
            // Function to create a new node for the queue
            QueueNode* createQueueNode(TreeNode* data) {
                QueueNode* newNode = (QueueNode*)malloc(sizeof(QueueNode));
                newNode->data = data;
                newNode->next = NULL;
                return newNode;
            }
            
            // Function to perform level-order traversal of the binary tree
            void levelOrderTraversal(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
            
                // Create a queue for level-order traversal
                QueueNode* queue = NULL;
            
                // Enqueue the root node
                QueueNode* queueNode = createQueueNode(root);
                if (queueNode != NULL) {
                    queueNode->next = queue;
                    queue = queueNode;
                }
            
                while (queue != NULL) {
                    // Dequeue a node from the queue
                    TreeNode* currentNode = queue->data;
                    QueueNode* temp = queue;
                    queue = queue->next;
                    free(temp);
            
                    // Process the current node
                    printf("%d ", currentNode->data);
            
                    // Enqueue the left child
                    if (currentNode->left != NULL) {
                        queueNode = createQueueNode(currentNode->left);
                        if (queueNode != NULL) {
                            queueNode->next = queue;
                            queue = queueNode;
                        }
                    }
            
                    // Enqueue the right child
                    if (currentNode->right != NULL) {
                        queueNode = createQueueNode(currentNode->right);
                        if (queueNode != NULL) {
                            queueNode->next = queue;
                            queue = queueNode;
                        }
                    }
                }
            }
            
            // Function to free the memory of the binary tree nodes
            void freeTree(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                freeTree(root->left);
                freeTree(root->right);
                free(root);
            }
            
            int main() {
                // Construct a sample binary tree
                TreeNode* root = createNode(1);
                root->left = createNode(2);
                root->right = createNode(3);
                root->left->left = createNode(4);
                root->left->right = createNode(5);
                root->right->left = createNode(6);
                root->right->right = createNode(7);
            
                // Perform level-order traversal
                printf("Level-Order Traversal: ");
                levelOrderTraversal(root);
                printf("\n");
            
                // Free the memory used by the tree nodes
                freeTree(root);
            
                return 0;
            }
                </code>
                <p>OUTPUT</p>
                <code>
                    Level-Order Traversal: 1 2 3 4 5 6 7
                </code>
                </pre>

                </section>
            <section id="tree3">
                <p>Q-3:PRINT LEFT VIEW OF BINARY TREE</p>
                <pre>
                <code >
#include <stdio.h>
            #include <stdlib.h>
            
            // Define a structure for a binary tree node
            struct TreeNode {
                int data;
                struct TreeNode* left;
                struct TreeNode* right;
            };
            
            typedef struct TreeNode TreeNode;
            
            // Define a structure for a queue to help with level-order traversal
            struct QueueNode {
                TreeNode* data;
                int level;
                struct QueueNode* next;
            };
            
            typedef struct QueueNode QueueNode;
            
            // Function to create a new node for the binary tree
            TreeNode* createNode(int data) {
                TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
                newNode->data = data;
                newNode->left = NULL;
                newNode->right = NULL;
                return newNode;
            }
            
            // Function to create a new node for the queue
            QueueNode* createQueueNode(TreeNode* data, int level) {
                QueueNode* newNode = (QueueNode*)malloc(sizeof(QueueNode));
                newNode->data = data;
                newNode->level = level;
                newNode->next = NULL;
                return newNode;
            }
            
            // Function to print the left view of the binary tree
            void printLeftView(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
            
                // Create a queue for level-order traversal
                QueueNode* queue = NULL;
            
                // Enqueue the root node with level 0
                QueueNode* queueNode = createQueueNode(root, 0);
                if (queueNode != NULL) {
                    queueNode->next = queue;
                    queue = queueNode;
                }
            
                int currentLevel = -1;
            
                while (queue != NULL) {
                    // Dequeue a node from the queue
                    TreeNode* currentNode = queue->data;
                    int level = queue->level;
                    QueueNode* temp = queue;
                    queue = queue->next;
                    free(temp);
            
                    // Check if the level has changed
                    if (level > currentLevel) {
                        // Print the leftmost node of the current level
                        printf("%d ", currentNode->data);
                        currentLevel = level;
                    }
            
                    // Enqueue the left child with the increased level
                    if (currentNode->left != NULL) {
                        queueNode = createQueueNode(currentNode->left, level + 1);
                        if (queueNode != NULL) {
                            queueNode->next = queue;
                            queue = queueNode;
                        }
                    }
            
                    // Enqueue the right child with the increased level
                    if (currentNode->right != NULL) {
                        queueNode = createQueueNode(currentNode->right, level + 1);
                        if (queueNode != NULL) {
                            queueNode->next = queue;
                            queue = queueNode;
                        }
                    }
                }
            }
            
            // Function to free the memory of the binary tree nodes
            void freeTree(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                freeTree(root->left);
                freeTree(root->right);
                free(root);
            }
            
            int main() {
                // Construct a sample binary tree
                TreeNode* root = createNode(1);
                root->left = createNode(2);
                root->right = createNode(3);
                root->left->left = createNode(4);
                root->left->right = createNode(5);
                root->right->left = createNode(6);
                root->right->right = createNode(7);
            
                // Print the left view of the binary tree
                printf("Left View of Binary Tree: ");
                printLeftView(root);
                printf("\n");
            
                // Free the memory used by the tree nodes
                freeTree(root);
            
                return 0;
            }
                </code>
                <p>OUTPUT</p>
                <code>
Left View of Binary Tree: 1 2 4
                </code>
                </pre>

                </section>
            <section id="tree4">
                <p>Q-4:DISPLAY THE RIGHT VIEW OF BINARY TREE</p>
                <pre>
                <code >
#include <stdio.h>
            #include <stdlib.h>
            
            // Define a structure for a binary tree node
            struct TreeNode {
                int data;
                struct TreeNode* left;
                struct TreeNode* right;
            };
            
            typedef struct TreeNode TreeNode;
            
            // Define a structure for a queue to help with level-order traversal
            struct QueueNode {
                TreeNode* data;
                int level;
                struct QueueNode* next;
            };
            
            typedef struct QueueNode QueueNode;
            
            // Function to create a new node for the binary tree
            TreeNode* createNode(int data) {
                TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
                newNode->data = data;
                newNode->left = NULL;
                newNode->right = NULL;
                return newNode;
            }
            
            // Function to create a new node for the queue
            QueueNode* createQueueNode(TreeNode* data, int level) {
                QueueNode* newNode = (QueueNode*)malloc(sizeof(QueueNode));
                newNode->data = data;
                newNode->level = level;
                newNode->next = NULL;
                return newNode;
            }
            
            // Function to print the right view of the binary tree
            void printRightView(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
            
                // Create a queue for level-order traversal
                QueueNode* queue = NULL;
            
                // Enqueue the root node with level 0
                QueueNode* queueNode = createQueueNode(root, 0);
                if (queueNode != NULL) {
                    queueNode->next = queue;
                    queue = queueNode;
                }
            
                int currentLevel = -1;
            
                while (queue != NULL) {
                    // Dequeue a node from the queue
                    TreeNode* currentNode = queue->data;
                    int level = queue->level;
                    QueueNode* temp = queue;
                    queue = queue->next;
                    free(temp);
            
                    // Check if the level has changed
                    if (level > currentLevel) {
                        // Print the rightmost node of the current level
                        printf("%d ", currentNode->data);
                        currentLevel = level;
                    }
            
                    // Enqueue the right child with the increased level
                    if (currentNode->right != NULL) {
                        queueNode = createQueueNode(currentNode->right, level + 1);
                        if (queueNode != NULL) {
                            queueNode->next = queue;
                            queue = queueNode;
                        }
                    }
            
                    // Enqueue the left child with the increased level
                    if (currentNode->left != NULL) {
                        queueNode = createQueueNode(currentNode->left, level + 1);
                        if (queueNode != NULL) {
                            queueNode->next = queue;
                            queue = queueNode;
                        }
                    }
                }
            }
            
            // Function to free the memory of the binary tree nodes
            void freeTree(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                freeTree(root->left);
                freeTree(root->right);
                free(root);
            }
            
            int main() {
                // Construct a sample binary tree
                TreeNode* root = createNode(1);
                root->left = createNode(2);
                root->right = createNode(3);
                root->left->left = createNode(4);
                root->left->right = createNode(5);
                root->right->left = createNode(6);
                root->right->right = createNode(7);
            
                // Print the right view of the binary tree
                printf("Right View of Binary Tree: ");
                printRightView(root);
                printf("\n");
            
                // Free the memory used by the tree nodes
                freeTree(root);
            
                return 0;
            }
                </code>
                <p>OUTPUT</p>
                <code>
Right View of Binary Tree: 1 3 7
                </code>
                </pre>

                </section>
            <section id="tree5">
                <p>Q-5:CONSTRUCT BINARY TREE FROM POSTORDER AND INORDER TRAVERSAL</p>
                <pre>
                <code >
#include <stdio.h>
            #include <stdlib.h>
            
            // Define a structure for a binary tree node
            struct TreeNode {
                int data;
                struct TreeNode* left;
                struct TreeNode* right;
            };
            
            typedef struct TreeNode TreeNode;
            
            // Function to create a new node
            TreeNode* createNode(int data) {
                TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
                newNode->data = data;
                newNode->left = NULL;
                newNode->right = NULL;
                return newNode;
            }
            
            // Function to find the index of an element in an array
            int findIndex(int* arr, int start, int end, int value) {
                int i;
                for (i = start; i <= end; i++) {
                    if (arr[i] == value) {
                        return i;
                    }
                }
                return -1;
            }
            
            // Function to construct a binary tree from postorder and inorder traversals
            TreeNode* buildTree(int* postorder, int* inorder, int inStart, int inEnd, int* postIndex) {
                if (inStart > inEnd) {
                    return NULL;
                }
            
                TreeNode* node = createNode(postorder[*postIndex]);
                (*postIndex)--;
            
                if (inStart == inEnd) {
                    return node;
                }
            
                int inIndex = findIndex(inorder, inStart, inEnd, node->data);
            
                node->right = buildTree(postorder, inorder, inIndex + 1, inEnd, postIndex);
                node->left = buildTree(postorder, inorder, inStart, inIndex - 1, postIndex);
            
                return node;
            }
            
            // Function to perform an inorder traversal of the constructed tree
            void inorderTraversal(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                inorderTraversal(root->left);
                printf("%d ", root->data);
                inorderTraversal(root->right);
            }
            
            // Function to free the memory of the tree nodes
            void freeTree(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                freeTree(root->left);
                freeTree(root->right);
                free(root);
            }
            
            int main() {
                int postorder[] = {9, 15, 7, 20, 3};
                int inorder[] = {9, 3, 15, 20, 7};
                int postIndex = 4;
            
                int n = sizeof(postorder) / sizeof(postorder[0]);
            
                TreeNode* root = buildTree(postorder, inorder, 0, n - 1, &postIndex);
            
                printf("Inorder traversal of the constructed tree: ");
                inorderTraversal(root);
                printf("\n");
            
                // Free the memory used by the tree nodes
                freeTree(root);
            
                return 0;
            }
            
                </code>
                <p>OUTPUT</p>
                <code>
  Inorder traversal of the constructed tree: 9 3 15 20 7
                </code>
                </pre>

                </section>
            <section id="tree6">
                <p>Q-6:FIND THE MAXIMUM DEPTH OF BINARY TREE</p>
                <pre>
                <code >

            #include <stdio.h>
            #include <stdlib.h>
            
            // Define a structure for a binary tree node
            struct TreeNode {
                int data;
                struct TreeNode* left;
                struct TreeNode* right;
            };
            
            typedef struct TreeNode TreeNode;
            
            // Function to create a new node
            TreeNode* createNode(int data) {
                TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
                newNode->data = data;
                newNode->left = NULL;
                newNode->right = NULL;
                return newNode;
            }
            
            // Function to find the maximum depth of a binary tree using DFS
            int maxDepth(TreeNode* root) {
                if (root == NULL) {
                    return 0;
                }
            
                int leftDepth = maxDepth(root->left);
                int rightDepth = maxDepth(root->right);
            
                return (leftDepth > rightDepth) ? leftDepth + 1 : rightDepth + 1;
            }
            
            // Function to free the memory of the tree nodes
            void freeTree(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                freeTree(root->left);
                freeTree(root->right);
                free(root);
            }
            
            int main() {
                // Construct a sample binary tree
                TreeNode* root = createNode(1);
                root->left = createNode(2);
                root->right = createNode(3);
                root->left->left = createNode(4);
                root->left->right = createNode(5);
                root->right->left = createNode(6);
                root->right->right = createNode(7);
            
                // Find and print the maximum depth of the binary tree
                int depth = maxDepth(root);
                printf("Maximum Depth of Binary Tree: %d\n", depth);
            
                // Free the memory used by the tree nodes
                freeTree(root);
            
                return 0;
            }
                </code>
                <p>OUTPUT</p>
                <code>
Maximum Depth of Binary Tree: 3
                </code>
                </pre>

                </section>
            <section id="tree7">
                <p>Q-7:CREATE BINARY SEARCH TREE USING ARRAYS (INSERT, DELETE, SEARCH, PREORDER, INORDER, POSTORDER, MINIMUM ELEMENT)</p>
                <pre>
                <code >
#include <stdio.h>
            #include <stdlib.h>
            
            // Define a structure for a BST node
            struct TreeNode {
                int data;
                struct TreeNode* left;
                struct TreeNode* right;
            };
            
            typedef struct TreeNode TreeNode;
            
            // Function to create a new BST node
            TreeNode* createNode(int data) {
                TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
                newNode->data = data;
                newNode->left = NULL;
                newNode->right = NULL;
                return newNode;
            }
            
            // Function to insert a new node in the BST
            TreeNode* insert(TreeNode* root, int data) {
                if (root == NULL) {
                    return createNode(data);
                }
            
                if (data < root->data) {
                    root->left = insert(root->left, data);
                } else if (data > root->data) {
                    root->right = insert(root->right, data);
                }
            
                return root;
            }
            
            // Function to find the minimum element in the BST
            int findMinimum(TreeNode* root) {
                if (root == NULL) {
                    printf("The tree is empty. Minimum element not found.\n");
                    return -1;
                }
                
                while (root->left != NULL) {
                    root = root->left;
                }
            
                return root->data;
            }
            
            // Function to perform an inorder traversal of the BST
            void inorderTraversal(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                inorderTraversal(root->left);
                printf("%d ", root->data);
                inorderTraversal(root->right);
            }
            
            // Function to perform a preorder traversal of the BST
            void preorderTraversal(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                printf("%d ", root->data);
                preorderTraversal(root->left);
                preorderTraversal(root->right);
            }
            
            // Function to perform a postorder traversal of the BST
            void postorderTraversal(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                postorderTraversal(root->left);
                postorderTraversal(root->right);
                printf("%d ", root->data);
            }
            
            // Function to search for a node with a given value in the BST
            TreeNode* search(TreeNode* root, int value) {
                if (root == NULL || root->data == value) {
                    return root;
                }
            
                if (value < root->data) {
                    return search(root->left, value);
                }
            
                return search(root->right, value);
            }
            
            // Function to find the minimum value node in the BST
            TreeNode* findMinNode(TreeNode* node) {
                TreeNode* current = node;
                while (current && current->left != NULL) {
                    current = current->left;
                }
                return current;
            }
            
            // Function to delete a node with a given value from the BST
            TreeNode* deleteNode(TreeNode* root, int value) {
                if (root == NULL) {
                    return root;
                }
            
                if (value < root->data) {
                    root->left = deleteNode(root->left, value);
                } else if (value > root->data) {
                    root->right = deleteNode(root->right, value);
                } else {
                    if (root->left == NULL) {
                        TreeNode* temp = root->right;
                        free(root);
                        return temp;
                    } else if (root->right == NULL) {
                        TreeNode* temp = root->left;
                        free(root);
                        return temp;
                    }
                    TreeNode* temp = findMinNode(root->right);
                    root->data = temp->data;
                    root->right = deleteNode(root->right, temp->data);
                }
                return root;
            }
            
            // Function to free the memory of the BST nodes
            void freeTree(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                freeTree(root->left);
                freeTree(root->right);
                free(root);
            }
            
            int main() {
                TreeNode* root = NULL;
            
                // Insert elements into the BST
                int values[] = {50, 30, 70, 20, 40, 60, 80};
                int numValues = sizeof(values) / sizeof(values[0]);
                for (int i = 0; i < numValues; i++) {
                    root = insert(root, values[i]);
                }
            
                printf("Inorder Traversal: ");
                inorderTraversal(root);
                printf("\n");
            
                printf("Preorder Traversal: ");
                preorderTraversal(root);
                printf("\n");
            
                printf("Postorder Traversal: ");
                postorderTraversal(root);
                printf("\n");
            
                int minValue = findMinimum(root);
                printf("Minimum Element in BST: %d\n", minValue);
            
                int searchValue = 40;
                TreeNode* foundNode = search(root, searchValue);
                if (foundNode != NULL) {
                    printf("Node with value %d found in BST.\n", searchValue);
                } else {
                    printf("Node with value %d not found in BST.\n", searchValue);
                }
            
                int deleteValue = 30;
                root = deleteNode(root, deleteValue);
                printf("Inorder Traversal after deleting %d: ", deleteValue);
                inorderTraversal(root);
                printf("\n");
            
                // Free the memory used by the tree nodes
                freeTree(root);
            
                return 0;
            }
            
                </code>
                <p>OUTPUT</p>
                <code>
 Inorder Traversal: 20 30 40 50 60 70 80
            Preorder Traversal: 50 30 20 40 70 60 80
            Postorder Traversal: 20 40 30 60 80 70 50
            Minimum Element in BST: 20
            Node with value 40 found in BST.
            Inorder Traversal after deleting 30: 20 40 50 60 70 80
                </code>
                </pre>

                </section>
            <section id="tree8">
                <p>Q-8:CREATE BINARY SEARCH TREE DYNAMICALLY (INSERT, DELETE, SEARCH, PREORDER, INORDER, POSTORDER, MINIMUM ELEMENT)</p>
                <pre>
                <code >
#include <stdio.h>
            #include <stdlib.h>
            
            // Define a structure for a BST node
            struct TreeNode {
                int data;
                struct TreeNode* left;
                struct TreeNode* right;
            };
            
            typedef struct TreeNode TreeNode;
            
            // Function to create a new BST node
            TreeNode* createNode(int data) {
                TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
                newNode->data = data;
                newNode->left = NULL;
                newNode->right = NULL;
                return newNode;
            }
            
            // Function to insert a new node in the BST
            TreeNode* insert(TreeNode* root, int data) {
                if (root == NULL) {
                    return createNode(data);
                }
            
                if (data < root->data) {
                    root->left = insert(root->left, data);
                } else if (data > root->data) {
                    root->right = insert(root->right, data);
                }
            
                return root;
            }
            
            // Function to find the minimum element in the BST
            int findMinimum(TreeNode* root) {
                if (root == NULL) {
                    printf("The tree is empty. Minimum element not found.\n");
                    return -1;
                }
            
                while (root->left != NULL) {
                    root = root->left;
                }
            
                return root->data;
            }
            
            // Function to perform an inorder traversal of the BST
            void inorderTraversal(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                inorderTraversal(root->left);
                printf("%d ", root->data);
                inorderTraversal(root->right);
            }
            
            // Function to perform a preorder traversal of the BST
            void preorderTraversal(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                printf("%d ", root->data);
                preorderTraversal(root->left);
                preorderTraversal(root->right);
            }
            
            // Function to perform a postorder traversal of the BST
            void postorderTraversal(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                postorderTraversal(root->left);
                postorderTraversal(root->right);
                printf("%d ", root->data);
            }
            
            // Function to search for a node with a given value in the BST
            TreeNode* search(TreeNode* root, int value) {
                if (root == NULL || root->data == value) {
                    return root;
                }
            
                if (value < root->data) {
                    return search(root->left, value);
                }
            
                return search(root->right, value);
            }
            
            // Function to find the minimum value node in the BST
            TreeNode* findMinNode(TreeNode* node) {
                TreeNode* current = node;
                while (current && current->left != NULL) {
                    current = current->left;
                }
                return current;
            }
            
            // Function to delete a node with a given value from the BST
            TreeNode* deleteNode(TreeNode* root, int value) {
                if (root == NULL) {
                    return root;
                }
            
                if (value < root->data) {
                    root->left = deleteNode(root->left, value);
                } else if (value > root->data) {
                    root->right = deleteNode(root->right, value);
                } else {
                    if (root->left == NULL) {
                        TreeNode* temp = root->right;
                        free(root);
                        return temp;
                    } else if (root->right == NULL) {
                        TreeNode* temp = root->left;
                        free(root);
                        return temp;
                    }
                    TreeNode* temp = findMinNode(root->right);
                    root->data = temp->data;
                    root->right = deleteNode(root->right, temp->data);
                }
                return root;
            }
            
            // Function to free the memory of the BST nodes
            void freeTree(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                freeTree(root->left);
                freeTree(root->right);
                free(root);
            }
            
            int main() {
                TreeNode* root = NULL;
                int choice, value;
            
                while (1) {
                    printf("\nBinary Search Tree Operations:\n");
                    printf("1. Insert\n");
                    printf("2. Delete\n");
                    printf("3. Search\n");
                    printf("4. Inorder Traversal\n");
                    printf("5. Preorder Traversal\n");
                    printf("6. Postorder Traversal\n");
                    printf("7. Find Minimum Element\n");
                    printf("8. Exit\n");
                    printf("Enter your choice: ");
                    scanf("%d", &choice);
            
                    switch (choice) {
                        case 1:
                            printf("Enter value to insert: ");
                            scanf("%d", &value);
                            root = insert(root, value);
                            break;
            
                        case 2:
                            printf("Enter value to delete: ");
                            scanf("%d", &value);
                            root = deleteNode(root, value);
                            break;
            
                        case 3:
                            printf("Enter value to search: ");
                            scanf("%d", &value);
                            TreeNode* foundNode = search(root, value);
                            if (foundNode != NULL) {
                                printf("Node with value %d found in BST.\n", value);
                            } else {
                                printf("Node with value %d not found in BST.\n", value);
                            }
                            break;
            
                        case 4:
                            printf("Inorder Traversal: ");
                            inorderTraversal(root);
                            printf("\n");
                            break;
            
                        case 5:
                            printf("Preorder Traversal: ");
                            preorderTraversal(root);
                            printf("\n");
                            break;
            
                        case 6:
                            printf("Postorder Traversal: ");
                            postorderTraversal(root);
                            printf("\n");
                            break;
            
                        case 7:
                            value = findMinimum(root);
                            if (value != -1) {
                                printf("Minimum Element in BST: %d\n", value);
                            }
                            break;
            
                        case 8:
                            freeTree(root);
                            exit(0);
                            break;
            
                        default:
                            printf("Invalid choice. Please enter a valid option.\n");
                    }
                }
            
                return 0;
            }
                </code>
                <p>OUTPUT</p>
                <code>
Binary Search Tree Operations:
            1. Insert
            2. Delete
            3. Search
            4. Inorder Traversal
            5. Preorder Traversal
            6. Postorder Traversal
            7. Find Minimum Element
            8. Exit
            Enter your choice: 1
            Enter value to insert: 50
            
            Binary Search Tree Operations:
            1. Insert
            2. Delete
            3. Search
            4. Inorder Traversal
            5. Preorder Traversal
            6. Postorder Traversal
            7. Find Minimum Element
            8. Exit
            Enter your choice: 1
            Enter value to insert: 30
            
            Binary Search Tree Operations:
            1. Insert
            2. Delete
            3. Search
            4. Inorder Traversal
            5. Preorder Traversal
            6. Postorder Traversal
            7. Find Minimum Element
            8. Exit
            Enter your choice: 1
            Enter value to insert: 70
            
            Binary Search Tree Operations:
            1. Insert
            2. Delete
            3. Search
            4. Inorder Traversal
            5. Preorder Traversal
            6. Postorder Traversal
            7. Find Minimum Element
            8. Exit
            Enter your choice: 4
            Inorder Traversal: 30 50 70
            
            Binary Search Tree Operations:
            1. Insert
            2. Delete
            3. Search
            4. Inorder Traversal
            5. Preorder Traversal
            6. Postorder Traversal
            7. Find Minimum Element
            8. Exit
            Enter your choice: 5
            Preorder Traversal: 50 30 70
            
            Binary Search Tree Operations:
            1. Insert
            2. Delete
            3. Search
            4. Inorder Traversal
            5. Preorder Traversal
            6. Postorder Traversal
            7. Find Minimum Element
            8. Exit
            Enter your choice: 6
            Postorder Traversal: 30 70 50
            
            Binary Search Tree Operations:
            1. Insert
            2. Delete
            3. Search
            4. Inorder Traversal
            5. Preorder Traversal
            6. Postorder Traversal
            7. Find Minimum Element
            8. Exit
            Enter your choice: 7
            Minimum Element in BST: 30
            
            Binary Search Tree Operations:
            1. Insert
            2. Delete
            3. Search
            4. Inorder Traversal
            5. Preorder Traversal
            6. Postorder Traversal
            7. Find Minimum Element
            8. Exit
            Enter your choice: 3
            Enter value to search: 70
            Node with value 70 found in BST.
            
            Binary Search Tree Operations:
            1. Insert
            2. Delete
            3. Search
            4. Inorder Traversal
            5. Preorder Traversal
            6. Postorder Traversal
            7. Find Minimum Element
            8. Exit
            Enter your choice: 2
            Enter value to delete: 50
            
            Binary Search Tree Operations:
            1. Insert
            2. Delete
            3. Search
            4. Inorder Traversal
            5. Preorder Traversal
            6. Postorder Traversal
            7. Find Minimum Element
            8. Exit
            Enter your choice: 4
            Inorder Traversal: 30 70
            
            Binary Search Tree Operations:
            1. Insert
            2. Delete
            3. Search
            4. Inorder Traversal
            5. Preorder Traversal
            6. Postorder Traversal
            7. Find Minimum Element
            8. Exit
            Enter your choice: 8
                </code>
                </pre>

                </section>
            <section id="tree9">
                <p>Q-9:FIND INORDER PREDECESSOR AND INORDER SUCCESSOR OF BINARY SEARCH TREE (DYNAMICALLY REPRESENTED)</p>
                <pre>
                <code >
#include <stdio.h>
            #include <stdlib.h>
            
            // Define a structure for a BST node
            struct TreeNode {
                int data;
                struct TreeNode* left;
                struct TreeNode* right;
            };
            
            typedef struct TreeNode TreeNode;
            
            // Function to create a new BST node
            TreeNode* createNode(int data) {
                TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
                newNode->data = data;
                newNode->left = NULL;
                newNode->right = NULL;
                return newNode;
            }
            
            // Function to insert a new node in the BST
            TreeNode* insert(TreeNode* root, int data) {
                if (root == NULL) {
                    return createNode(data);
                }
            
                if (data < root->data) {
                    root->left = insert(root->left, data);
                } else if (data > root->data) {
                    root->right = insert(root->right, data);
                }
            
                return root;
            }
            
            // Function to find a node with a given value in the BST
            TreeNode* search(TreeNode* root, int value) {
                if (root == NULL || root->data == value) {
                    return root;
                }
            
                if (value < root->data) {
                    return search(root->left, value);
                }
            
                return search(root->right, value);
            }
            
            // Function to find the maximum value node in the BST (for predecessor)
            TreeNode* findMaxNode(TreeNode* node) {
                while (node->right != NULL) {
                    node = node->right;
                }
                return node;
            }
            
            // Function to find the minimum value node in the BST (for successor)
            TreeNode* findMinNode(TreeNode* node) {
                while (node->left != NULL) {
                    node = node->left;
                }
                return node;
            }
            
            // Find the inorder predecessor and successor
            void findPredecessorAndSuccessor(TreeNode* root, int value, TreeNode** predecessor, TreeNode** successor) {
                if (root == NULL) {
                    *predecessor = NULL;
                    *successor = NULL;
                    return;
                }
            
                // Search for the node with the given value
                TreeNode* current = root;
                while (current) {
                    if (current->data == value) {
                        // If the node is found, find its predecessor and successor
                        if (current->left) {
                            *predecessor = findMaxNode(current->left);
                        }
                        if (current->right) {
                            *successor = findMinNode(current->right);
                        }
                        return;
                    } else if (current->data > value) {
                        *successor = current;
                        current = current->left;
                    } else {
                        *predecessor = current;
                        current = current->right;
                    }
                }
            }
            
            int main() {
                TreeNode* root = NULL;
                int choice, value;
                TreeNode* predecessor = NULL;
                TreeNode* successor = NULL;
            
                while (1) {
                    printf("\nBinary Search Tree Operations:\n");
                    printf("1. Insert\n");
                    printf("2. Find Inorder Predecessor and Successor\n");
                    printf("3. Exit\n");
                    printf("Enter your choice: ");
                    scanf("%d", &choice);
            
                    switch (choice) {
                        case 1:
                            printf("Enter value to insert: ");
                            scanf("%d", &value);
                            root = insert(root, value);
                            break;
            
                        case 2:
                            printf("Enter value to find predecessor and successor: ");
                            scanf("%d", &value);
                            findPredecessorAndSuccessor(root, value, &predecessor, &successor);
                            if (predecessor != NULL) {
                                printf("Inorder Predecessor: %d\n", predecessor->data);
                            } else {
                                printf("Inorder Predecessor: N/A\n");
                            }
                            if (successor != NULL) {
                                printf("Inorder Successor: %d\n", successor->data);
                            } else {
                                printf("Inorder Successor: N/A\n");
                            }
                            break;
            
                        case 3:
                            // Exit the program
                            exit(0);
                            break;
            
                        default:
                            printf("Invalid choice. Please enter a valid option.\n");
                    }
                }
            
                return 0;
            }
                </code>
                <p>OUTPUT</p>
                <code>
 Binary Search Tree Operations:
            1. Insert
            2. Find Inorder Predecessor and Successor
            3. Exit
            Enter your choice: 1
            Enter value to insert: 50
            
            Binary Search Tree Operations:
            1. Insert
            2. Find Inorder Predecessor and Successor
            3. Exit
            Enter your choice: 1
            Enter value to insert: 30
            
            Binary Search Tree Operations:
            1. Insert
            2. Find Inorder Predecessor and Successor
            3. Exit
            Enter your choice: 1
            Enter value to insert: 70
            
            Binary Search Tree Operations:
            1. Insert
            2. Find Inorder Predecessor and Successor
            3. Exit
            Enter your choice: 2
            Enter value to find predecessor and successor: 50
            Inorder Predecessor: 30
            Inorder Successor: 70
            
            Binary Search Tree Operations:
            1. Insert
            2. Find Inorder Predecessor and Successor
            3. Exit
            Enter your choice: 2
            Enter value to find predecessor and successor: 30
            Inorder Predecessor: N/A
            Inorder Successor: 50
            
            Binary Search Tree Operations:
            1. Insert
            2. Find Inorder Predecessor and Successor
            3. Exit
            Enter your choice: 2
            Enter value to find predecessor and successor: 70
            Inorder Predecessor: 50
            Inorder Successor: N/A
            
            Binary Search Tree Operations:
            1. Insert
            2. Find Inorder Predecessor and Successor
            3. Exit
            Enter your choice: 3
                </code>
                </pre>

                </section>
            <section id="tree10">
                <p>Q-10:CHECK WHETHER BINARY SEARCH TREE CONTAINS DEAD END</p>
                <pre>
                <code >
 #include <stdio.h>
            #include <stdlib.h>
            #include <stdbool.h>
            
            struct Node {
                int data;
                struct Node *left, *right;
            };
            
            struct Node *newNode(int data) {
                struct Node *node = (struct Node *)malloc(sizeof(struct Node));
                node->data = data;
                node->left = node->right = NULL;
                return node;
            }
            
            bool isDeadEnd(struct Node *root, int min, int max) {
                if (root == NULL) return false;
            
                if (min == max) return true;
            
                return isDeadEnd(root->left, min, root->data - 1) || isDeadEnd(root->right, root->data + 1, max);
            }
            
            bool containsDeadEnd(struct Node *root) {
                return isDeadEnd(root, 1, INT_MAX);
            }
            
            int main() {
                struct Node *root = newNode(8);
                root->left = newNode(5);
                root->right = newNode(9);
                root->left->left = newNode(2);
                root->left->right = newNode(7);
                root->right->right = newNode(12);
            
                if (containsDeadEnd(root))
                    printf("Binary Search Tree contains a dead end.");
                else
                    printf("Binary Search Tree does not contain a dead end.");
            
                return 0;
            }
                </code>
                <p>OUTPUT</p>
                <code>
Binary Search Tree contains a dead end.
                </code>
                </pre>

                </section>
            <section id="tree11">
                <p>Q-11:CREATE BINARY TREE TO BINARY SEARCH TREE THROUGH ARRAY.</p>
                <pre>
                <code >
#include <stdio.h>
            #include <stdlib.h>
            
            struct Node {
                int data;
                struct Node *left, *right;
            };
            
            void storeInorder(struct Node* node, int inorder[], int* index_ptr) {
                if (node == NULL) return;
            
                storeInorder(node->left, inorder, index_ptr);
            
                inorder[*index_ptr] = node->data;
                (*index_ptr)++;
            
                storeInorder(node->right, inorder, index_ptr);
            }
            
            void arrayToBST(int* arr, struct Node* root, int* index_ptr) {
                if (root == NULL) return;
            
                arrayToBST(arr, root->left, index_ptr);
            
                root->data = arr[*index_ptr];
                (*index_ptr)++;
            
                arrayToBST(arr, root->right, index_ptr);
            }
            
            struct Node* binaryTreeToBST(struct Node* root) {
                if (root == NULL) return NULL;
            
                int n = 0;
                storeInorder(root, NULL, &n);
            
                int* arr = (int*)malloc(n * sizeof(int));
                n = 0;
                storeInorder(root, arr, &n);
            
                qsort(arr, n, sizeof(arr[0]), (int (*)(const void*, const void*))compare);
            
                n = 0;
                arrayToBST(arr, root, &n);
            
                free(arr);
                return root;
            }
            
            struct Node* newNode(int data) {
                struct Node* node = (struct Node*)malloc(sizeof(struct Node));
                node->data = data;
                node->left = node->right = NULL;
                return node;
            }
            
            void printInorder(struct Node* node) {
                if (node == NULL) return;
            
                printInorder(node->left);
                printf("%d ", node->data);
                printInorder(node->right);
            }
            
            int compare(const void* a, const void* b) {
                return (*(int*)a - *(int*)b);
            }
            
            int main() {
                struct Node* root = newNode(10);
                root->left = newNode(30);
                root->right = newNode(15);
                root->left->left = newNode(20);
                root->right->right = newNode(5);
            
                printf("Inorder traversal of the constructed binary tree: \n");
                printInorder(root);
            
                root = binaryTreeToBST(root);
            
                printf("\nInorder traversal of the converted binary search tree: \n");
                printInorder(root);
            
                return 0;
            }
                </code>
                <p>OUTPUT</p>
                <code>
Inorder traversal of the constructed binary tree: 
            20 30 10 15 5 
            Inorder traversal of the converted binary search tree: 
            5 10 15 20 30
            
                </code>
                </pre>

                </section>
            <section id="tree12">
                <p>Q-12:FIND KTH LARGEST ELEMENT IN BINARY SEARCH TREE THROUGH ARRAY</p>
                <pre>
                <code >
#include <stdio.h>
            
            int kthLargest(int arr[], int size, int k) {
                if (k > 0 && k <= size) {
                    return arr[size - k];
                }
                return -1;
            }
            
            int main() {
                int size, k;
            
                printf("Enter the size of the binary search tree: ");
                scanf("%d", &size);
            
                int bst[size];
            
                printf("Enter the elements of the binary search tree:\n");
                for (int i = 0; i < size; i++) {
                    scanf("%d", &bst[i]);
                }
            
                printf("Enter the value of K: ");
                scanf("%d", &k);
            
                int result = kthLargest(bst, size, k);
            
                if (result != -1) {
                    printf("The %dth largest element in the binary search tree is: %d", k, result);
                } else {
                    printf("Invalid input. The element does not exist.");
                }
                return 0;
            }
                </code>
                <p>OUTPUT</p>
                <code>
Enter the size of the binary search tree: 7
            Enter the elements of the binary search tree:
            4
            8
            10
            12
            15
            18
            20
            Enter the value of K: 3
            The 3rd largest element in the binary search tree is: 15
                </code>
                </pre>

                </section>
            <section id="tree13">
                <p>Q-13:FIND KTH SMALLEST ELEMENT IN A BINARY SEARCH TREE THROUGH ARRAY</p>
                <pre>
                <code >
#include <stdio.h>
            
            int kthSmallest(int arr[], int size, int k) {
                if (k > 0 && k <= size) {
                    return arr[k - 1];
                }
                return -1;
            }
            
            int main() {
                int bst[] = {2, 3, 4, 5, 6, 8, 9};
                int size = sizeof(bst) / sizeof(bst[0]);
                int k = 3;
            
                int result = kthSmallest(bst, size, k);
            
                if (result != -1) {
                    printf("The %dth smallest element in the binary search tree is: %d", k, result);
                } else {
                    printf("Invalid input. The element does not exist.");
                }
                return 0;
            }
                </code>
                <p>OUTPUT</p>
                <code>
 The 3rd smallest element in the binary search tree is: 4
                </code>
                </pre>

                </section>
            <section id="tree14">
                <p>Q-14:PRINT PREORDER TRAVERSAL TO POSTORDER TRAVERSAL OF BINARY SEARCH TREE</p>
                <pre>
                <code >
#include <stdio.h>
            #include <stdlib.h>
            
            struct Node {
                int data;
                struct Node *left, *right;
            };
            
            struct Node* createNode(int data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                newNode->data = data;
                newNode->left = newNode->right = NULL;
                return newNode;
            }
            
            struct Node* constructBST(int preorder[], int* preIndex, int key, int min, int max, int size) {
                if (*preIndex >= size) {
                    return NULL;
                }
            
                struct Node* root = NULL;
            
                if (key > min && key < max) {
                    root = createNode(key);
                    *preIndex = *preIndex + 1;
            
                    if (*preIndex < size) {
                        root->left = constructBST(preorder, preIndex, preorder[*preIndex], min, key, size);
                        root->right = constructBST(preorder, preIndex, preorder[*preIndex], key, max, size);
                    }
                }
                return root;
            }
            
            void postorderTraversal(struct Node* root) {
                if (root != NULL) {
                    postorderTraversal(root->left);
                    postorderTraversal(root->right);
                    printf("%d ", root->data);
                }
            }
            
            int main() {
                int preorder[] = {8, 5, 3, 6, 10, 9, 12};
                int size = sizeof(preorder) / sizeof(preorder[0]);
                int preIndex = 0;
            
                struct Node* root = constructBST(preorder, &preIndex, preorder[preIndex], INT_MIN, INT_MAX, size);
            
                printf("Postorder traversal of the constructed BST: ");
                postorderTraversal(root);
                return 0;
            }
                </code>
                <p>OUTPUT</p>
                <code>
Postorder traversal of the constructed BST: 3 6 5 9 12 10 8
                </code>
                </pre>

                </section>
            <section id="tree15">
                <p>Q-15:CONSTRUCT BINARY SEARCH TREE FROM GIVEN PREORDER TRAVERSAL THROUGH ARRAYS</p>
                <pre>
                <code >
#include <stdio.h>
            #include <stdlib.h>
            
            struct Node {
                int data;
                struct Node *left, *right;
            };
            
            struct Node* createNode(int data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                newNode->data = data;
                newNode->left = newNode->right = NULL;
                return newNode;
            }
            
            struct Node* constructBST(int preorder[], int* preIndex, int key, int min, int max, int size) {
                if (*preIndex >= size) {
                    return NULL;
                }
            
                struct Node* root = NULL;
            
                if (key > min && key < max) {
                    root = createNode(key);
                    *preIndex = *preIndex + 1;
            
                    if (*preIndex < size) {
                        root->left = constructBST(preorder, preIndex, preorder[*preIndex], min, key, size);
                        root->right = constructBST(preorder, preIndex, preorder[*preIndex], key, max, size);
                    }
                }
                return root;
            }
            
            void inorderTraversal(struct Node* root) {
                if (root != NULL) {
                    inorderTraversal(root->left);
                    printf("%d ", root->data);
                    inorderTraversal(root->right);
                }
            }
            
            int main() {
                int preorder[] = {5, 3, 2, 4, 8, 6, 9};
                int size = sizeof(preorder) / sizeof(preorder[0]);
                int preIndex = 0;
            
                struct Node* root = constructBST(preorder, &preIndex, preorder[preIndex], INT_MIN, INT_MAX, size);
            
                printf("Inorder traversal of the constructed BST: ");
                inorderTraversal(root);
                return 0;
            }
                </code>
                <p>OUTPUT</p>
                <code>
 Inorder traversal of the constructed BST: 2 3 4 5 6 8 9
            
                </code>
                </pre>

                </section>
            <section id="tree16">
                <p>Q-16:CONSTRUCT BINARY SEARCH TREE FROM GIVEN POSTORDER TRAVERSAL THROUGH ARRAYS</p>
                <pre>
                <code >
#include <stdio.h>
            #include <stdlib.h>
            
            struct Node {
                int data;
                struct Node *left, *right;
            };
            
            struct Node* createNode(int data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                newNode->data = data;
                newNode->left = newNode->right = NULL;
                return newNode;
            }
            
            struct Node* constructBST(int postorder[], int* postIndex, int key, int min, int max, int size) {
                if (*postIndex < 0) {
                    return NULL;
                }
            
                struct Node* root = NULL;
            
                if (key > min && key < max) {
                    root = createNode(key);
                    *postIndex = *postIndex - 1;
            
                    if (*postIndex >= 0) {
                        root->right = constructBST(postorder, postIndex, postorder[*postIndex], key, max, size);
                        root->left = constructBST(postorder, postIndex, postorder[*postIndex], min, key, size);
                    }
                }
                return root;
            }
            
            void inorderTraversal(struct Node* root) {
                if (root != NULL) {
                    inorderTraversal(root->left);
                    printf("%d ", root->data);
                    inorderTraversal(root->right);
                }
            }
            
            int main() {
                int postorder[] = {1, 3, 2, 7, 9, 8, 5};
                int size = sizeof(postorder) / sizeof(postorder[0]);
                int postIndex = size - 1;
            
                struct Node* root = constructBST(postorder, &postIndex, postorder[postIndex], INT_MIN, INT_MAX, size);
            
                printf("Inorder traversal of the constructed BST: ");
                inorderTraversal(root);
                return 0;
            }
                </code>
                <p>OUTPUT</p>
                <code>
 Inorder traversal of the constructed BST: 1 2 3 5 7 8 9
                </code>
                </pre>

                </section>
            <section id="tree17">
                <p>Q-17:CREATE STRICTLY BINARY TREE FROM THE GIVEN INPUT BY THE USER (DYNAMICALLY)</p>
                <pre>
                <code >
#include <stdio.h>
            #include <stdlib.h>
            
            struct Node {
                int data;
                struct Node *left;
                struct Node *right;
            };
            
            struct Node* createNode(int data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                newNode->data = data;
                newNode->left = NULL;
                newNode->right = NULL;
                return newNode;
            }
            
            struct Node* insertNode(struct Node* root, int data) {
                if (root == NULL) {
                    root = createNode(data);
                } else {
                    printf("Node already exists.\n");
                }
                return root;
            }
            
            void inorderTraversal(struct Node* root) {
                if (root != NULL) {
                    inorderTraversal(root->left);
                    printf("%d ", root->data);
                    inorderTraversal(root->right);
                }
            }
            
            int main() {
                struct Node* root = NULL;
                int n;
                printf("Enter the number of nodes in the strictly binary tree: ");
                scanf("%d", &n);
            
                int arr[n];
                printf("Enter the elements: ");
                for (int i = 0; i < n; i++) {
                    scanf("%d", &arr[i]);
                    root = insertNode(root, arr[i]);
                }
            
                printf("Inorder traversal of the strictly binary tree: ");
                inorderTraversal(root);
                return 0;
            }
                </code>
                <p>OUTPUT</p>
                <code>
Enter the number of nodes in the strictly binary tree: 5
            Enter the elements: 1 2 3 4 5
            Node already exists.
            Inorder traversal of the strictly binary tree: 1 2 3 4 5
                </code>
                </pre>

                </section>
            <section id="tree18">
                <p>Q-18:CREATE ALMOST COMPLETE BINARY TREE FROM THE GIVEN INPUT BY THE USER (DYNAMICALLY)</p>
                <pre>
                <code >
#include <stdio.h>
            #include <stdlib.h>
            
            // Structure for a binary tree node
            struct Node {
                int data;
                struct Node *left;
                struct Node *right;
            };
            
            // Function to create a new node
            struct Node* createNode(int data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                newNode->data = data;
                newNode->left = NULL;
                newNode->right = NULL;
                return newNode;
            }
            
            // Function to insert nodes in level order
            struct Node* insertLevelOrder(int arr[], struct Node* root, int i, int n) {
                // Base case for recursion
                if (i < n) {
                    struct Node* temp = createNode(arr[i]);
                    root = temp;
            
                    // Insert left child
                    root->left = insertLevelOrder(arr, root->left, 2 * i + 1, n);
            
                    // Insert right child
                    if (2 * i + 2 < n) {
                        root->right = insertLevelOrder(arr, root->right, 2 * i + 2, n);
                    }
                }
                return root;
            }
            
            // Function to traverse the binary tree in preorder
            void preorder(struct Node* root) {
                if (root != NULL) {
                    printf("%d ", root->data);
                    preorder(root->left);
                    preorder(root->right);
                }
            }
            
            // Driver code
            int main() {
                struct Node* root = NULL;
                int n;
                printf("Enter the number of nodes in the almost complete binary tree: ");
                scanf("%d", &n);
            
                int arr[n];
                printf("Enter the elements: ");
                for (int i = 0; i < n; i++) {
                    scanf("%d", &arr[i]);
                }
            
                root = insertLevelOrder(arr, root, 0, n);
                printf("Preorder traversal of the almost complete binary tree: ");
                preorder(root);
            
                return 0;
            }
                </code>
                <p>OUTPUT</p>
                <code>
 Enter the number of nodes in the almost complete binary tree: 5
            Enter the elements: 1 2 3 4 5
            Preorder traversal of the almost complete binary tree: 1 2 4 5 3
            
                </code>
                </pre>

                </section>
            <section id="tree19">
                <p>Q-19:CREATE COMPLETE BINARY TREE FROM THE GIVEN INPUT BY THE USER (DYNAMICALLY)</p>
                <pre>
                <code >
#include <stdio.h>
            #include <stdlib.h>
            
            // Structure for a binary tree node
            struct Node {
                int data;
                struct Node *left;
                struct Node *right;
            };
            
            // Function to create a new node
            struct Node* createNode(int data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                newNode->data = data;
                newNode->left = NULL;
                newNode->right = NULL;
                return newNode;
            }
            
            // Function to insert nodes in level order
            struct Node* insertLevelOrder(int arr[], struct Node* root, int i, int n) {
                // Base case for recursion
                if (i < n) {
                    struct Node* temp = createNode(arr[i]);
                    root = temp;
            
                    // Insert left child
                    root->left = insertLevelOrder(arr, root->left, 2 * i + 1, n);
            
                    // Insert right child
                    root->right = insertLevelOrder(arr, root->right, 2 * i + 2, n);
                }
                return root;
            }
            
            // Function to traverse the binary tree in preorder
            void preorder(struct Node* root) {
                if (root != NULL) {
                    printf("%d ", root->data);
                    preorder(root->left);
                    preorder(root->right);
                }
            }
            
            // Driver code
            int main() {
                struct Node* root = NULL;
                int n;
                printf("Enter the number of nodes in the binary tree: ");
                scanf("%d", &n);
            
                int arr[n];
                printf("Enter the elements: ");
                for (int i = 0; i < n; i++) {
                    scanf("%d", &arr[i]);
                }
            
                root = insertLevelOrder(arr, root, 0, n);
                printf("Preorder traversal of the complete binary tree: ");
                preorder(root);
            
                return 0;
            }
                </code>
                <p>OUTPUT</p>
                <code>

            Enter the number of nodes in the binary tree: 5
            Enter the elements: 1 2 3 4 5
            Preorder traversal of the complete binary tree: 1 2 4 5 3 
            
                </code>
                </pre>

                </section>
            <section id="tree20">
                <p>Q-20:COUNT THE NUMBER OF NODES IN BINARY SEARCH TREE CONSTRUCTED DYNAMICALLY</p>
                <pre>
                <code >
#include <stdio.h>
            #include <stdlib.h>
            
            struct Node {
                int data;
                struct Node *left;
                struct Node *right;
            };
            
            struct Node* createNode(int data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                newNode->data = data;
                newNode->left = NULL;
                newNode->right = NULL;
                return newNode;
            }
            
            struct Node* insert(struct Node* root, int data) {
                if (root == NULL) {
                    return createNode(data);
                }
            
                if (data < root->data) {
                    root->left = insert(root->left, data);
                } else if (data > root->data) {
                    root->right = insert(root->right, data);
                }
            
                return root;
            }
            
            int countNodes(struct Node* root) {
                if (root == NULL) {
                    return 0;
                }
                return 1 + countNodes(root->left) + countNodes(root->right);
            }
            
            int main() {
                struct Node* root = NULL;
                int n, data;
                printf("Enter the number of nodes you want to insert: ");
                scanf("%d", &n);
                printf("Enter the elements:\n");
                for (int i = 0; i < n; i++) {
                    scanf("%d", &data);
                    root = insert(root, data);
                }
            
                printf("Number of nodes in the BST is %d", countNodes(root));
                return 0;
            }
                </code>
                <p>OUTPUT</p>
                <code>
Enter the number of nodes you want to insert: 7
            Enter the elements:
            5
            3
            7
            2
            4
            6
            8
            Number of nodes in the BST is 7
            
                </code>
                </pre>

                </section>
                
        </ul>
       
    </section>

    <section id="graphs">
        <h2>GRAPH PROBLEMS</h2>
        <ul>
            <li><a href="#graph1">Q-1:ENTER THE VERTICES AND EDGES AND REPRESENT IN ADJACENCY MATRIX AND PRINT IT.</a></li>
            <li><a href="#graph2">Q-2:CREATE THE GRAPH AS A ADJACENCY LIST WITH OPERATIONS SUCH AS INSERTION, DELETION</a></li>
            <li><a href="#graph3">Q-3:TRAVERSE THE ADJACENT MATRIX WITH DEPTH FIRST SEARCH</a></li>
            <li><a href="#graph4">Q-4:TRAVERSE THE ADJACENT LIST WITH DEPTH FIRST SEARCH</a></li>
            <li><a href="#graph5">Q-5:TRAVERSE THE ADJACENT MATRIX WITH BREADTH FIRST SEARCH</a></li>
            <li><a href="#graph6">Q-6:TRAVERSE THE ADJACENT LIST WITH BREADTH FIRST SEARCH</a></li>
            <section id="graph1">
                <p>Q-1:ENTER THE VERTICES AND EDGES AND REPRESENT IN ADJACENCY MATRIX AND PRINT IT.</p>
                <pre>
                <code >
#include <stdio.h>

#define MAX 10

void initializeMatrix(int adjacencyMatrix[MAX][MAX], int numVertices) {
    for (int i = 0; i < numVertices; i++) {
        for (int j = 0; j < numVertices; j++) {
            adjacencyMatrix[i][j] = 0;
        }
    }
}

void addEdge(int adjacencyMatrix[MAX][MAX], int origin, int destination) {
    adjacencyMatrix[origin][destination] = 1;
    // Uncomment the next line if your graph is undirected
    // adjacencyMatrix[destination][origin] = 1;
}

void printAdjacencyMatrix(int adjacencyMatrix[MAX][MAX], int numVertices) {
    printf("\nAdjacency Matrix:\n");
    for (int i = 0; i < numVertices; i++) {
        for (int j = 0; j < numVertices; j++) {
            printf("%d ", adjacencyMatrix[i][j]);
        }
        printf("\n");
    }
}

int main() {
    int adjacencyMatrix[MAX][MAX];
    int numVertices, numEdges, origin, destination;

    printf("Enter the number of vertices: ");
    scanf("%d", &numVertices);

    initializeMatrix(adjacencyMatrix, numVertices);

    printf("Enter the number of edges: ");
    scanf("%d", &numEdges);

    printf("Enter the edges (format: <origin> <destination>):\n");
    for (int e = 0; e < numEdges; e++) {
        scanf("%d %d", &origin, &destination);
        if (origin >= numVertices || destination >= numVertices || origin < 0 || destination < 0) {
            printf("Invalid edge. Please try again.\n");
            e--;
            continue;
        }
        addEdge(adjacencyMatrix, origin, destination);
    }

    printAdjacencyMatrix(adjacencyMatrix, numVertices);

    return 0;
}
                </code>
                <p>OUTPUT</p>
                <code>

Enter the number of vertices: 4
Enter the number of edges: 4
Enter the edges (format:<origin> <destination>):
0 1
1 2
2 3
3 0

Adjacency Matrix:
0 1 0 0 
0 0 1 0 
0 0 0 1 
1 0 0 0

                </code>
                </pre>

                </section>
            <section id="graph2">
                <p>Q-2:CREATE THE GRAPH AS A ADJACENCY LIST WITH OPERATIONS SUCH AS INSERTION, DELETION</p>
                <pre>
                <code >
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
};

struct Graph {
    int numVertices;
    struct Node** adjLists;
};

struct Node* createNode(int v) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = v;
    newNode->next = NULL;
    return newNode;
}

struct Graph* createGraph(int vertices) {
    struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
    graph->numVertices = vertices;

    graph->adjLists = (struct Node**)malloc(vertices * sizeof(struct Node*));

    for (int i = 0; i < vertices; i++) {
        graph->adjLists[i] = NULL;
    }

    return graph;
}

void addEdge(struct Graph* graph, int src, int dest) {
    // Add edge from src to dest
    struct Node* newNode = createNode(dest);
    newNode->next = graph->adjLists[src];
    graph->adjLists[src] = newNode;

    // Uncomment the next two lines if your graph is undirected
    // newNode = createNode(src);
    // newNode->next = graph->adjLists[dest];
    // graph->adjLists[dest] = newNode;
}

void printGraph(struct Graph* graph) {
    for (int v = 0; v < graph->numVertices; v++) {
        struct Node* temp = graph->adjLists[v];
        printf("\n Adjacency list of vertex %d\n head ", v);
        while (temp) {
            printf("-> %d", temp->data);
            temp = temp->next;
        }
        printf("\n");
    }
}

void deleteGraph(struct Graph* graph) {
    if (graph) {
        if (graph->adjLists) {
            for (int v = 0; v < graph->numVertices; v++) {
                struct Node* temp = graph->adjLists[v];
                while (temp) {
                    struct Node* prev = temp;
                    temp = temp->next;
                    free(prev);
                }
            }
            free(graph->adjLists);
        }
        free(graph);
    }
}

int main() {
    int vertices, edges, src, dest;

    printf("Enter the number of vertices: ");
    scanf("%d", &vertices);

    struct Graph* graph = createGraph(vertices);

    printf("Enter the number of edges: ");
    scanf("%d", &edges);

    printf("Enter the edges (format: <source> <destination>):\n");
    for (int i = 0; i < edges; i++) {
        scanf("%d %d", &src, &dest);
        if (src < 0 || src >= vertices || dest < 0 || dest >= vertices) {
            printf("Invalid edge. Please try again.\n");
            i--;
            continue;
        }
        addEdge(graph, src, dest);
    }

    printf("\nAdjacency List representation of the graph:\n");
    printGraph(graph);

    deleteGraph(graph);
    return 0;
}
 
                </code>
                <p>OUTPUT</p>
                <code>
Enter the number of vertices: 4
Enter the number of edges: 5
Enter the edges (format: <source> <destination>):
0 1
0 2
1 2
2 0
2 3

Adjacency List representation of the graph:

 Adjacency list of vertex 0
 head -> 2-> 1

 Adjacency list of vertex 1
 head -> 2

 Adjacency list of vertex 2
 head -> 3-> 0-> 1

 Adjacency list of vertex 3
 head
                </code>
                </pre>

                </section>
            <section id="graph3">
                <p>Q-3:TRAVERSE THE ADJACENT MATRIX WITH DEPTH FIRST SEARCH</p>
                <pre>
                <code >

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

struct Node {
    int data;
    struct Node* next;
};

struct Graph {
    int numVertices;
    struct Node** adjLists;
};

struct Node* createNode(int v) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = v;
    newNode->next = NULL;
    return newNode;
}

struct Graph* createGraph(int vertices) {
    struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
    graph->numVertices = vertices;

    graph->adjLists = (struct Node**)malloc(vertices * sizeof(struct Node*));

    for (int i = 0; i < vertices; i++) {
        graph->adjLists[i] = NULL;
    }

    return graph;
}

void addEdge(struct Graph* graph, int src, int dest) {
    // Add edge from src to dest
    struct Node* newNode = createNode(dest);
    newNode->next = graph->adjLists[src];
    graph->adjLists[src] = newNode;

    // Uncomment the next two lines if your graph is undirected
    // newNode = createNode(src);
    // newNode->next = graph->adjLists[dest];
    // graph->adjLists[dest] = newNode;
}

void printGraph(struct Graph* graph) {
    for (int v = 0; v < graph->numVertices; v++) {
        struct Node* temp = graph->adjLists[v];
        printf("\n Adjacency list of vertex %d\n head ", v);
        while (temp) {
            printf("-> %d", temp->data);
            temp = temp->next;
        }
        printf("\n");
    }
}

void DFSUtil(struct Graph* graph, int v, bool visited[]) {
    visited[v] = true;
    printf("%d ", v);

    struct Node* temp = graph->adjLists[v];
    while (temp) {
        int adjVertex = temp->data;
        if (!visited[adjVertex]) {
            DFSUtil(graph, adjVertex, visited);
        }
        temp = temp->next;
    }
}

void DFS(struct Graph* graph, int startVertex) {
    bool* visited = (bool*)malloc(graph->numVertices * sizeof(bool));
    for (int i = 0; i < graph->numVertices; i++) {
        visited[i] = false;
    }

    DFSUtil(graph, startVertex, visited);
    free(visited);
}

void deleteGraph(struct Graph* graph) {
    if (graph) {
        if (graph->adjLists) {
            for (int v = 0; v < graph->numVertices; v++) {
                struct Node* temp = graph->adjLists[v];
                while (temp) {
                    struct Node* prev = temp;
                    temp = temp->next;
                    free(prev);
                }
            }
            free(graph->adjLists);
        }
        free(graph);
    }
}

int main() {
    int vertices, edges, src, dest;

    printf("Enter the number of vertices: ");
    scanf("%d", &vertices);

    struct Graph* graph = createGraph(vertices);

    printf("Enter the number of edges: ");
    scanf("%d", &edges);

    printf("Enter the edges (format: <source> <destination>):\n");
    for (int i = 0; i < edges; i++) {
        scanf("%d %d", &src, &dest);
        if (src < 0 || src >= vertices || dest < 0 || dest >= vertices) {
            printf("Invalid edge. Please try again.\n");
            i--;
            continue;
        }
        addEdge(graph, src, dest);
    }

    printf("\nAdjacency List representation of the graph:\n");
    printGraph(graph);

    printf("\nDepth First Traversal starting from vertex 0: ");
    DFS(graph, 0);
    printf("\n");

    deleteGraph(graph);
    return 0;
}
                </code>
                <p>OUTPUT</p>
                <code>
Enter the number of vertices: 4
Enter the number of edges: 5
Enter the edges (format: <source> <destination>):
0 1
0 2
1 2
2 0
2 3

Adjacency List representation of the graph:

 Adjacency list of vertex 0
 head -> 2-> 1

 Adjacency list of vertex 1
 head -> 2

 Adjacency list of vertex 2
 head -> 3-> 0-> 1

 Adjacency list of vertex 3
 head

Depth First Traversal starting from vertex 0: 0 2 3 1
                </code>
                </pre>

                </section>
            <section id="graph4">
                <p>Q-4:TRAVERSE THE ADJACENT LIST WITH DEPTH FIRST SEARCH</p>
                <pre>
                <code >
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

struct Node {
    int data;
    struct Node* next;
};

struct Graph {
    int numVertices;
    struct Node** adjLists;
};

struct Node* createNode(int v) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = v;
    newNode->next = NULL;
    return newNode;
}

struct Graph* createGraph(int vertices) {
    struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
    graph->numVertices = vertices;

    graph->adjLists = (struct Node**)malloc(vertices * sizeof(struct Node*));

    for (int i = 0; i < vertices; i++) {
        graph->adjLists[i] = NULL;
    }

    return graph;
}

void addEdge(struct Graph* graph, int src, int dest) {
    // Add edge from src to dest
    struct Node* newNode = createNode(dest);
    newNode->next = graph->adjLists[src];
    graph->adjLists[src] = newNode;

    // Uncomment the next two lines if your graph is undirected
    // newNode = createNode(src);
    // newNode->next = graph->adjLists[dest];
    // graph->adjLists[dest] = newNode;
}

void printGraph(struct Graph* graph) {
    for (int v = 0; v < graph->numVertices; v++) {
        struct Node* temp = graph->adjLists[v];
        printf("\n Adjacency list of vertex %d\n head ", v);
        while (temp) {
            printf("-> %d", temp->data);
            temp = temp->next;
        }
        printf("\n");
    }
}

void DFSUtil(struct Graph* graph, int v, bool visited[]) {
    visited[v] = true;
    printf("%d ", v);

    struct Node* temp = graph->adjLists[v];
    while (temp) {
        int adjVertex = temp->data;
        if (!visited[adjVertex]) {
            DFSUtil(graph, adjVertex, visited);
        }
        temp = temp->next;
    }
}

void DFS(struct Graph* graph, int startVertex) {
    bool* visited = (bool*)malloc(graph->numVertices * sizeof(bool));
    for (int i = 0; i < graph->numVertices; i++) {
        visited[i] = false;
    }

    DFSUtil(graph, startVertex, visited);
    free(visited);
}

void deleteGraph(struct Graph* graph) {
    if (graph) {
        if (graph->adjLists) {
            for (int v = 0; v < graph->numVertices; v++) {
                struct Node* temp = graph->adjLists[v];
                while (temp) {
                    struct Node* prev = temp;
                    temp = temp->next;
                    free(prev);
                }
            }
            free(graph->adjLists);
        }
        free(graph);
    }
}

int main() {
    int vertices, edges, src, dest;

    printf("Enter the number of vertices: ");
    scanf("%d", &vertices);

    struct Graph* graph = createGraph(vertices);

    printf("Enter the number of edges: ");
    scanf("%d", &edges);

    printf("Enter the edges (format: <source> <destination>):\n");
    for (int i = 0; i < edges; i++) {
        scanf("%d %d", &src, &dest);
        if (src < 0 || src >= vertices || dest < 0 || dest >= vertices) {
            printf("Invalid edge. Please try again.\n");
            i--;
            continue;
        }
        addEdge(graph, src, dest);
    }

    printf("\nAdjacency List representation of the graph:\n");
    printGraph(graph);

    printf("\nDepth First Traversal starting from vertex 0: ");
    DFS(graph, 0);
    printf("\n");

    deleteGraph(graph);
    return 0;
}
                </code>
                <p>OUTPUT</p>
                <code>
Enter the number of vertices: 4
Enter the number of edges: 5
Enter the edges (format: <source> <destination>):
0 1
0 2
1 2
2 0
2 3

Adjacency List representation of the graph:

 Adjacency list of vertex 0
 head -> 2-> 1

 Adjacency list of vertex 1
 head -> 2

 Adjacency list of vertex 2
 head -> 3-> 0-> 1

 Adjacency list of vertex 3
 head

Depth First Traversal starting from vertex 0: 0 2 3 1

                
                </code>
                </pre>

                </section>
            <section id="graph5">
                <p>Q-5:TRAVERSE THE ADJACENT MATRIX WITH BREADTH FIRST SEARCH</p>
                <pre>
                <code >
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAX 10

struct Queue {
    int items[MAX];
    int front;
    int rear;
};

struct Queue* createQueue() {
    struct Queue* queue = (struct Queue*)malloc(sizeof(struct Queue));
    queue->front = -1;
    queue->rear = -1;
    return queue;
}

bool isEmpty(struct Queue* queue) {
    return queue->rear == -1;
}

void enqueue(struct Queue* queue, int value) {
    if (queue->rear == MAX - 1)
        printf("\nQueue is full");
    else {
        if (queue->front == -1)
            queue->front = 0;
        queue->rear++;
        queue->items[queue->rear] = value;
    }
}

int dequeue(struct Queue* queue) {
    int item;
    if (isEmpty(queue)) {
        printf("Queue is empty");
        item = -1;
    } else {
        item = queue->items[queue->front];
        queue->front++;
        if (queue->front > queue->rear) {
            queue->front = queue->rear = -1;
        }
    }
    return item;
}

struct Graph {
    int numVertices;
    int** adjacencyMatrix;
};

struct Graph* createGraph(int vertices) {
    struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
    graph->numVertices = vertices;

    graph->adjacencyMatrix = (int**)malloc(vertices * sizeof(int*));
    for (int i = 0; i < vertices; i++) {
        graph->adjacencyMatrix[i] = (int*)malloc(vertices * sizeof(int));
        for (int j = 0; j < vertices; j++) {
            graph->adjacencyMatrix[i][j] = 0;
        }
    }

    return graph;
}

void addEdge(struct Graph* graph, int src, int dest) {
    graph->adjacencyMatrix[src][dest] = 1;
    // Uncomment the next line if your graph is undirected
    // graph->adjacencyMatrix[dest][src] = 1;
}

void printGraph(struct Graph* graph) {
    printf("Adjacency Matrix:\n");
    for (int i = 0; i < graph->numVertices; i++) {
        for (int j = 0; j < graph->numVertices; j++) {
            printf("%d ", graph->adjacencyMatrix[i][j]);
        }
        printf("\n");
    }
}

void BFS(struct Graph* graph, int startVertex) {
    struct Queue* queue = createQueue();
    bool* visited = (bool*)malloc(graph->numVertices * sizeof(bool));
    for (int i = 0; i < graph->numVertices; i++) {
        visited[i] = false;
    }

    visited[startVertex] = true;
    enqueue(queue, startVertex);

    while (!isEmpty(queue)) {
        int currentVertex = dequeue(queue);
        printf("%d ", currentVertex);

        for (int i = 0; i < graph->numVertices; i++) {
            if (graph->adjacencyMatrix[currentVertex][i] == 1 && !visited[i]) {
                enqueue(queue, i);
                visited[i] = true;
            }
        }
    }

    free(queue);
    free(visited);
}

void deleteGraph(struct Graph* graph) {
    if (graph) {
        if (graph->adjacencyMatrix) {
            for (int i = 0; i < graph->numVertices; i++) {
                free(graph->adjacencyMatrix[i]);
            }
            free(graph->adjacencyMatrix);
        }
        free(graph);
    }
}

int main() {
    int vertices, edges, src, dest;

    printf("Enter the number of vertices: ");
    scanf("%d", &vertices);

    struct Graph* graph = createGraph(vertices);

    printf("Enter the number of edges: ");
    scanf("%d", &edges);

    printf("Enter the edges (format: <source> <destination>):\n");
    for (int i = 0; i < edges; i++) {
        scanf("%d %d", &src, &dest);
        if (src < 0 || src >= vertices || dest < 0 || dest >= vertices) {
            printf("Invalid edge. Please try again.\n");
            i--;
            continue;
        }
        addEdge(graph, src, dest);
    }

    printf("\n");
    printGraph(graph);

    printf("\nBreadth First Traversal starting from vertex 0: ");
    BFS(graph, 0);
    printf("\n");

    deleteGraph(graph);
    return 0;
}
 
                </code>
                <p>OUTPUT</p>
                <code>
Enter the number of vertices: 4
Enter the number of edges: 5
Enter the edges (format: <source> <destination>):
0 1
0 2
1 2
2 0
2 3

Adjacency Matrix:
0 1 1 0 
0 0 1 0 
1 0 0 1 
0 0 0 0 

Breadth First Traversal starting from vertex 0: 0 1 2 3 
                </code>
                </pre>

                </section>
            <section id="graph6">
                <p>Q-6:TRAVERSE THE ADJACENT LIST WITH BREADTH FIRST SEARCH</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
    
        </ul>
    </section>

    <section id="searching">
        <h2>SEARCHING PROBLEMS</h2>
        <ul>
            <li><a href="#search1">Q-1:ENTER A INTEGER ARRAY FROM THE USER, ENTER AN INTEGER VALUE AND PERFORM LINEAR SEARCH ALGORITHM THROUGH ITERATION.</a></li>
            <li><a href="#search2">Q-2:ENTER A STRING FROM THE USER, ENTER A CHARACTER AND PERFORM LINEAR SEARCH ALGORITHM THROUGH RECURSION.</a></li>
            <li><a href="#search3">Q-3:ENTER A INTEGER ARRAY FROM THE USER, ENTER AN INTEGER VALUE AND PERFORM LINEAR SEARCH ALGORITHM THROUGH RECURSION.</a></li>
            <li><a href="#search4">Q-4:ENTER A STRING FROM THE USER, ENTER A CHARACTER AND PERFORM LINEAR SEARCH ALGORITHM THROUGH ITERATION.</a></li>
            <li><a href="#search5">Q-5:ENTER A INTEGER ARRAY FROM THE USER, ENTER AN INTEGER VALUE AND PERFORM BINARY SEARCH ALGORITHM THROUGH ITERATION.</a></li>
            <li><a href="#search6">Q-6:ENTER A STRING FROM THE USER, ENTER A CHARACTER AND PERFORM BINARY SEARCH ALGORITHM THROUGH RECURSION.</a></li>
            <li><a href="#search7">Q-7:ENTER A INTEGER ARRAY FROM THE USER, ENTER AN INTEGER VALUE AND PERFORM BINARY SEARCH ALGORITHM THROUGH RECURSION.</a></li>
            <li><a href="#search8">Q-8:ENTER A STRING FROM THE USER, ENTER A CHARACTER AND PERFORM BINARY SEARCH ALGORITHM THROUGH ITERATION.</a></li>
            <li><a href="#search9">Q-9:CALCULATE THE BEST AND WORST COMPLEXITY OF THE LINEAR SEARCHING ALGORITHM WITH EXACT TIME TAKEN BY THE ALGORITHM ON INTEGER ARRAY.</a></li>
            <li><a href="#search10">Q-10:CALCULATE THE BEST AND WORST COMPLEXITY OF THE BINARY SEARCHING ALGORITHM WITH EXACT TIME TAKEN BY THE ALGORITHM ON INTEGER ARRAY.</a></li>

            <section id="search1">
                <p>Q-1:ENTER A INTEGER ARRAY FROM THE USER, ENTER AN INTEGER VALUE AND PERFORM LINEAR SEARCH ALGORITHM THROUGH ITERATION.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="search2">
                <p>Q-2:ENTER A STRING FROM THE USER, ENTER A CHARACTER AND PERFORM LINEAR SEARCH ALGORITHM THROUGH RECURSION.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="search3">
                <p>Q-3:ENTER A INTEGER ARRAY FROM THE USER, ENTER AN INTEGER VALUE AND PERFORM LINEAR SEARCH ALGORITHM THROUGH RECURSION.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="search4">
                <p>Q-4:ENTER A STRING FROM THE USER, ENTER A CHARACTER AND PERFORM LINEAR SEARCH ALGORITHM THROUGH ITERATION.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="search5">
                <p>Q-5:ENTER A INTEGER ARRAY FROM THE USER, ENTER AN INTEGER VALUE AND PERFORM BINARY SEARCH ALGORITHM THROUGH ITERATION.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="search6">
                <p>Q-6:ENTER A STRING FROM THE USER, ENTER A CHARACTER AND PERFORM BINARY SEARCH ALGORITHM THROUGH RECURSION.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="search7">
                <p>Q-7:ENTER A INTEGER ARRAY FROM THE USER, ENTER AN INTEGER VALUE AND PERFORM BINARY SEARCH ALGORITHM THROUGH RECURSION.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="search8">
                <p>Q-8:ENTER A STRING FROM THE USER, ENTER A CHARACTER AND PERFORM BINARY SEARCH ALGORITHM THROUGH ITERATION.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="search9">
                <p>Q-9:CALCULATE THE BEST AND WORST COMPLEXITY OF THE LINEAR SEARCHING ALGORITHM WITH EXACT TIME TAKEN BY THE ALGORITHM ON INTEGER ARRAY.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="search10">
                <p>Q-10:CALCULATE THE BEST AND WORST COMPLEXITY OF THE BINARY SEARCHING ALGORITHM WITH EXACT TIME TAKEN BY THE ALGORITHM ON INTEGER ARRAY.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>





        </ul>
        
    </section>

    <section id="sorting">
        <h2>SORTING PROBLEMS</h2>
        <ul>
            <li><a href="#sort1">Q-1:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM SELECTION SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort2">Q-2:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM SELECTION SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort3">Q-3:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM BUBBLE SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort4">Q-4:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM BUBBLE SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort5">Q-5:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM INSERTION SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort6">Q-6:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM INSERTION SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort7">Q-7:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM MERGE SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort8">Q-8:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM MERGE SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort9">Q-9:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM QUICK SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort10">Q-10:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM QUICK SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort11">Q-11:ENTER A STRING ARRAY FROM THE USER AND PERFORM SELECTION SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort12">Q-12:ENTER A STRING ARRAY FROM THE USER AND PERFORM SELECTION SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort13">Q-13:ENTER A STRING ARRAY FROM THE USER AND PERFORM BUBBLE SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort14">Q-14:ENTER A STRING ARRAY FROM THE USER AND PERFORM BUBBLE SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort15">Q-15:ENTER A STRING ARRAY FROM THE USER AND PERFORM INSERTION SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort16">Q-16:ENTER A STRING ARRAY FROM THE USER AND PERFORM INSERTION SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort17">Q-17:ENTER A STRING ARRAY FROM THE USER AND PERFORM MERGE SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort18">Q-18:ENTER A STRING ARRAY FROM THE USER AND PERFORM MERGE SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort19">Q-19:ENTER A STRING ARRAY FROM THE USER AND PERFORM QUICK SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort20">Q-20:ENTER A STRING ARRAY FROM THE USER AND PERFORM QUICK SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>

            <section id="sort1">
                <p>Q-1:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM SELECTION SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort2">
                <p>Q-2:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM SELECTION SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort3">
                <p>Q-3:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM BUBBLE SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort4">
                <p>Q-4:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM BUBBLE SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort5">
                <p>Q-5:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM INSERTION SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort6">
                <p>Q-6:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM INSERTION SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort7">
                <p>Q-7:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM MERGE SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort8">
                <p>Q-8:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM MERGE SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort9">
                <p>Q-9:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM QUICK SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort10">
                <p>Q-10:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM QUICK SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort11">
                <p>Q-11:ENTER A STRING ARRAY FROM THE USER AND PERFORM SELECTION SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort12">
                <p>Q-12:ENTER A STRING ARRAY FROM THE USER AND PERFORM SELECTION SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort13">
                <p>Q-13:ENTER A STRING ARRAY FROM THE USER AND PERFORM BUBBLE SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort14">
                <p>Q-14:ENTER A STRING ARRAY FROM THE USER AND PERFORM BUBBLE SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort15">
                <p>Q-15:ENTER A STRING ARRAY FROM THE USER AND PERFORM INSERTION SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort16">
                <p>Q-16:ENTER A STRING ARRAY FROM THE USER AND PERFORM INSERTION SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort17">
                <p>Q-17:ENTER A STRING ARRAY FROM THE USER AND PERFORM MERGE SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort18">
                <p>Q-18:ENTER A STRING ARRAY FROM THE USER AND PERFORM MERGE SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort19">
                <p>Q-19:ENTER A STRING ARRAY FROM THE USER AND PERFORM QUICK SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort20">
                <p>Q-20:ENTER A STRING ARRAY FROM THE USER AND PERFORM QUICK SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
                </p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>



        </ul>
    </section>

    <!-- <footer>
        <p>&copy; 2023 StartupX. All rights reserved.</p>
    </footer> -->
</body>
</html>
