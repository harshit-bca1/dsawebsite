<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSA problems </title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: rgba(255, 255, 255, 0.997);
            line-height: 1.6;
            margin: 0;
            padding: 0;
            
        }
        #myBtn {
      display: none;
      position: fixed;
      bottom: 15px;
      right: 20px;
      z-index: 99;
      font-size: 18px;
      border: none;
      outline: none;
      background-color: rgb(255, 0, 0);
      color: rgb(255, 255, 255);
      cursor: pointer;
      padding: 5px;
      border-radius: 4px;
    }

    #myBtn:hover {
      background-color: #ffd3d3;
    }
    
        header {
            /* background: #000000; 
            color: #fff;
            padding: 288.5px 0;
            text-align: center; */
            background-image: url("background.jpg");
            background-size: cover;
            background-position: center;
            height: 700px; /* Set the desired height of your header */
            color: rgb(0, 0, 0); /* Text color on top of the background image */
            text-align: center;
            padding: 20px; /* Add padding to the header content */

        }
        nav ul {
            list-style-type: none;
            padding: 0;
        }
        nav ul li {
            display: inline;
            margin-right: 40px;
        }
        nav ul li a {
            color: #000000;
            text-decoration: underline;
            text-decoration-color: red; /* Change the color of the underline */
          text-decoration-style: dotted; /* Change the style of the underline */
        }
        section {
            padding: 20px;
            text-align: center;
        }
        
        footer {
            background: #333;
            color: #fff;
            text-align: center;
            padding: 10px 0;
            position: absolute;
            bottom: 0;
            width: 100%;
            
        }
        /* Applying text decorations */
.text-underline {
  text-decoration: underline;
}

.text-overline {
  text-decoration: overline;
}

.text-line-through {
  text-decoration: line-through;
}

.text-multiple-decorations {
  text-decoration: underline overline line-through;
}

/* Customizing text decoration color and style */
.custom-text-decoration {
  text-decoration: underline;
  text-decoration-color: red; /* Change the color of the underline */
  text-decoration-style: wavy; /* Change the style of the underline */
}
a {
            text-decoration: none;
            color: #333;
            font-weight: bold;
        }

        a:hover {
            text-decoration: underline;
        }
    
        p {
            text-decoration: none;
            color: #333;
            font-weight: bold;
        }

        p:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>

    <button onclick="topFunction()" id="myBtn" title="Go to top">Top</button>

<script>
    // When the user scrolls down 20px from the top of the document, show the button
    window.onscroll = function() {scrollFunction()};

    function scrollFunction() {
        if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
            document.getElementById("myBtn").style.display = "block";
        } else {
            document.getElementById("myBtn").style.display = "none";
        }
    }

    // When the user clicks on the button, scroll to the top of the document
    function topFunction() {
        document.body.scrollTop = 0; // For Safari
        document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
    }
    
</script>

    <header>
        <h1>DSA QUESTION SHEET</h1>
        <nav>
            <ul>
                <li><a href="#arrays">ARRAYS</a></li>
                <li><a href="#2darrays">2D-ARRAYS</a></li>
                <li><a href="#string">STRING</a></li>
                <li><a href="#stack">STACK</a></li>
                <li><a href="#queue">QUEUE</a></li>
                <li><a href="#linkedlist">LINKEDLIST</a></li>
                <li><a href="#trees">TREES</a></li>
                <li><a href="#graphs">GRAPHS</a></li>
                <li><a href="#searching">SEARCHING</a></li>
                <li><a href="#sorting">SORTING</a></li>
            </ul>
        </nav>
        <img src="DSA.jpg" alt="DSA Logo" width="400" height="400">
    </header>
    
    <!-- MAIN SECTIONID -->

    <section id="arrays">
        <h2>ARRAY PROBLEMS</h2>
        <ul>
            <li><a href="#arr1">Q-1:Enter an array from user and display all the value ?</a></li>
            <li><a href="#arr2">Q-2:Enter an array from user and print the array in reverse order?</a></li>
            <li><a href="#arr3">Q-3:Enter an array from user and copy the array into second array ?</a></li>
            <li><a href="#arr4">Q-4:Enter an array from user and copy it into another array in reverse order ?</a></li>
            <li><a href="#arr5">Q-5:Enter an array from user and print the number which is even ?</a></li>
            <li><a href="#arr6">Q-6:Enter an array from user and print the number which is positive ?</a></li>
            <li><a href="#arr7">Q-7:Enter an array from user and square all the values of array ?</a></li>
            <li><a href="#arr8">Q-8:Enter an array from user and find maximum and minimum value?</a></li>
            <li><a href="#arr9">Q-9:Enter an array from user and find the k-th smallest value?</a></li>
            <li><a href="#arr10">Q-10:Enter an array from user and add all values ?</a></li>
            <li><a href="#arr11">Q-11:Enter an array from user and find the duplicate values?</a></li>
            <li><a href="#arr12">Q-12:Enter an array from user and remove the duplicate values and fill with zero?</a></li>
            <li><a href="#arr13">Q-13:Enter an array from user and count the duplicate values?</a></li>
            <li><a href="#arr14">Q-14:Enter an array from user and print all possible combinations of the elements?</a></li>
            <li><a href="#arr15">Q-15:Enter an array from user and print all the palindrone numbers?</a></li>
            <li><a href="#arr16">Q-16: Enter two arrays from the user and check they are same or not?</a></li>
            <li><a href="#arr17">Q-17:Merge the two sorted arrays into one array but in sorted order?</a></li>
            <li><a href="#arr18">Q-18:Find the local minima in the array? (An element in an array is a local minima if it less than the element after it, and the element before it)</a></li>
            <li><a href="#arr19">Q-19:Find the local maxima in the array? (An element in an array is a local maxima if it greater than the element after it, and the element before it)</a></li>
            <li><a href="#arr20">Q-20:Trapping Rain Water Problem: Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.</a></li>
                

                <section id="arr1">
                    <p>Q-1:Enter an array from user and display all the value ? </p>
                    <pre>
                    <code >
#include <stdio.h>

    int main() {
    int n, i;
                            
    printf("Enter the number of elements: ");
    scanf("%d", &n);
                            
    int arr[n];
                            
    printf("Enter the elements:\n");
    for (i = 0; i &lt n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
        }
                            
    printf("The elements you entered are: ");
    for (i = 0; i &lt n; i++) {
        printf("%d ", arr[i]);
        }
    printf("\n");
                            
    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
Enter the number of elements: 5
    Enter the elements:
    Enter element 1: 10
    Enter element 2: 20
    Enter element 3: 30
    Enter element 4: 40
    Enter element 5: 50
    The elements you entered are: 10 20 30 40 50

                    </code>
                    </pre>

                </section>
                <section id="arr2">
                    <p>Q-2:Enter an array from user and print the array in reverse order ?</p>
                    <pre>
                        <code>            
#include <stdio.h>

    int main() {
        int n, i;
    
        printf("Enter the number of elements: ");
        scanf("%d", &n);
    
        int arr[n];
    
        printf("Enter the elements:\n");
        for (i = 0; i < n; i++) {
            printf("Enter element %d: ", i + 1);
            scanf("%d", &arr[i]);
        }
    
        printf("The array in reverse order is: ");
        for (i = n - 1; i >= 0; i--) {
            printf("%d ", arr[i]);
        }
        printf("\n");
    
        return 0;
    } 
                        </code>
                        <p>OUTPUT</p>
                    <code>
Enter the number of elements: 5
Enter the elements:
Enter element 1: 10
Enter element 2: 20
Enter element 3: 30
Enter element 4: 40
Enter element 5: 50
The array in reverse order is: 50 40 30 20 10
                    </code>

                        </pre>
    
                </section>
                <section id="arr3">
                    <p>Q-3:Enter an array from user and copy the array into second array ?</p>
                    <pre>
                        <code>
#include <stdio.h>

int main() {
    int n, i;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int firstArray[n], secondArray[n];

    printf("Enter the elements of the first array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &firstArray[i]);
        secondArray[i] = firstArray[i];
    }

    printf("Elements of the second array (copy): ");
    for (i = 0; i < n; i++) {
        printf("%d ", secondArray[i]);
    }
    printf("\n");

    return 0;
}                         
    
    
                        </code>
                        <p>OUTPUT</p>
                    <code>
Enter the number of elements: 4
Enter the elements of the first array:
Enter element 1: 10
Enter element 2: 20
Enter element 3: 30
Enter element 4: 40
Elements of the second array (copy): 10 20 30 40
                    </code>
                        </pre>
    
                </section>
                <section id="arr4">
                    <p>Q-4:Enter an array from user and copy it into another array in reverse order ?</p>
                    <pre>
                        <code>
#include <stdio.h>

int main() {
    int n, i;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int firstArray[n], secondArray[n];

    printf("Enter the elements of the first array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &firstArray[i]);
    }

    printf("Copying the array in reverse order...\n");
    for (i = 0; i < n; i++) {
        secondArray[i] = firstArray[n - 1 - i];
    }

    printf("Elements of the second array (copy in reverse order): ");
    for (i = 0; i < n; i++) {
        printf("%d ", secondArray[i]);
    }
    printf("\n");

    return 0;
}
                        </code>
                        <p>OUTPUT</p>
                    <code>
Enter the number of elements: 5
Enter the elements of the first array:
Enter element 1: 10
Enter element 2: 20
Enter element 3: 30
Enter element 4: 40
Enter element 5: 50
Copying the array in reverse order...
Elements of the second array (copy in reverse order): 50 40 30 20 10                        
                    </code>
                        </pre>
                </section>
                <section id="arr5">
                    <p>Q-5:Enter an array from user and print the number which is even ?</p>
                    <pre>
                        <code>
#include <stdio.h>

int main() {
    int n, i;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("Even numbers in the array are: ");
    for (i = 0; i < n; i++) {
        if (arr[i] % 2 == 0) {
            printf("%d ", arr[i]);
        }
    }
    printf("\n");

    return 0;
}   
                        </code>
                        <p>OUTPUT</p>
                    <code>
Enter the number of elements: 5
Enter the elements of the array:
Enter element 1: 10
Enter element 2: 25
Enter element 3: 12
Enter element 4: 7
Enter element 5: 16
Even numbers in the array are: 10 12 16
                    </code>

                        </pre>
    
                </section>
                <section id="arr6">
                    <p>Q-6:Enter an array from user and print the number which is positive ?</p>
                    <pre>
                        <code>
#include <stdio.h>

int main() {
    int n, i;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("Positive numbers in the array are: ");
    for (i = 0; i < n; i++) {
        if (arr[i] > 0) {
            printf("%d ", arr[i]);
        }
    }
    printf("\n");

    return 0;
}
                        </code>
                        <p>OUTPUT</p>
                    <code>
Enter the number of elements: 6
Enter the elements of the array:
Enter element 1: 10
Enter element 2: -5
Enter element 3: 0
Enter element 4: 12
Enter element 5: -8
Enter element 6: 7
Positive numbers in the array are: 10 12 7
                    </code>

                        </pre>
                </section>
                <section id="arr7">
                    <p>Q-7:Enter an array from user and square all the values of array ?</p>
                    <pre>
                        <code>
#include <stdio.h>

int main() {
    int n, i;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("Square of all values of the array: ");
    for (i = 0; i < n; i++) {
        printf("%d ", arr[i] * arr[i]);
    }
    printf("\n");

    return 0;
}
                        </code>
                        <p>OUTPUT</p>
                    <code>
Enter the number of elements: 4
Enter the elements of the array:
Enter element 1: 5
Enter element 2: -3
Enter element 3: 2
Enter element 4: 8
Square of all values of the array: 25 9 4 64
                    </code>

                        </pre>
    
                </section>
                <section id="arr8">
                    <p>Q-8:Enter an array from user and find maximum and minimum value?</p>
                    <pre>
                        <code>
#include <stdio.h>

int main() {
    int n, i;
    int max, min;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    max = arr[0];
    min = arr[0];

    for (i = 1; i < n; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
        if (arr[i] < min) {
            min = arr[i];
        }
    }

    printf("Maximum value: %d\n", max);
    printf("Minimum value: %d\n", min);

    return 0;
}
                        </code>
                        <p>OUTPUT</p>
                    <code>
Enter the number of elements: 5
Enter the elements of the array:
Enter element 1: 10
Enter element 2: 25
Enter element 3: 7
Enter element 4: 14
Enter element 5: 3
Maximum value: 25
Minimum value: 3
                    </code>
                        </pre>
    
                </section>
                <section id="arr9">
                    <p>Q-9:Enter an array from user and find the k-th smallest value?</p>
                    <pre>
                        <code>
#include <stdio.h>

int main() {
    int n, i, k;
    int temp;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("Enter the value of k: ");
    scanf("%d", &k);

    // Using bubble sort to sort the array
    for (i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }

    printf("The %dth smallest value is: %d\n", k, arr[k - 1]);

    return 0;
}
                        </code>
                        <p>OUTPUT</p>
                    <code>
Enter the number of elements: 6
Enter the elements of the array:
Enter element 1: 10
Enter element 2: 5
Enter element 3: 8
Enter element 4: 3
Enter element 5: 12
Enter element 6: 7
Enter the value of k: 3
The 3th smallest value is: 7
                    </code>
                        </pre>
    
                </section>
                <section id="arr10">
                    <p>-Q-10:Enter an array from user and add all values ?</p>
                    <pre>
                        <code>
   #include <stdio.h>

int main() {
    int n, i, sum = 0;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
        sum += arr[i];
    }

    printf("Sum of all values in the array: %d\n", sum);

    return 0;
}
                        </code>
                        <p>OUTPUT</p>
                    <code>
Enter the number of elements: 4
Enter the elements of the array:
Enter element 1: 5
Enter element 2: 10
Enter element 3: 15
Enter element 4: 20
Sum of all values in the array: 50
                    </code>

                        </pre>
    
                </section>
                <section id="arr11">
                    <p>Q-11:Enter an array from user and find the duplicate values?</p>
                    <pre>
                        <code>
#include <stdio.h>

int main() {
    int n, i, j;
    int count;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("Duplicate values in the array are: ");
    for (i = 0; i < n; i++) {
        count = 0;
        for (j = i + 1; j < n; j++) {
            if (arr[i] == arr[j]) {
                count++;
                break;
            }
        }
        if (count > 0) {
            printf("%d ", arr[i]);
        }
    }
    printf("\n");

    return 0;
}
                        </code>
                        <p>OUTPUT</p>
                    <code>
                        
                    </code>
Enter the number of elements: 8
Enter the elements of the array:
Enter element 1: 4
Enter element 2: 2
Enter element 3: 6
Enter element 4: 8
Enter element 5: 2
Enter element 6: 6
Enter element 7: 4
Enter element 8: 10
Duplicate values in the array are: 4 2 6
                        </pre>
    
                </section>
                <section id="arr12">
                    <p>Q-12:Enter an array from user and remove the duplicate values and fill with zero?</p>
                    <pre>
                        <code>
#include <stdio.h>

int main() {
    int n, i, j;
    int count;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    for (i = 0; i < n - 1; i++) {
        for (j = i + 1; j < n; j++) {
            if (arr[i] == arr[j]) {
                arr[j] = 0;
            }
        }
    }

    printf("Array after removing duplicates and filling with zeros: ");
    for (i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    return 0;
}
                        </code>
                        <p>OUTPUT</p>
                        <code>
Enter the number of elements: 7
Enter the elements of the array:
Enter element 1: 3
Enter element 2: 4
Enter element 3: 5
Enter element 4: 3
Enter element 5: 6
Enter element 6: 4
Enter element 7: 5
Array after removing duplicates and filling with zeros: 3 4 5 0 6 0 0
                        </code>
                        </pre>
    
                </section>
                <section id="arr13">
                    <p>Q-13:Enter an array from user and count the duplicate values?</p>
                    <pre>
                        <code>
#include <stdio.h>

int main() {
    int n, i, j;
    int count, total_count = 0;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    for (i = 0; i < n - 1; i++) {
        count = 0;
        for (j = i + 1; j < n; j++) {
            if (arr[i] == arr[j]) {
                count++;
                break;
            }
        }
        if (count > 0) {
            total_count++;
        }
    }

    printf("Total number of duplicate values in the array: %d\n", total_count);

    return 0;
}  
    
    
                        </code>
                        <p>OUTPUT</p>
                        <code>
Enter the number of elements: 6
Enter the elements of the array:
Enter element 1: 5
Enter element 2: 3
Enter element 3: 5
Enter element 4: 2
Enter element 5: 7
Enter element 6: 3
Total number of duplicate values in the array: 2                            
                        </code>
                        </pre>
    
                </section>
                <section id="arr14">
                    <p>Q-14:Enter an array from user and print all possible combinations of the elements?</p>
                    <pre>
                        <code>

    
    
                        </code>
                        <p>OUTPUT</p>
                        <code>
 
                        </code>
                        </pre>
    
                </section>
                <section id="arr15">
                    <p>Q-15:Enter an array from user and print all the palindrone numbers?</p>
                    <pre>
                        <code>
#include <stdio.h>

int isPalindrome(int num) {
    int reversed = 0;
    int original = num;

    while (num > 0) {
        int remainder = num % 10;
        reversed = reversed * 10 + remainder;
        num /= 10;
    }

    return original == reversed;
}

int main() {
    int n, i;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("Palindrome numbers in the array are: ");
    for (i = 0; i < n; i++) {
        if (isPalindrome(arr[i])) {
            printf("%d ", arr[i]);
        }
    }
    printf("\n");

    return 0;
}
    
    
    
                        </code>
                        <p>OUTPUT</p>
                        <code>
Enter the number of elements: 5
Enter element 1: 121
Enter element 2: 34
Enter element 3: 1551
Enter element 4: 67
Enter element 5: 12321
Palindrome numbers in the array are: 121 1551 12321                            
                        </code>
                        </pre>
    
                </section>
                <section id="arr16">
                    <p>Q-16:Enter two arrays from the user and check they are same or not?</p>
                    <pre>
                        <code>
#include <stdio.h>
#include <stdbool.h>

bool areEqual(int arr1[], int arr2[], int n) {
    for (int i = 0; i < n; i++) {
        if (arr1[i] != arr2[i]) {
            return false;
        }
    }
    return true;
}

int main() {
    int n, i;

    printf("Enter the number of elements in the arrays: ");
    scanf("%d", &n);

    int arr1[n], arr2[n];

    printf("Enter the elements of the first array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr1[i]);
    }

    printf("Enter the elements of the second array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr2[i]);
    }

    if (areEqual(arr1, arr2, n)) {
        printf("The arrays are the same.\n");
    } else {
        printf("The arrays are not the same.\n");
    }

    return 0;
}   
                        </code>
                        <p>OUTPUT</p>
                        <code>
Enter the number of elements in the arrays: 4
Enter the elements of the first array:
Enter element 1: 2
Enter element 2: 5
Enter element 3: 3
Enter element 4: 8
Enter the elements of the second array:
Enter element 1: 2
Enter element 2: 5
Enter element 3: 3
Enter element 4: 8
The arrays are the same.                           
                        </code>
                        </pre>
    
                </section>
                <section id="arr17">
                    <p>-Q-17:Merge the two sorted arrays into one array but in sorted order?</p>
                    <pre>
                        <code>
    #include <stdio.h>

int main() {
    int n, m, i, j, k;

    printf("Enter the number of elements in the first array: ");
    scanf("%d", &n);

    int arr1[n];

    printf("Enter the elements of the first array in sorted order:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr1[i]);
    }

    printf("Enter the number of elements in the second array: ");
    scanf("%d", &m);

    int arr2[m];

    printf("Enter the elements of the second array in sorted order:\n");
    for (i = 0; i < m; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr2[i]);
    }

    int merged[n + m];
    i = 0,j = 0,k = 0;

    while (i < n && j < m) {
        if (arr1[i] < arr2[j]) {
            merged[k] = arr1[i];
            i++;
        } else {
            merged[k] = arr2[j];
            j++;
        }
        k++;
    }

    while (i < n) {
        merged[k] = arr1[i];
        i++;
        k++;
    }

    while (j < m) {
        merged[k] = arr2[j];
        j++;
        k++;
    }

    printf("Merged array in sorted order: ");
    for (i = 0; i < n + m; i++) {
        printf("%d ", merged[i]);
    }
    printf("\n");

    return 0;
}
                        </code>
Enter the number of elements in the first array: 4
Enter the elements of the first array in sorted order:
Enter element 1: 2
Enter element 2: 4
Enter element 3: 6
Enter element 4: 8
Enter the number of elements in the second array: 3
Enter the elements of the second array in sorted order:
Enter element 1: 1
Enter element 2: 3
Enter element 3: 7
Merged array in sorted order: 1 2 3 4 6 7 8
                        </pre>
                    
                </section>
                <section id="arr18">
                    <p>Q-18:Find the local minima in the array? (An element in an array is a local minima if it less than the element after it, and the element before it)</p>
                    <pre>
                        <code>
   #include <stdio.h>

void findLocalMinima(int arr[], int n) {
    if (n == 0) {
        return;
    }

    if (arr[0] < arr[1]) {
        printf("%d ", arr[0]);
    }

    for (int i = 1; i < n - 1; i++) {
        if (arr[i] < arr[i - 1] && arr[i] < arr[i + 1]) {
            printf("%d ", arr[i]);
        }
    }

    if (arr[n - 1] < arr[n - 2]) {
        printf("%d ", arr[n - 1]);
    }
}

int main() {
    int n, i;

    printf("Enter the number of elements in the array: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("Local minima in the array: ");
    findLocalMinima(arr, n);
    printf("\n");

    return 0;
}
                        </code>
                        <p>OUTPUT</p>
                        <code>
Enter the number of elements in the array: 7
Enter the elements of the array:
Enter element 1: 3
Enter element 2: 2
Enter element 3: 4
Enter element 4: 1
Enter element 5: 6
Enter element 6: 5
Enter element 7: 3
Local minima in the array: 2 1 3                         
                        </code>
                        </pre>
                </section>
                <section id="arr19">
                    <p>Q-19:Find the local maxima in the array? (An element in an array is a local maxima if it greater than the element after it, and the element before it)</p>
                    <pre>
                        <code>
#include <stdio.h>

void findLocalMaxima(int arr[], int n) {
    if (n == 0) {
        return;
    }

    if (arr[0] > arr[1]) {
        printf("%d ", arr[0]);
    }

    for (int i = 1; i &lt n - 1; i++) {
        if (arr[i] > arr[i - 1] && arr[i] > arr[i + 1]) {
            printf("%d ", arr[i]);
        }
    }

    if (arr[n - 1] > arr[n - 2]) {
        printf("%d ", arr[n - 1]);
    }
}

int main() {
    int n, i;

    printf("Enter the number of elements in the array: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i&lt n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("Local maxima in the array: ");
    findLocalMaxima(arr, n);
    printf("\n");

    return 0;
}
                        </code>
                        <p>OUTPUT</p>
                        <code>
   Enter the number of elements in the array: 6
Enter the elements of the array:
Enter element 1: 2
Enter element 2: 4
Enter element 3: 3
Enter element 4: 6
Enter element 5: 5
Enter element 6: 1
Local maxima in the array: 4 6 5                         
                        </code>
                        </pre>
                </section>
                <section id="arr20">
                    <p>Q-20:Trapping Rain Water Problem</p>
                    <pre>
                        <code>
 
    
    
                        </code>
                        <p>OUTPUT</p>
                        <code>
                            
                        </code>
                        </pre>
                </section>
        </ul>
    </section>

    <section id="2darrays">
        <h2>2D-ARRAY PROBLEMS</h2>
        <ul>
        <li><a href="#2darr1">Q-1:Enter a matrix of 4 rows and 2 columns from the user display it in matrix format?</a></li>
        <li><a href="#2darr2">Q-2:Enter two Matrices from user, add the matrices and display the answer?</a></li>
        <li><a href="#2darr3">Q-3:Enter two Matrices from user, subtract the matrices and display the answer?</a></li>
        <li><a href="#2darr4">Q-4:Enter two Matrices from user, multiply the matrices and display the answer?</a></li>
        <li><a href="#2darr5">Q-5:Enter a Matrix from user, copy it in another matrix of same size?</a></li>
        <li><a href="#2darr6">Q-6:Enter the Matrix from user, multiply it with a scalar value and display the answer?</a></li>
        <li><a href="#2darr7">Q-7:Create a tic tac toe game using 2D Arrays.</a></li>

        <section id="2darr1">
            <p>Q-1:Enter a matrix of 4 rows and 2 columns from the user display it in matrix format?</p>
            <pre>
            <code >
#include<stdio.h>
void main()
{
    int rows=4,cols=2;
    int arr1[rows][cols],arr2[rows][cols],i,j;
    printf("Enter the matrix\n");
    for(i=0;i &lt rows;i++){
        for(j=0;j &lt cols;j++){
            printf("Enter element at matrix[%d][%d]",i,j);
            scanf("%d",&arr1[i][j]);
        }
    }
        for(j=0;j &lt cols;j++){
            arr2[i][j]=arr1[i][j];
        }
    }

    printf("Elements in copied array\n");
    for(i=0;i &lt rows;i++){
        for(j=0;j &lt cols;j++){
            printf("%d ",arr2[i][j]);

        }
        printf("\n");
    }
    
} 
            </code>
            <p>OUTPUT</p>
            <code>
Enter the matrix
Enter element at matrix[0][0]1
Enter element at matrix[0][1]1
Enter element at matrix[1][0]2
Enter element at matrix[1][1]2
Enter element at matrix[2][0]3
Enter element at matrix[2][1]3
Enter element at matrix[3][0]4
Enter element at matrix[3][1]4
Elements in copied array
1 1 
2 2 
3 3 
4 4
            </code>
            </pre>

            </section>

            <section id="2darr2">
                <p>Q-2:Enter two Matrices from user, add the matrices and display the answer?</p>
                <pre>
                <code >
#include<stdio.h>
void main(){
    int arr1[3][3],arr2[3][3],res[3][3],i,j;
    printf("Enter the first matrix");
    for(i=0;i &lt 3;i++){
        for(j=0;j &lt 3;j++){
            printf("Enter element at matrix1[%d][%d]",i,j);
            scanf("%d",&arr1[i][j]);
        }
    }
    printf("Enter the second matrix");
    for(i=0;i &lt 3;i++){
        for(j=0;j &lt 3;j++){
            printf("Enter element at matrix2[%d][%d]",i,j);
            scanf("%d",&arr2[i][j]);
        }
    }
    for(i=0;i &lt 3;i++){
        for(j=0;j &lt 3;j++){
            res[i][j]=arr1[i][j]+arr2[i][j];
        }
    }
    for(i=0;i &lt 3;i++){
        for(j=0;j &lt 3;j++){
            printf("%d  ",res[i][j]);
        }
        printf("\n");
    }
}
                </code>
                <p>OUTPUT</p>
                <code>
Enter the first matrix
Enter element at matrix1[0][0]: 1
Enter element at matrix1[0][1]: 2
Enter element at matrix1[0][2]: 3
Enter element at matrix1[1][0]: 4
Enter element at matrix1[1][1]: 5
Enter element at matrix1[1][2]: 6
Enter element at matrix1[2][0]: 7
Enter element at matrix1[2][1]: 8
Enter element at matrix1[2][2]: 9
Enter the second matrix
Enter element at matrix2[0][0]: 9
Enter element at matrix2[0][1]: 8
Enter element at matrix2[0][2]: 7
Enter element at matrix2[1][0]: 6
Enter element at matrix2[1][1]: 5
Enter element at matrix2[1][2]: 4
Enter element at matrix2[2][0]: 3
Enter element at matrix2[2][1]: 2
Enter element at matrix2[2][2]: 1
Resultant matrix after addition is:
10  10  10  
10  10  10  
10  10  10
                </code>
                </pre>

                </section>

                <section id="2darr3">
                    <p>Q-3:Enter two Matrices from user, subtract the matrices and display the answer?</p>
                    <pre>
                    <code >
#include<stdio.h>
void main(){
    
    int arr1[3][3],arr2[3][3],res[3][3],i,j;
    printf("Enter the first matrix");
    for(i=0;i &lt 3;i++){
        for(j=0;j &lt 3;j++){
            printf("Enter element at matrix1[%d][%d]",i,j);
            scanf("%d",&arr1[i][j]);
        }
    }
    printf("Enter the second matrix");
    for(i=0;i &lt 3;i++){
        for(j=0;j &lt 3;j++){
            printf("Enter element at matrix2[%d][%d]",i,j);
            scanf("%d",&arr2[i][j]);
        }
    }
    for(i=0;i &lt 3;i++){
        for(j=0;j &lt 3;j++){
            res[i][j]=arr1[i][j]-arr2[i][j];
        }
    }
    for(i=0;i &lt 3;i++){
        for(j=0;j &lt 3;j++){
            printf("%d  ",res[i][j]);
        }
        printf("\n");
    }
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
Enter the first matrix:
Enter element at matrix1[0][0]: 4
Enter element at matrix1[0][1]: 6
Enter element at matrix1[0][2]: 8
Enter element at matrix1[1][0]: 2
Enter element at matrix1[1][1]: 3
Enter element at matrix1[1][2]: 5
Enter element at matrix1[2][0]: 9
Enter element at matrix1[2][1]: 7
Enter element at matrix1[2][2]: 1
Enter the second matrix:
Enter element at matrix2[0][0]: 1
Enter element at matrix2[0][1]: 2
Enter element at matrix2[0][2]: 3
Enter element at matrix2[1][0]: 4
Enter element at matrix2[1][1]: 5
Enter element at matrix2[1][2]: 6
Enter element at matrix2[2][0]: 7
Enter element at matrix2[2][1]: 8
Enter element at matrix2[2][2]: 9
Resultant matrix after subtraction is:
3  4  5  
-2  -2  -1  
2  -1  -8
                    </code>
                    </pre>

                    </section>

                    <section id="2darr4">
                    <p>Q-4:Enter two Matrices from user, multiply the matrices and display the answer?</p>
                    <pre>
                    <code >
#include<stdio.h>
void main(){
int arr1[3][3],arr2[3][3],res[3][3]={0},i,j,k,size;
    printf("Enter the number of rows and columns");
    scanf("%d",&size);
    printf("Enter the first matrix");
    for(i=0;i &lt size;i++){
        for(j=0;j &lt size;j++){
            printf("Enter element at matrix1[%d][%d]",i,j);
            scanf("%d",&arr1[i][j]);
        }
    }
    printf("Enter the second matrix");
    for(i=0;i &lt size;i++){
        for(j=0;j &lt size;j++){
            printf("Enter element at matrix1[%d][%d]",i,j);
            scanf("%d",&arr2[i][j]);
        }
    }
     for ( i = 0; i &lt size; i++)
    {
        for(j=0;j &lt size;j++){
           
            for(k=0;k &lt size;k++){
                res[i][j]+=arr1[i][k] * arr2[k][j];
            }
        }
    }
    printf("Product of matrices\n");
    for(i=0;i &lt size;i++){
        for(j=0;j &lt size;j++){
            printf("%d ",res[i][j]);    
        }
        printf("\n");
    }

}
                    </code>
                    <p>OUTPUT</p>
                    <code>
Enter elements of the first matrix:
Enter element at matrix1[0][0]: 1
Enter element at matrix1[0][1]: 2
Enter element at matrix1[0][2]: 3
Enter element at matrix1[1][0]: 4
Enter element at matrix1[1][1]: 5
Enter element at matrix1[1][2]: 6
Enter element at matrix1[2][0]: 7
Enter element at matrix1[2][1]: 8
Enter element at matrix1[2][2]: 9
Enter elements of the second matrix:
Enter element at matrix2[0][0]: 9
Enter element at matrix2[0][1]: 8
Enter element at matrix2[0][2]: 7
Enter element at matrix2[1][0]: 6
Enter element at matrix2[1][1]: 5
Enter element at matrix2[1][2]: 4
Enter element at matrix2[2][0]: 3
Enter element at matrix2[2][1]: 2
Enter element at matrix2[2][2]: 1
Product of the matrices is:
30  24  18 
84  69  54 
138  114  90
                    </code>
                    </pre>

                    </section>

                    <section id="2darr5">
                        <p>Q-5:Enter a Matrix from user, copy it in another matrix of same size?</p>
                        <pre>
                        <code >
   #include<stdio.h>
void main()
{
    int rows,cols;
    printf("Enter the no. of rows");
    scanf("%d",&rows);
    printf("Enter the no. of cols");
    scanf("%d",&cols);
    int arr1[rows][cols],arr2[rows][cols],i,j;
    printf("Enter the matrix");
    for(i=0;i &lt rows;i++){
        for(j=0;j &lt cols;j++){
            printf("Enter element at matrix[%d][%d]",i,j);
            scanf("%d",&arr1[i][j]);
        }
    }
    for(i=0;i &lt rows;i++){
        for(j=0;j &lt cols;j++){
            arr2[i][j]=arr1[i][j];
        }
    }
    printf("Elements in copied array\n");
    for(i=0;i &lt rows;i++){
        for(j=0;j &lt cols;j++){
            printf("%d ",arr2[i][j]);

        }
        printf("\n");
    }
    
}
                        </code>
                        <p>OUTPUT</p>
                        <code>
Enter the no. of rows2
Enter the no. of cols3
Enter the matrixEnter element at matrix[0][0]1
Enter element at matrix[0][1]2
Enter element at matrix[0][2]3
Enter element at matrix[1][0]4
Enter element at matrix[1][1]5
Enter element at matrix[1][2]6
Elements in copied array
1 2 3 
4 5 6  
                        </code>
                        </pre>
    
                        </section>

                        <section id="2darr6">
                            <p>Q-6:Enter the Matrix from user, multiply it with a scalar value and display the answer?</p>
                            <pre>
                            <code >
#include<stdio.h>
void main(){
    int rows=4,cols=2;
    printf("Enter the number of rows ");
    scanf("%d",&rows);
    printf("Enter the number of columns");
    scanf("%d",&cols);
    int arr1[rows][cols],res[rows][cols],i,j,scalar;
    printf("Enter the scalar value");
    scanf("%d",&scalar);
    printf("Enter the matrix\n");
    for(i=0;i &lt rows;i++){
        for(j=0;j &lt cols;j++){
            printf("Enter element at matrix[%d][%d]",i,j);
            scanf("%d",&arr1[i][j]);
        }
    }
    for(i=0;i &lt rows;i++){
        for(j=0;j &lt cols;j++){
            res[i][j]=arr1[i][j]*scalar;
        }
    }
    for(i=0;i &lt rows;i++){
        for(j=0;j &lt cols;j++){
            printf("%d ",res[i][j]);
        }
        printf("\n");
    }
}        
                            </code>
                            <p>OUTPUT</p>
                            <code>
Enter the number of rows 2
Enter the number of columns2
Enter the scalar value3
Enter the matrix
Enter element at matrix[0][0]1
Enter element at matrix[0][1]2
Enter element at matrix[1][0]3
Enter element at matrix[1][1]1
3 6 
9 3       
                            </code>
                            </pre>
        
                            </section>

                            <section id="2darr7">
                                <p>Q-7:Create a tic tac toe game using 2D Arrays.</p>
                                <pre>
                                <code >
            
                                </code>
                                <p>OUTPUT</p>
                                <code>
            
                                </code>
                                </pre>
            
                                </section>

        </ul>
        </section>

    <section id="string">
        <h2>STRING PROBLEMS</h2>
        <ul>
            <li><a href="#st1">Q-1:Convert in uppercase ?</a></li>
            <li><a href="#st2">Q-2:Convert into lowercase ?</a></li>
            <li><a href="#st3">Q-3:Convert into sentence case ?</a></li>
            <li><a href="#st4">Q-4:Convert into title case ?</a></li>
            <li><a href="#st5">Q-5:Convert into toggle case ?</a></li>
            <li><a href="#st6">Q-6:Final length of the string ?</a></li>
            <li><a href="#st7">Q-7:Compare those string ?</a></li>
            <li><a href="#st8">Q-8:Concatenate the string ?</a></li>
            <li><a href="#st9">Q-9:Copy that string into another string ?</a></li>
            <li><a href="#st10">Q-10:Enter bound number and print character on that bound ?</a></li>
            <li><a href="#st11">Q-11:Check its palindrome or not?</a></li>
            <li><a href="#st12">Q-12:Print each character in new line ?</a></li>
            <li><a href="#st13">Q-13:Copy reverse order into another string ?</a></li>
            <li><a href="#st14">Q-14:ENTER THE STRING FROM THE USER AND PRINT THE DIFFERENCE OF ASCII VALUE OF EACH CHARACTER ?</a></li>
            <li><a href="#st15">Q-15:ENTER THE STRING FROM THE USER, ENTER A CHARACTER ALSO AND SEARCH THE CHARACTER IN THE STRING?</a></li>
            <li><a href="#st16">Q-16:ENTER THE STRING FROM THE USER, ALSO ENTER A CHARACTER AND PRINT THE INDEX OF THE CHARACTER IF IT IS EXIST IN THE STRING ELSE PRINT -1.</a></li>
            <li><a href="#st17">Q-17:ENTER THE STRING FROM THE USER, AND COUNT THE NUMBER OF VOWELS.</a></li>
            <li><a href="#st18">Q-18:ENTER THE STRING FROM THE USER AND CONVERT INTO AN INTEGER VALUE?</a></li>
            <li><a href="#st19">Q-19:ENTER THE STRING FROM THE USER AND CONVERT INTO A FLOAT VALUE?</a></li>
            <li><a href="#st20">Q-20:ENTER THE STRING FROM THE USER AND COUNT THE NUMBER OF CHARACTERS, WORDS, SPACES AND LINES</a></li>
            <li><a href="#st21">Q-21:PRINT ALL THE PERMUTATION OF A STRING I.E. "ABCDE".</a></li>
            <li><a href="#st22">Q-22:ENTER THE STRING FROM THE USER, SORT THE STRING IN ASCENDING ORDER AND PRINT IT.</a></li>
            <li><a href="#st23">Q-23:ENTER A SENTENCE FROM USER AND THEN ENTER THE WORD AND COUNT THE OCCURENCE OF THAT WORD IN THE SENTENCE.</a></li>
            <li><a href="#st24">Q-24:ENTER A SENTENCE FROM USER AND THEN ENTER THE WORD AND REPLACE THAT WORD BY ANOTHER WORD.</a></li>
            <li><a href="#st25">Q-25:ENTER THE STRING FROM THE USER AND TRIM/ ELIMINATE THE SPACES FROM BOTH ENDS (IF ANY).</a></li>
            <li><a href="#st26">Q-26:ENTER THE STRING FROM USER AND SPLITS THE FIRST WORD AND SECOND WORD AND RETURN THE START INDEX OF THE SECOND WORD.</a></li>
            <li><a href="#st27">Q-27:DISPLAY THE STRING ON THE OUTPUT SCREEN BUT ASK THE TEXT ALIGNMENT OPTION GIVEN BY THE USER (1 FOR LEFT, 2 FOR CENTER, 3 RIGHT)</a></li>
            <li><a href="#st28">Q-28:CREATE A DICTIONARY HAVING 10 WORDS AND THEIR MEANING WITH FOLLOWING OPERATIONS. [CREATE, DELETE, SEARCH].</a></li>
            <li><a href="#st29">Q-29:ENTER THE STRING FROM USER AND CONVERT CHARACTERS INTO THEIR ASCII VALUES IN THE INTEGER ARRAY. [FOR EXAMPLE TAKE 10 CHARACTERS]</a></li>
        <section id="st1">
            <p>Q-1:ENTER THE STRING FROM USER AND CONVERT IN UPPERCASE ?</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
void changeInUpper(char * str,int size){
    for(int i=0;i &lt size;i++){
        if(str[i]>='a' && str[i] &lt='z'){
            str[i]=str[i]-32;
        }
    }
}
void main(){
    char str[10];
    printf("Enter the string - \n");
    gets(str);
    changeInUpper(str,strlen(str));
    printf("After changing in Uppercase - %s",str);

}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
hello world
After changing in Uppercase - HELLO WORLD
            </code>
            </pre>

            </section>
        <section id="st2">
            <p>Q-2:ENTER THE STRING FROM USER AND CONVERT IN LOWERCASE ?</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
void changeInLower(char * str,int size){
    for(int i=0;i &lt size;i++){
        if(str[i]>='A' && str[i] &lt ='Z'){
            str[i]=str[i]+32;
        }
    }
}
void main(){
    char str[10];
    printf("Enter the string - \n");
    gets(str);
    changeInLower(str,strlen(str));
    printf("After changing in lowercase - %s",str);

}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
Hello WORLD
After changing in lowercase - hello world
            </code>
            </pre>

            </section>
        <section id="st3">
            <p>Q-3:ENTER THE STRING FROM USER AND CONVERT INTO SENTENCE CASE ?</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
void changeInSentenceCase(char * str,int size){
    if(str[0]>='a' && str[0] &lt='z'){
            str[0]=str[0]-32;
        }
    for(int i=1;i &lt size;i++){
        if(str[i]>='A' && str[i] &lt='Z'){
            str[i]=str[i]+32;
        }
    }
}
void main(){
    char str[10];
    printf("Enter the string - \n");
    gets(str);
    changeInSentenceCase(str,strlen(str));
    printf("After changing in Sentence case - %s",str);

}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
This is a SentENCE aS INpUT.      
After changing in Sentence case - This is a sentence as input
            </code>
            </pre>

            </section>
        <section id="st4">
            <p>Q-4:</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
void changeInTitleCase(char * str,int size){
    if(str[0]>='a' && str[0]&lt='z'){
            str[0]=str[0]-32;
        }
    for(int i=1;i &lt size;i++){
        if(str[i-1]==' '){
            if(str[i]>='a' && str[i]&lt='z'){
                str[i]=str[i]-32;
            }
        }
        else{
            if(str[i]>='A' && str[i]&lt='Z'){
                str[i]=str[i]+32;
            }
        }
    }
}
void main(){
    char str[10];
    printf("Enter the string - \n");
    gets(str);
    changeInTitleCase(str,strlen(str));
    printf("After changing in Sentence case - %s",str);

}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
coVERT thiS to TITLEcase.
After changing in Sentence case - Covert This To Titlecase.
            </code>
            </pre>

            </section>
        <section id="st5">
            <p>Q-5:</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
void changeInTitleCase(char * str,int size){
    if(str[0]>='A' && str[0]&lt='Z'){
            str[0]=str[0]+32;
        }
    for(int i=1;i &lt size;i++){
        if(str[i-1]==' '){
            if(str[i]>='A' && str[i]&lt='Z'){
                str[i]=str[i]+32;
            }
        }
        else{
            if(str[i]>='a' && str[i]&lt='z'){
                str[i]=str[i]-32;
            }
        }
    }
}
void main(){
    char str[10];
    printf("Enter the string - \n");
    gets(str);
    changeInTitleCase(str,strlen(str));
    printf("After changing in Sentence case - %s",str);

}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
Covert this to toggle case
After changing in Sentence case - cOVERT tHIS tO tOGGLE cASE
            </code>
            </pre>

            </section>
        <section id="st6">
            <p>Q-6:</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
int finalLength(char * str){
    int i=0,len = 0;
    while(str[i]!='\0'){
        len++;
        i++;
    }
    return len;
}
void main(){
    char str[10];
    printf("Enter the string - \n");
    gets(str);   
    printf("Final length of the string is - %d",finalLength(str));

}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
hello world
Final length of the string is - 11
            </code>
            </pre>

            </section>
        <section id="st7">
            <p>Q-7:</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
int finalLength(char * str){
    int i=0,len = 0;
    while(str[i]!='\0'){
        len++;
        i++;
    }
    return len;
}
int compareString(char * str,char * str2){
    int i=0;
    if(finalLength(str)!=finalLength(str2))
        return 0;
    while(str[i]){
        if(str[i]!=str2[i]){
            return 0;
        }
        i++;
    }
    return 1;
}
void main(){
    char str[20];
    char str2[20];
    printf("Enter the string1 - \n");
    gets(str);   
    printf("Enter the string2 - \n");
    gets(str2);   
    if(compareString(str,str2))
        printf("Strings are equal");
    else
        printf("Strings are not equal");
}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string1 - 
hello
Enter the string2 - 
world
Strings are not equal
            </code>
            </pre>

            </section>
        <section id="st8">
            <p>Q-8:</p>
            <pre>
            <code >
#include<stdio.h>
#include<stdlib.h>
int finalLength(char * str){
    int i=0,len = 0;
    while(str[i]!='\0'){
        len++;
        i++;
    }
    return len;
}
char * concatenateString(char * str,char * str2){
    int size = finalLength(str)+ finalLength(str2);
    char * strcat= (char *)malloc(size * sizeof(char));
    int i=0;
    while(str[i]){
        strcat[i]=str[i];
        i++;
    }
    int j=0;
    while(str2[j]){
        strcat[i]=str2[j];
        j++;
        i++;
    }
    return strcat;
}
void main(){
    char str[20];
    char str2[20];
    char * str3;
    printf("Enter the string1 - \n");
    gets(str);   
    printf("Enter the string2 - \n");
    gets(str2);   
    str3 = concatenateString(str,str2);
    printf("%s",str3);
    free(str3);
}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string1 - 
hello 
Enter the string2 -
world
hello world
            </code>
            </pre>

            </section>
        <section id="st9">
            <p>Q-9:</p>
            <pre>
            <code >
#include<stdio.h>
#include<stdlib.h>
int finalLength(char * str){
    int i=0,len = 0;
    while(str[i]!='\0'){
        len++;
        i++;
    }
    return len;
}
char * copyString(char * str){
    int size = finalLength(str)+1;
    char * strcopied= (char *)malloc(size * sizeof(char));
    int i=0;
    while(str[i]){
        strcopied[i]=str[i];
        i++;
    }
    strcopied[i]='\0';
    return strcopied;
}
void main(){
    char str[20];
    char * str2;
    printf("Enter the string - \n");
    gets(str);    
    str2 = copyString(str);
    printf("Original string - %s\n",str);
    printf("Copied string - %s",str2);
    free(str2);
} 
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
helloo world 
Original string - helloo world
Copied string - helloo world
            </code>
            </pre>

            </section>
        <section id="st10">
            <p>Q-10:</p>
            <pre>
            <code >
#include<stdio.h>
#include<stdlib.h>

void main(){
    char str[20];
    int index;
    printf("Enter the string - \n");
    gets(str); 
    printf("Enter the index number - \n");
    scanf("%d",&index);
    printf("Character at index %d is %c.",index,str[index]);
}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
hello world
Enter the index number -
6
Character at index 6 is w.
            </code>
            </pre>

            </section>
        <section id="st11">
            <p>Q-11:Check its palindrome or not?</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
int finalLength(char * str){
    int i=0,len = 0;
    while(str[i]!='\0'){
        len++;
        i++;
    }
    return len;
}
int checkPalindrome(char * str){
    int size = finalLength(str);
    for(int i=0;i&lt(size+1)/2;i++){
        if(str[i]!=str[size - i -1])
            return 0;
    }
    return 1;
}
void main(){
    char str[20];
    char * str2;
    printf("Enter the string - \n");
    gets(str);    
    if(checkPalindrome(str))
        printf("%s is pallindrome.",str);
    else
        printf("%s is not pallindrome.",str);
}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
level
level is pallindrome
            </code>
            </pre>

            </section>
        <section id="st12">
            <p>Q-12:Print each character in new line ?</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
char * printNewlines(char * str){
    int i=0;
    char * str2 = (char *)malloc(strlen(str)*sizeof(char));
    strcpy(str2,str);
    while(str2[i]){
        if(str2[i]==' ')
            str2[i]='\n';
        i++;
    }
    return str2;
}
void main(){
    char str[20];
    char * str2;
    printf("Enter the string - \n");
    gets(str);    
    str2= printNewlines(str);
    printf("%s",str2);
}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
this is a string
this
is
a
string
            </code>
            </pre>

            </section>
        <section id="st13">
            <p>Q-13:Copy reverse order into another string ?</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
char * copyReverse(char * str){
    int i= strlen(str) - 1,j=0;
    char * str2 = (char *)malloc(strlen(str)*sizeof(char));
    for(;i>=0;i--){
        str2[j++]= str[i];
    }
    str2[j]='\0';
    return str2;
}
void main(){
    char str[20];
    char * str2;
    printf("Enter the string - \n");
    gets(str);    
    str2= copyReverse(str);
    printf("%s",str2);
    free(str2);
}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
hello world
dlrow olle
            </code>
            </pre>

            </section>
        <section id="st14">
            <p>Q-14:ENTER THE STRING FROM THE USER AND PRINT THE DIFFERENCE OF ASCII VALUE OF EACH CHARACTER ?</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
int * diffOfAsciiValues(char * str1,char * str2){
    if(strlen(str1)!=strlen(str2))
        return NULL;
    int size= strlen(str1) + strlen(str2);
    int * str = (int *)malloc(size*sizeof(int));
    for(int i=0;i&ltstrlen(str1);i++){
        str[i]= str1[i] - str2[i];
    }
    return str;
}
void main(){
    char str1[20];
    char str2[20];
    int * str;
    printf("Enter the string1 - \n");
    gets(str1);    
    printf("Enter the string2 - \n");
    gets(str2);    
    str= diffOfAsciiValues(str1,str2);
    for(int i=0;i&ltstrlen(str1);i++){
        printf("%d ",str[i]);
    }
    free(str);
}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string1 - 
hello
Enter the string2 - 
world
-15 -10 -6 0 11
            </code>
            </pre>

            </section>
        <section id="st15">
            <p>Q-15:ENTER THE STRING FROM THE USER, ENTER A CHARACTER ALSO AND SEARCH THE CHARACTER IN THE STRING?</p>
            <pre>
            <code >

          #include<stdio.h>
#include<string.h>
#include<stdlib.h>
int findChar(char * str1,char x){
    int i=0;
    while(str1[i]){
        if(str1[i]==x)
            return i+1;
            i++;
    }
    return 0;
}
void main(){
    char str1[20];
    char str2;
    printf("Enter the string - \n");
    gets(str1);    
    printf("Enter the character - \n");
    scanf("%c",&str2);   
    int pos = findChar(str1,str2);
    if(pos)
        printf("%c is present at position %d",str2,pos);
    else
        printf("%c is not found");
        
}  </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
hello world
Enter the character -
o
o is present at position 5
            </code>
            </pre>

            </section>
        <section id="st16">
            <p>Q-16:ENTER THE STRING FROM THE USER, ALSO ENTER A CHARACTER AND PRINT THE INDEX OF THE CHARACTER IF IT IS EXIST IN THE STRING ELSE PRINT -1.</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
int findChar(char * str1,char x){
    int i=0;
    while(str1[i]){
        if(str1[i]==x)
            return i+1;
            i++;
    }
    return -1;
}
void main(){
    char str1[20];
    char str2;
    printf("Enter the string - \n");
    gets(str1);    
    printf("Enter the character - \n");
    scanf("%c",&str2);   
    int pos = findChar(str1,str2);
    if(pos!=-1)
        printf("%c is present at index %d",str2,pos);
    else
        printf("%d",pos);
        
} 
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
Hello world.
Enter the character - 
d
d is present at index 11
            </code>
            </pre>

            </section>
        <section id="st17">
            <p>Q-17:ENTER THE STRING FROM THE USER, AND COUNT THE NUMBER OF VOWELS.</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
int countVowels(char * str1){
    int i=0,count=0;
    while(str1[i]){
        if(str1[i]=='a'||str1[i]=='e'||str1[i]=='i'||str1[i]=='o'||str1[i]=='u'||str1[i]=='A'||str1[i]=='E'||str1[i]=='I'||str1[i]=='O'||str1[i]=='U')
            count++;
            i++;
    }
    return count;
}
void main(){
    char str1[20];char str2;
    printf("Enter the string - \n");
    gets(str1);    
    printf("No. of vowels = %d",countVowels(str1));  
    
        
} 
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
THis is a sentence. 
No. of vowels = 6
            </code>
            </pre>

            </section>
        <section id="st18">
            <p>Q-18:ENTER THE STRING FROM THE USER AND CONVERT INTO AN INTEGER VALUE?</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
void printStringInInt(char * arr){
    int i=0;
while(arr[i]){
    printf("%d ",arr[i++]);
}
}

void main(){
    char str[30]; 
    printf("Enter the string.\n");
    gets(str);
    printStringInInt(str);
}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string.
this is a string.
116 104 105 115 32 105 115 32 97 32 115 116 114 105 110 103 46
            </code>
            </pre>

            </section>
        <section id="st20">
            <p>Q-20:ENTER THE STRING FROM THE USER AND COUNT THE NUMBER OF CHARACTERS, WORDS, SPACES AND LINES</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
int countchar(char * str1){
    int i=0,countchar=0;
    while(str1[i]){
        if(str1[i]>='a' && str1[i]&lt='z'|| str1[i]>='A'&& str1[i]&lt='Z')
            countchar++;
    i++;
    }
    return countchar;
}
int countspaces(char * str1){
    int i=0,spaces=0;
    while(str1[i]){
        if(str1[i]==' ')
            spaces++;
    i++;
    }
    return spaces;
}
int countlines(char * str1){
    int i=0,countlines=0;
    while(str1[i]){
        if(str1[i]=='.')
            countlines++;
    i++;
    }
    return countlines;
}
void main(){
    char str1[20];char str2;
    printf("Enter the string - \n");
    gets(str1);    
    printf("No. of character = %d\n",countchar(str1));  
    printf("No. of words = %d\n",countspaces(str1)+1);  
    printf("No. of spaces = %d\n",countspaces(str1));  
    printf("No. of lines = %d\n",countlines(str1));          
}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string - 
This is first line.This is second line. 
No. of character = 31
No. of words = 7
No. of spaces = 6
No. of lines = 2
            </code>
            </pre>

            </section>
        <section id="st21">
            <p>Q-21:PRINT ALL THE PERMUTATION OF A STRING I.E. "ABCDE".</p>
            <pre>
            <code >
#include <stdio.h>
#include <string.h>

void swap(char *x, char *y) {
    char temp = *x;
    *x = *y;
    *y = temp;
}

void permute(char *str, int l, int r) {
    if (l == r) {
        printf("%s\n", str);
    } else {
        for (int i = l; i &lt= r; i++) {
            swap((str + l), (str + i));
            permute(str, l + 1, r);
            swap((str + l), (str + i)); 
        }
    }
}

int main() {
    char str[] = "abcde";
    int n = strlen(str);
    printf("Printing all combinations-\n");
    permute(str, 0, n - 1);
    return 0;
}
            </code>
            <p>OUTPUT</p>
            <code>
Printing all combinations-
abcde
abced
abdce
abdec
abedc
abecd
acbde
acbed
acdbe
acdeb
acedb
acebd
adcbe
adceb
adbce
adbec
adebc
adecb
aecdb
aecbd
aedcb
aedbc
aebdc
aebcd
bacde
baced
badce
badec
baedc
baecd
bcade
bcaed
bcdae
bcdea
bceda
bcead
bdcae
bdcea
bdace
bdaec
bdeac
bdeca
becda
becad
bedca
bedac
beadc
beacd
cbade
cbaed
cbdae
cbdea
cbeda
cbead
cabde
cabed
cadbe
cadeb
caedb
caebd
cdabe
cdaeb
cdbae
cdbea
cdeba
cdeab
ceadb
ceabd
cedab
cedba
cebda
cebad
dbcae
dbcea
dbace
dbaec
dbeac
dbeca
dcbae
dcbea
dcabe
dcaeb
dceab
dceba
dacbe
daceb
dabce
dabec
daebc
daecb
decab
decba
deacb
deabc
debac
debca
ebcda
ebcad
ebdca
ebdac
ebadc
ebacd
ecbda
ecbad
ecdba
ecdab
ecadb
ecabd
edcba
edcab
edbca
edbac
edabc
edacb
eacdb
eacbd
eadcb
eadbc
eabdc
eabcd
            </code>
            </pre>

            </section>
        <section id="st22">
            <p>Q-22:ENTER THE STRING FROM THE USER, SORT THE STRING IN ASCENDING ORDER AND PRINT IT.</p>
            <pre>
            <code >
#include<stdio.h>
#include<string.h>
char * sortString( char * arr){
        int size = strlen(arr);
        int i,j;
        char temp;
        for(i=0;i &lt size;i++){
            for(j=0;j&ltsize - i -1;j++){
                if(arr[j]>arr[j+1]){
                    temp = arr[j];
                    arr[j]= arr[j+1];
                    arr[j+1] = temp; 
                }
            }
        }
return arr;
}
void main(){
    char str[50];
    printf("Enter the string.\n");
    gets(str);
    int i=0;
    char * str1 = sortString(str);
    while(i&ltstrlen(str1)){
        if(str1[i]!=' ' && str1[i]!='.')
            printf("%c ",str1[i]);
        i++;
    }
}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string.
hello world.this is a string.
a d e g h h i i i l l l n o o r r s s s t t w
            </code>
            </pre>

            </section>
        <section id="st23">
            <p>Q-23:ENTER A SENTENCE FROM USER AND THEN ENTER THE WORD AND COUNT THE OCCURENCE OF THAT WORD IN THE SENTENCE.</p>
            <pre>
            <code >
#include<stdio.h>

int countOccurence(char * arr,char * word){
    int i=0,count =0;
    while(arr[i]){
        int j =0,flag=1;
        while(arr[i]!=' '&& arr[i]!='.'){
            if(arr[i]==word[j]){
                i++;
                j++;
            }
            else{
                flag =0;
                while(arr[i]!=' '&& arr[i]!='.'){
                    i++;
                }
            }
        }
        if(flag==1)
            count++;
    
    i++;
    }
    
return count;
}
void main(){
    char str[30];
    char word[15];
    printf("Enter the string");
    gets(str);
    printf("Enter the word");
    gets(word);
    printf("%s occurs %d times",word, countOccurence(str,word));
}
            </code>
            <p>OUTPUT</p>
            <code>
Enter the string
This is a word that is - is. 
Enter the word
is
is occurs 3 times
            </code>
            </pre>

            </section>
        <section id="st24">
            <p>Q-24:Enter a sentence from user and then enter the word and replace that word by another word.</p>
            <pre>
            <code >
#include<stdio.h>
#include<stblib.h>
#include<string.h>
char * replaceWord(char * arr,char * word,char * replacingword){
    int i=0,count =0,k;
    int newsize = strlen(arr)+strlen(replacingword);
    int initial;
    char * newarr = (char *)malloc(newsize*sizeof(char));
    while(arr[i]){
        int j =0,flag=1;
        while(arr[i]!=' '&& arr[i]!='.'){
            initial = i-1;
            if(arr[i]==word[j]){
                i++;
                j++;
            }
            else{
                flag =0;
                while(arr[i]!=' '&& arr[i]!='.'){
                    i++;
                    initial = -1;
                }
            }
        }
        if(flag==1){
            i =j=k  = 0;
            while(arr[i]){
                if(i!=initial){
                    newarr[j] = arr[i];
                    i++;
                    j++;
                }
                else{
                    while(replacingword[k]){
                        newarr[j]=replacingword[k];
                        k++;
                        j++;
                    }
                    while(arr[i]!=' ' && arr[i]!='.'){
                        i++;
                    }
                }
            }
        }
    
    i++;
    }
    
return newarr;
}
void main(){
    char str[30];
    char word[15];
    char replaceby[15];
    printf("Enter the string");
    gets(str);
    printf("Enter the  word to replace");
    gets(word);
    printf("Enter the word by which word will be replaced. ");
    gets(replaceby);
    char * new;
    new = replaceWord(str,word,replaceby);
    printf("%s",new);
} 
            </code>
            <p>OUTPUT</p>
            <code>

            </code>
            </pre>

            </section>
        <section id="st25">
            <p>Q-25:ENTER THE STRING FROM THE USER AND TRIM/ ELIMINATE THE SPACES FROM BOTH ENDS (IF ANY).</p>
            <pre>
            <code >
#include <stdio.h>
#include <string.h>

char *trimString(char *str) {
    int i = 0, j = strlen(str) - 1;

    while (str[i] == ' ') {
        i++;
    }

    while (j > i && str[j] == ' ') {
        j--;
    }

    for (int k = 0; k &lt= j - i; k++) {
        str[k] = str[i + k];
    }

    str[j - i + 1] = '\0';
    return str;
}

int main() {
    char str[100];
    printf("Enter a string: ");
    gets(str);

    char *trimmedString = trimString(str);
    printf("Trimmed string: %s\n", trimmedString);

    return 0;
}

            </code>
            <p>OUTPUT</p>
            <code>
Enter a string:            this is a string
Trimmed string: this is a string
            </code>
            </pre>

            </section>
        <section id="st26">
            <p>Q-26:ENTER THE STRING FROM USER AND SPLITS THE FIRST WORD AND SECOND WORD AND RETURN THE START INDEX OF THE SECOND WORD.</p>
            <pre>
            <code >

            </code>
            <p>OUTPUT</p>
            <code>

            </code>
            </pre>

            </section>
        <section id="st27">
            <p>Q-27:Display the string with text alignment option (1 for left, 2 for center, 3 right)</p>
            <pre>
            <code >
#include <stdio.h>
#include <string.h>

int split(char *str, char *firstWord, char *secondWord) {
    int i, j = 0, startIndexOfSecond = -1;
    int len = strlen(str);

    for (i = 0; i &lt len && str[i] != ' ' && str[i] != '\t' && str[i] != '\n'; i++) {
        firstWord[i] = str[i];
    }
    firstWord[i] = '\0';

    while (i &lt len && (str[i] == ' ' || str[i] == '\t' || str[i] == '\n')) {
        i++;
    }

    startIndexOfSecond = i;
    for (; i &lt len; i++) {
        secondWord[j++] = str[i];
    }
    secondWord[j] = '\0';

    return startIndexOfSecond;
}

int main() {
    char str[100], firstWord[50], secondWord[50];
    printf("Enter a string: ");
    fgets(str, sizeof(str), stdin);

    int startIndexOfSecond = split(str, firstWord, secondWord);

    printf("First word: %s\n", firstWord);
    printf("Second word: %s\n", secondWord);
    printf("Start index of the second word: %d\n", startIndexOfSecond);

    return 0;
}
            </code>
            <p>OUTPUT</p>
            <code>
Enter a string: hello world
First word: hello
Second word: world

Start index of the second word: 6 
            </code>
            </pre>

            </section>
        <section id="st28">
            <p>Q-28:Create a dictionary having 10 words and their meaning with following operations. [create, delete,search]</p>
            <pre>
            <code >
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define SIZE 10

struct Dictionary {
    char word[20];
    char meaning[100];
};

void create(struct Dictionary dict[], int *count) {
    if (*count >= SIZE) {
        printf("Dictionary is full. Cannot add more words.\n");
        return;
    }

    printf("Enter word: ");
    scanf("%s", dict[*count].word);

    printf("Enter meaning: ");
    scanf(" %[^\n]s", dict[*count].meaning);

    (*count)++;
}

void search(struct Dictionary dict[], int count, char *word) {
    int found = 0;
    for (int i = 0; i &lt count; i++) {
        if (strcmp(dict[i].word, word) == 0) {
            printf("Meaning: %s\n", dict[i].meaning);
            found = 1;
            break;
        }
    }
    if (!found) {
        printf("Word not found in the dictionary.\n");
    }
}

void delete (struct Dictionary dict[], int *count, char *word) {
    for (int i = 0; i &lt *count; i++) {
        if (strcmp(dict[i].word, word) == 0) {
            for (int j = i; j &lt *count - 1; j++) {
                strcpy(dict[j].word, dict[j + 1].word);
                strcpy(dict[j].meaning, dict[j + 1].meaning);
            }
            (*count)--;
            printf("Word deleted from the dictionary.\n");
            return;
        }
    }
    printf("Word not found in the dictionary.\n");
}

int main() {
    struct Dictionary dict[SIZE];
    int count = 0;
    int choice;
    char word[20];

    while (1) {
        printf("\n1. Create\n2. Delete\n3. Search\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                create(dict, &count);
                break;
            case 2:
                printf("Enter word to delete: ");
                scanf("%s", word);
                delete(dict, &count, word);
                break;
            case 3:
                printf("Enter word to search: ");
                scanf("%s", word);
                search(dict, count, word);
                break;
            case 4:
                exit(0);
            default:
                printf("Invalid choice! Please select a valid option.\n");
        }
    }

    return 0;
}
            </code>
            <p>OUTPUT</p>
            <code>
1. Create
2. Delete
3. Search
4. Exit
Enter your choice: 1
Enter word: apple
Enter meaning: A fruit

1. Create
2. Delete
3. Search
4. Exit
Enter your choice: 1
Enter word: orange
Enter meaning: A citrus fruit

1. Create
2. Delete
3. Search
4. Exit
Enter your choice: 3
Enter word to search: apple
Meaning: A fruit

1. Create
2. Delete
3. Search
4. Exit
Enter your choice: 2
Enter word to delete: orange
Word deleted from the dictionary.

1. Create
2. Delete
3. Search
4. Exit
Enter your choice: 3
Enter word to search: orange
Word not found in the dictionary.

1. Create
2. Delete
3. Search
4. Exit
Enter your choice: 4
            </code>
            </pre>

            </section>
        <section id="st29">
            <p>Q-29:ENTER THE STRING FROM USER AND CONVERT CHARACTERS INTO THEIR ASCII VALUES IN THE INTEGER ARRAY. [FOR EXAMPLE TAKE 10 CHARACTERS]</p>
            <pre>
            <code >
                #include <stdio.h>
                    #include <string.h>
                    
                    int main() {
                        char str[100];
                        int asciiValues[100];
                        int i, length;
                    
                        printf("Enter a string: ");
                        fgets(str, sizeof(str), stdin);
                    
                        length = strlen(str);
                    
                        for (i = 0; i &lt length - 1; i++) {
                            asciiValues[i] = (int)str[i];
                        }
                    
                        printf("ASCII values of the characters: ");
                        for (i = 0; i &lt length - 1; i++) {
                            printf("%d ", asciiValues[i]);
                        }
                        printf("\n");
                    
                        return 0;
                    }
            </code>
            <p>OUTPUT</p>
            <code>
Enter a string: Hello, world!
ASCII values of characters: 72 101 108 108 111 44 32 119 111 114 108 100 33
            </code>
            </pre>

            </section>

    <section id="stack">
        <h2>STACK PROBLEMS</h2>
        <ul>
            <li><a href="#stack1">Q-1:CREATE A STACK IMPLEMENTING THE OPERATIONS ON AN INTEGER ARRAY (PUSH, POP, PEEK, ISEMPTY, ISFULL)</a></li>
            <li><a href="#stack2">Q-2:CREATE A STACK IMPLEMENTING THE OPERATIONS ON THE CHARACTERS ARRAY (PUSH, POP, PEEK, ISEMPTY, ISFULL)</a></li>
            <li><a href="#stack3">Q-3:CREATE A STACK IMPLEMENTING THE OPERATIONS ON AN INTEGER NODES (DYNAMICALLY) (PUSH, POP, PEEK, ISEMPTY, ISFULL) </a></li>
            <li><a href="#stack4">Q-4:CREATE A STACK IMPLEMENTING THE OPERATIONS ON THE CHARACTERS NODES (DYNAMICALLY) (PUSH, POP, PEEK, ISEMPTY, ISFULL)</a></li>
            <li><a href="#stack5">Q-5:ENTE R THE STRING FROM THE USER AND REVERSE THE STRING USING STACKS.</a></li>
            <li><a href="#stack6">Q-6:CREATE THE PROGRAM TO MATCH THE SINGLE BRACKET USING STACKS.</a></li>
            <li><a href="#stack7">Q-7:CREATE TWO INTEGER STACKS IN A SINGLE ARRAY.</a></li>
            <li><a href="#stack8">Q-8:SORT THE STACK IN ASCENDING ORDER USING INTEGER ARRAY.</a></li>
            <li><a href="#stack9">Q-9:ENTER THE INFIX EXPRESSION FROM USER AND CONVERT INTO PREFIX EXPRESSION.</a></li>
            <li><a href="#stack10">Q-10:ENTER THE INFIX EXPRESSION FROM USER AND CONVERT INTO POSTFIX EXPRESSION.</a></li>
            <li><a href="#stack11">Q-11:CREATE A PROGRAM TO EVALUATE THE PREFIX EXPRESSION.</a></li>
            <li><a href="#stack12">Q-12:CREATE A PROGRAM TO EVALUATE THE POSTFIX EXPRESSION.</a></li>
            <li><a href="#stack13">Q-13:IMPLEMENT THE TOWER OF HANOI USING STACKS.</a></li>
            
            <section id="stack1">
                <p>Q-1:CREATE A STACK IMPLEMENTING THE OPERATIONS ON AN INTEGER ARRAY (PUSH, POP, PEEK, ISEMPTY, ISFULL)</p>
                <pre>
                <code >
#include <stdio.h>

const int MAX_SIZE = 5;

struct Stack {
    int items[5];
    int top;
};

int isEmpty(struct Stack *stack) {
    return stack->top == -1;
}

int isFull(struct Stack *stack) {
    return stack->top == MAX_SIZE - 1;
}

void push(struct Stack *stack, int value) {
    if (isFull(stack)) {
        printf("Stack is full. Cannot push more elements.\n");
    } else {
        stack->top++;
        stack->items[stack->top] = value;
        printf("%d pushed to the stack.\n", value);
    }
}

int pop(struct Stack *stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return -1;
    } else {
        int item = stack->items[stack->top];
        stack->top--;
        return item;
    }
}

int peek(struct Stack *stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty.\n");
        return -1;
    } else {
        return stack->items[stack->top];
    }
}

int main() {
    struct Stack stack;
    stack.top = -1;

    int choice, value;

    while (1) {
        printf("\n1. Push\n");
        printf("2. Pop\n");
        printf("3. Peek\n");
        printf("4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to push: ");
                scanf("%d", &value);
                push(&stack, value);
                break;
            case 2:
                printf("%d popped from the stack\n", pop(&stack));
                break;
            case 3:
                printf("Top element is %d\n", peek(&stack));
                break;
            case 4:
                return 0;
            default:
                printf("Invalid choice! Please select a valid option.\n");
        }
    }
}
                </code>
                <p>OUTPUT</p>
                <code>
1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter value to push: 10
10 pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter value to push: 20
20 pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 3
Top element is 20

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 2
20 popped from the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 2
10 popped from the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 3
Stack is empty.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 4
                </code>
                </pre>

                </section>
                
                <section id="stack2">
                    <p>Q-2:CREATE A STACK IMPLEMENTING THE OPERATIONS ON THE CHARACTERS ARRAY (PUSH, POP, PEEK, ISEMPTY, ISFULL)</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <stdbool.h>

#define MAX_SIZE 5

struct Stack {
    char items[MAX_SIZE];
    int top;
};

void initializeStack(struct Stack* stack) {
    stack->top = -1;
}

bool isFull(struct Stack* stack) {
    return stack->top == MAX_SIZE - 1;
}

bool isEmpty(struct Stack* stack) {
    return stack->top == -1;
}

void push(struct Stack* stack, char value) {
    if (isFull(stack)) {
        printf("Stack is full. Cannot push more elements.\n");
    } else {
        stack->top++;
        stack->items[stack->top] = value;
        printf("%c pushed to the stack.\n", value);
    }
}

char pop(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return '\0';
    } else {
        char value = stack->items[stack->top];
        stack->top--;
        return value;
    }
}

char peek(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty.\n");
        return '\0';
    } else {
        return stack->items[stack->top];
    }
}

int main() {
    struct Stack stack;
    initializeStack(&stack);

    int choice;
    char value;

    while (1) {
        printf("\n1. Push\n");
        printf("2. Pop\n");
        printf("3. Peek\n");
        printf("4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter character to push: ");
                scanf(" %c", &value);
                push(&stack, value);
                break;
            case 2:
                printf("%c popped from the stack.\n", pop(&stack));
                break;
            case 3:
                printf("Top element is %c\n", peek(&stack));
                break;
            case 4:
                return 0;
            default:
                printf("Invalid choice! Please select a valid option.\n");
        }
    }
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter character to push: a
a pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter character to push: b
b pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter character to push: c
c pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 3
Top element is c

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 2
c popped from the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 2
b popped from the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 3
Top element is a

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 4
                    </code>
                    </pre>

                    </section>
                    
                    <section id="stack3">
                        <p>Q-3:CREATE A STACK IMPLEMENTING THE OPERATIONS ON AN INTEGER NODES (DYNAMICALLY) (PUSH, POP, PEEK, ISEMPTY, ISFULL)</p>
                        <pre>
                        <code >
#include <stdio.h>
#include <string.h>
#define MAX_SIZE 50

struct Stack {
    char items[MAX_SIZE];
    int top;
};

void initializeStack(struct Stack* stack) {
    stack->top = -1;
}

void push(struct Stack* stack, char value) {
    if (stack->top == MAX_SIZE - 1) {
        printf("Stack is full. Cannot push more elements.\n");
    } else {
        stack->top++;
        stack->items[stack->top] = value;
    }
}

char pop(struct Stack* stack) {
    if (stack->top == -1) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return '\0';
    } else {
        char value = stack->items[stack->top];
        stack->top--;
        return value;
    }
}

void reverseString(char* str) {
    struct Stack stack;
    initializeStack(&stack);

    int i;
    for (i = 0; str[i] != '\0'; i++) {
        push(&stack, str[i]);
    }

    for (i = 0; stack.top != -1; i++) {
        str[i] = pop(&stack);
    }
}

int main() {
    char str[MAX_SIZE];

    printf("Enter a string: ");
    gets(str);

    printf("Original string: %s\n", str);
    reverseString(str);
    printf("Reversed string: %s\n", str);

    return 0;
}  
                        </code>
                        <p>OUTPUT</p>
                        <code>
 Enter a string: Hello, world!
Original string: Hello, world!
Reversed string: !dlrow ,olleH   
                        </code>
                        </pre>
    
                        </section>
                        
                    <section id="stack4">
                        <p>Q-4:CREATE A STACK IMPLEMENTING THE OPERATIONS ON THE CHARACTERS NODES (DYNAMICALLY) (PUSH, POP, PEEK, ISEMPTY, ISFULL)</p>
                        <pre>
                        <code >
 #include <stdio.h>
#include <stdbool.h>
#define MAX_SIZE 50

struct Stack {
    char items[MAX_SIZE];
    int top;
};

void initializeStack(struct Stack* stack) {
    stack->top = -1;
}

void push(struct Stack* stack, char value) {
    if (stack->top == MAX_SIZE - 1) {
        printf("Stack is full. Cannot push more elements.\n");
    } else {
        stack->top++;
        stack->items[stack->top] = value;
    }
}

char pop(struct Stack* stack) {
    if (stack->top == -1) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return '\0';
    } else {
        char value = stack->items[stack->top];
        stack->top--;
        return value;
    }
}

bool isMatchingPair(char character1, char character2) {
    if (character1 == '(' && character2 == ')')
        return true;
    else if (character1 == '{' && character2 == '}')
        return true;
    else if (character1 == '[' && character2 == ']')
        return true;
    else
        return false;
}

bool checkBalanced(char exp[]) {
    struct Stack stack;
    initializeStack(&stack);

    for (int i = 0; exp[i] != '\0'; i++) {
        if (exp[i] == '(' || exp[i] == '{' || exp[i] == '[')
            push(&stack, exp[i]);
        else if (exp[i] == ')' || exp[i] == '}' || exp[i] == ']') {
            if (stack.top == -1 || !isMatchingPair(stack.items[stack.top], exp[i]))
                return false;
            else
                pop(&stack);
        }
    }
    return stack.top == -1; // Stack should be empty for balanced expression
}

int main() {
    char expression[MAX_SIZE];

    printf("Enter an expression: ");
    gets(expression);

    if (checkBalanced(expression))
        printf("The expression is balanced.\n");
    else
        printf("The expression is not balanced.\n");

    return 0;
}   
                        </code>
                        <p>OUTPUT</p>
                        <code>
Enter an expression: (a+b)*[c+d]
The expression is balanced.

Enter an expression: {a+(b*c]+d}
The expression is not balanced.   
                        </code>
                        </pre>
    
                        </section>
                        
                    <section id="stack5">
                        <p>Q-5:ENTER THE STRING FROM THE USER AND REVERSE THE STRING USING STACKS.</p>
                        <pre>
                        <code >
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdlib.h>

#define MAX_SIZE 100

struct Stack {
    char items[MAX_SIZE];
    int top;
};

void initializeStack(struct Stack* stack) {
    stack->top = -1;
}

void push(struct Stack* stack, char value) {
    if (stack->top == MAX_SIZE - 1) {
        printf("Stack is full. Cannot push more elements.\n");
    } else {
        stack->top++;
        stack->items[stack->top] = value;
    }
}

char pop(struct Stack* stack) {
    if (stack->top == -1) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return '\0';
    } else {
        char value = stack->items[stack->top];
        stack->top--;
        return value;
    }
}

int getPrecedence(char ch) {
    switch (ch) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        case '^':
            return 3;
    }
    return -1;
}

bool isOperator(char ch) {
    return (ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '^');
}

bool isOperand(char ch) {
    return ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'));
}

void infixToPrefix(char* infix, char* prefix) {
    struct Stack stack;
    initializeStack(&stack);
    int i, j = 0;

    for (i = strlen(infix) - 1; i >= 0; i--) {
        if (infix[i] == ')') {
            push(&stack, infix[i]);
        } else if (infix[i] == '(') {
            while (stack.items[stack.top] != ')') {
                prefix[j++] = pop(&stack);
            }
            pop(&stack);  // pop the ')'
        } else if (isOperand(infix[i])) {
            prefix[j++] = infix[i];
        } else if (isOperator(infix[i])) {
            while (getPrecedence(infix[i]) <= getPrecedence(stack.items[stack.top]) && stack.top != -1) {
                prefix[j++] = pop(&stack);
            }
            push(&stack, infix[i]);
        }
    }

    while (stack.top != -1) {
        prefix[j++] = pop(&stack);
    }

    prefix[j] = '\0';
    // Reverse the prefix expression
    int len = strlen(prefix);
    for (i = 0; i < len / 2; i++) {
        char temp = prefix[i];
        prefix[i] = prefix[len - i - 1];
        prefix[len - i - 1] = temp;
    }
}

int main() {
    char infix[MAX_SIZE], prefix[MAX_SIZE];
    printf("Enter an infix expression: ");
    gets(infix);

    infixToPrefix(infix, prefix);
    printf("Prefix expression: %s\n", prefix);
    return 0;
}   
                        </code>
                        <p>OUTPUT</p>
                        <code>
Enter an infix expression: (A+B)*C-D*E
Prefix expression: -*+ABC*DE  
                        </code>
                        </pre>
    
                        </section>
                        
                    <section id="stack6">
                        <p>Q-6:CREATE THE PROGRAM TO MATCH THE SINGLE BRACKET USING STACKS.</p>
                        <pre>
                        <code >
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAX_SIZE 100

struct Stack {
    char items[MAX_SIZE];
    int top;
};

void initializeStack(struct Stack* stack) {
    stack->top = -1;
}

void push(struct Stack* stack, char value) {
    if (stack->top == MAX_SIZE - 1) {
        printf("Stack is full. Cannot push more elements.\n");
    } else {
        stack->top++;
        stack->items[stack->top] = value;
    }
}

char pop(struct Stack* stack) {
    if (stack->top == -1) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return '\0';
    } else {
        char value = stack->items[stack->top];
        stack->top--;
        return value;
    }
}

int getPrecedence(char ch) {
    switch (ch) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        case '^':
            return 3;
    }
    return -1;
}

bool isOperator(char ch) {
    return (ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '^');
}

bool isOperand(char ch) {
    return ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'));
}

void infixToPostfix(char* infix, char* postfix) {
    struct Stack stack;
    initializeStack(&stack);
    int i, j = 0;

    for (i = 0; infix[i] != '\0'; i++) {
        if (isOperand(infix[i])) {
            postfix[j++] = infix[i];
        } else if (infix[i] == '(') {
            push(&stack, infix[i]);
        } else if (infix[i] == ')') {
            while (stack.items[stack.top] != '(') {
                postfix[j++] = pop(&stack);
            }
            pop(&stack);  // Pop the '('
        } else if (isOperator(infix[i])) {
            while (stack.top != -1 && getPrecedence(infix[i]) <= getPrecedence(stack.items[stack.top])) {
                postfix[j++] = pop(&stack);
            }
            push(&stack, infix[i]);
        }
    }

    while (stack.top != -1) {
        postfix[j++] = pop(&stack);
    }

    postfix[j] = '\0';
}

int main() {
    char infix[MAX_SIZE], postfix[MAX_SIZE];
    printf("Enter an infix expression: ");
    fgets(infix);

    infixToPostfix(infix, postfix);
    printf("Postfix expression: %s\n", postfix);
    return 0;
}    
                        </code>
                        <p>OUTPUT</p>
                        <code>
Enter an infix expression: A+B*C-(D+E)/F
Postfix expression: ABC*+DE+F/-   
                        </code>
                        </pre>
    
                        </section>
                        
                    <section id="stack7">
                        <p>Q-7:CREATE TWO INTEGER STACKS IN A SINGLE ARRAY.</p>
                        <pre>
                        <code >
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_SIZE 100

struct Stack {
    int items[MAX_SIZE];
    int top;
};

void initializeStack(struct Stack* stack) {
    stack->top = -1;
}

void push(struct Stack* stack, int value) {
    if (stack->top == MAX_SIZE - 1) {
        printf("Stack is full. Cannot push more elements.\n");
    } else {
        stack->top++;
        stack->items[stack->top] = value;
    }
}

int pop(struct Stack* stack) {
    if (stack->top == -1) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return -1;
    } else {
        int value = stack->items[stack->top];
        stack->top--;
        return value;
    }
}

int evaluatePrefix(char* expression) {
    struct Stack stack;
    initializeStack(&stack);
    int length = strlen(expression);

    for (int i = length - 1; i >= 0; i--) {
        if (isdigit(expression[i])) {
            push(&stack, expression[i] - '0');
        } else {
            int operand1 = pop(&stack);
            int operand2 = pop(&stack);
            switch (expression[i]) {
                case '+':
                    push(&stack, operand1 + operand2);
                    break;
                case '-':
                    push(&stack, operand1 - operand2);
                    break;
                case '*':
                    push(&stack, operand1 * operand2);
                    break;
                case '/':
                    push(&stack, operand1 / operand2);
                    break;
            }
        }
    }

    return pop(&stack);
}

int main() {
    char expression[MAX_SIZE];
    printf("Enter a prefix expression: ");
    fgets(expression);

    int result = evaluatePrefix(expression);
    printf("Result: %d\n", result);
    return 0;
}   
                        </code>
                        <p>OUTPUT</p>
                        <code>
Enter a prefix expression: -+7*45+20
Result: 25   
                        </code>
                        </pre>
    
                        </section>
                        
                    <section id="stack8">
                        <p>Q-8:SORT THE STACK IN ASCENDING ORDER USING INTEGER ARRAY.</p>
                        <pre>
                        <code >
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_SIZE 100

struct Stack {
    int items[MAX_SIZE];
    int top;
};

void initializeStack(struct Stack* stack) {
    stack->top = -1;
}

void push(struct Stack* stack, int value) {
    if (stack->top == MAX_SIZE - 1) {
        printf("Stack is full. Cannot push more elements.\n");
    } else {
        stack->top++;
        stack->items[stack->top] = value;
    }
}

int pop(struct Stack* stack) {
    if (stack->top == -1) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return -1;
    } else {
        int value = stack->items[stack->top];
        stack->top--;
        return value;
    }
}

int evaluatePostfix(char* expression) {
    struct Stack stack;
    initializeStack(&stack);
    int length = strlen(expression);

    for (int i = 0; i < length; i++) {
        if (isdigit(expression[i])) {
            push(&stack, expression[i] - '0');
        } else {
            int operand2 = pop(&stack);
            int operand1 = pop(&stack);
            switch (expression[i]) {
                case '+':
                    push(&stack, operand1 + operand2);
                    break;
                case '-':
                    push(&stack, operand1 - operand2);
                    break;
                case '*':
                    push(&stack, operand1 * operand2);
                    break;
                case '/':
                    push(&stack, operand1 / operand2);
                    break;
            }
        }
    }

    return pop(&stack);
}

int main() {
    char expression[MAX_SIZE];
    printf("Enter a postfix expression: ");
    fgets(expression);

    int result = evaluatePostfix(expression);
    printf("Result: %d\n", result);
    return 0;
}   
                        </code>
                        <p>OUTPUT</p>
                        <code>
Enter a postfix expression: 345*+2+
Result: 17    
                        </code>
                        </pre>
    
                        </section>
                        
                    <section id="stack9">
                        <p>Q-9:ENTER THE INFIX EXPRESSION FROM USER AND CONVERT INTO PREFIX EXPRESSION.</p>
                        <pre>
                        <code >
#include <stdio.h>

void towerOfHanoi(int n, char source, char auxiliary, char destination) {
    if (n == 1) {
        printf("Move disk 1 from %c to %c\n", source, destination);
        return;
    }
    towerOfHanoi(n - 1, source, destination, auxiliary);
    printf("Move disk %d from %c to %c\n", n, source, destination);
    towerOfHanoi(n - 1, auxiliary, source, destination);
}

int main() {
    int n = 3; // Number of disks
    towerOfHanoi(n, 'A', 'B', 'C');  // A, B, C are the names of the rods
    return 0;
}    
                        </code>
                        <p>OUTPUT</p>
                        <code>
Move disk 1 from A to C
Move disk 2 from A to B
Move disk 1 from C to B
Move disk 3 from A to C
Move disk 1 from B to A
Move disk 2 from B to C
Move disk 1 from A to C    
                        </code>
                        </pre>
    
                        </section>
                        
                    <section id="stack10">
                        <p>Q-10:ENTER THE INFIX EXPRESSION FROM USER AND CONVERT INTO POSTFIX EXPRESSION.</p>
                        <pre>
                        <code >
    
                        </code>
                        <p>OUTPUT</p>
                        <code>
    
                        </code>
                        </pre>
    
                        </section>
                        
                    <section id="stack11">
                        <p>Q-11:CREATE A PROGRAM TO EVALUATE THE PREFIX EXPRESSION.</p>
                        <pre>
                        <code >
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 10

struct TwoStacks {
    int* array;
    int top1;
    int top2;
    int capacity;
};

struct TwoStacks* createTwoStacks() {
    struct TwoStacks* twoStacks = (struct TwoStacks*)malloc(sizeof(struct TwoStacks));
    if (!twoStacks) {
        return NULL;
    }
    twoStacks->capacity = MAX_SIZE;
    twoStacks->array = (int*)malloc(twoStacks->capacity * sizeof(int));
    if (!twoStacks->array) {
        return NULL;
    }
    twoStacks->top1 = -1;
    twoStacks->top2 = twoStacks->capacity;
    return twoStacks;
}

int isFull(struct TwoStacks* twoStacks) {
    return twoStacks->top1 + 1 == twoStacks->top2;
}

int isEmpty1(struct TwoStacks* twoStacks) {
    return twoStacks->top1 == -1;
}

int isEmpty2(struct TwoStacks* twoStacks) {
    return twoStacks->top2 == twoStacks->capacity;
}

void push1(struct TwoStacks* twoStacks, int value) {
    if (isFull(twoStacks)) {
        printf("Stack Overflow\n");
        return;
    }
    twoStacks->array[++twoStacks->top1] = value;
}

void push2(struct TwoStacks* twoStacks, int value) {
    if (isFull(twoStacks)) {
        printf("Stack Overflow\n");
        return;
    }
    twoStacks->array[--twoStacks->top2] = value;
}

int pop1(struct TwoStacks* twoStacks) {
    if (isEmpty1(twoStacks)) {
        printf("Stack Underflow\n");
        return -1;
    }
    return twoStacks->array[twoStacks->top1--];
}

int pop2(struct TwoStacks* twoStacks) {
    if (isEmpty2(twoStacks)) {
        printf("Stack Underflow\n");
        return -1;
    }
    return twoStacks->array[twoStacks->top2++];
}

int main() {
    struct TwoStacks* twoStacks = createTwoStacks();
    int choice, value;

    do {
        printf("\n1. Push to Stack 1");
        printf("\n2. Push to Stack 2");
        printf("\n3. Pop from Stack 1");
        printf("\n4. Pop from Stack 2");
        printf("\n0. Exit");
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to push to Stack 1: ");
                scanf("%d", &value);
                push1(twoStacks, value);
                break;
            case 2:
                printf("Enter value to push to Stack 2: ");
                scanf("%d", &value);
                push2(twoStacks, value);
                break;
            case 3:
                printf("Popped element from Stack 1: %d\n", pop1(twoStacks));
                break;
            case 4:
                printf("Popped element from Stack 2: %d\n", pop2(twoStacks));
                break;
            case 0:
                break;
            default:
                printf("Invalid choice! Please try again.\n");
        }
    } while (choice != 0);

    free(twoStacks->array);
    free(twoStacks);
    return 0;
}   
                        </code>
                        <p>OUTPUT</p>
                        <code>
1. Push to Stack 1
2. Push to Stack 2
3. Pop from Stack 1
4. Pop from Stack 2
0. Exit
Enter your choice: 1
Enter value to push to Stack 1: 5

1. Push to Stack 1
2. Push to Stack 2
3. Pop from Stack 1
4. Pop from Stack 2
0. Exit
Enter your choice: 2
Enter value to push to Stack 2: 10

1. Push to Stack 1
2. Push to Stack 2
3. Pop from Stack 1
4. Pop from Stack 2
0. Exit
Enter your choice: 3
Popped element from Stack 1: 5

1. Push to Stack 1
2. Push to Stack 2
3. Pop from Stack 1
4. Pop from Stack 2
0. Exit
Enter your choice: 4
Popped element from Stack 2: 10

1. Push to Stack 1
2. Push to Stack 2
3. Pop from Stack 1
4. Pop from Stack 2
0. Exit
Enter your choice: 0   
                        </code>
                        </pre>
    
                        </section>
                        
                    <section id="stack12">
                        <p>Q-12:CREATE A PROGRAM TO EVALUATE THE POSTFIX EXPRESSION.</p>
                        <pre>
                        <code >
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

struct Node {
    int data;
    struct Node* next;
};

struct Stack {
    struct Node* top;
    int size;
    int capacity;
};

struct Stack* createStack(int capacity) {
    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));
    stack->top = NULL;
    stack->size = 0;
    stack->capacity = capacity;
    return stack;
}

bool isFull(struct Stack* stack) {
    return stack->size == stack->capacity;
}

bool isEmpty(struct Stack* stack) {
    return stack->size == 0;
}

void push(struct Stack* stack, int data) {
    if (isFull(stack)) {
        printf("Stack is full. Cannot push more elements.\n");
        return;
    }

    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = stack->top;
    stack->top = newNode;
    stack->size++;
}

int pop(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return -1;
    }

    int data = stack->top->data;
    struct Node* temp = stack->top;
    stack->top = stack->top->next;
    free(temp);
    stack->size--;
    return data;
}

int peek(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty.\n");
        return -1;
    }
    return stack->top->data;
}

int main() {
    struct Stack* stack = createStack(5);
    int choice, value;

    while (1) {
        printf("\n1. Push\n");
        printf("2. Pop\n");
        printf("3. Peek\n");
        printf("4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to push: ");
                scanf("%d", &value);
                push(stack, value);
                break;
            case 2:
                printf("%d popped from the stack\n", pop(stack));
                break;
            case 3:
                printf("Top element is %d\n", peek(stack));
                break;
            case 4:
                return 0;
            default:
                printf("Invalid choice! Please select a valid option.\n");
        }
    }
}   
                        </code>
                        <p>OUTPUT</p>
                        <code>
1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter value to push: 10
10 pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter value to push: 20
20 pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 3
Top element is 20

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 2
20 popped from the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 2
10 popped from the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 3
Stack is empty.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 4   
                        </code>
                        </pre>
    
                        </section>
                        
                    <section id="stack13">
                        <p>Q-13:IMPLEMENT THE TOWER OF HANOI USING STACKS.</p>
                        <pre>
                        <code >
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define MAX_SIZE 5
#define MAX_LENGTH 50

struct Stack {
    char** items;
    int top;
    int size;
};

struct Stack* createStack(int size) {
    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));
    stack->items = (char**)malloc(size * sizeof(char*));
    stack->top = -1;
    stack->size = size;
    return stack;
}

bool isFull(struct Stack* stack) {
    return stack->top == stack->size - 1;
}

bool isEmpty(struct Stack* stack) {
    return stack->top == -1;
}

void push(struct Stack* stack, char* str) {
    if (isFull(stack)) {
        printf("Stack is full. Cannot push more elements.\n");
    } else {
        stack->top++;
        stack->items[stack->top] = (char*)malloc(MAX_LENGTH * sizeof(char));
        strcpy(stack->items[stack->top], str);
        printf("%s pushed to the stack.\n", str);
    }
}

char* pop(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return NULL;
    } else {
        return stack->items[stack->top--];
    }
}

char* peek(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty.\n");
        return NULL;
    } else {
        return stack->items[stack->top];
    }
}

int main() {
    struct Stack* stack = createStack(MAX_SIZE);
    int choice;
    char str[MAX_LENGTH];

    while (1) {
        printf("\n1. Push\n");
        printf("2. Pop\n");
        printf("3. Peek\n");
        printf("4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter string to push: ");
                scanf("%s", str);
                push(stack, str);
                break;
            case 2: {
                char* popped = pop(stack);
                if (popped != NULL) {
                    printf("%s popped from the stack\n", popped);
                }
                break;
            }
            case 3: {
                char* top = peek(stack);
                if (top != NULL) {
                    printf("Top element is %s\n", top);
                }
                break;
            }
            case 4:
                return 0;
            default:
                printf("Invalid choice! Please select a valid option.\n");
        }
    }
}    
                        </code>
                        <p>OUTPUT</p>
                        <code>
1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter string to push: apple
apple pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter string to push: banana
banana pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter string to push: cherry
cherry pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 3
Top element is cherry

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 2
cherry popped from the stack

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 2
banana popped from the stack

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 3
Top element is apple

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 4   
                        </code>
                        </pre>

                        </section>
                
        </ul>
    </section>

    <section id="queue">
        <h2>QUEUE PROBLEMS</h2>
        <li><a href="#QUE1">Q-1:IMPLEMENT THE OPERATIONS OF SIMPLE QUEUE IN AN INTEGER ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
        <li><a href="#QUE2">Q-2:IMPLEMENT THE OPERATIONS OF SIMPLE QUEUE IN AN STRING ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
        <li><a href="#QUE3">Q-3:IMPLEMENT THE OPERATIONS OF QUEUE DYNAMICALLY OF INTEGERS (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
        <li><a href="#QUE4">Q-4:IMPLEMENT THE OPERATIONS OF QUEUE DYNAMICALLY OF STRING (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
        <li><a href="#QUE5">Q-5:IMPLEMENT THE OPERATIONS OF CIRCULAR QUEUE IN AN INTEGER ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
        <li><a href="#QUE6">Q-6:IMPLEMENT THE OPERATIONS OF CIRCULAR QUEUE IN AN STRING ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
        <li><a href="#QUE7">Q-7:IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE IN AN INTEGER ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
        <li><a href="#QUE8">Q-8:IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE IN AN STRING ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
        <li><a href="#QUE9">Q-9:IMPLEMENT THE OPERATIONS OF DOUBLE ENDED QUEUE IN AN INTEGER ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
        <li><a href="#QUE10">Q-10:IMPLEMENT THE OPERATIONS OF DOUBLE ENDED QUEUE IN AN STRING ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
        <li><a href="#QUE11">Q-11:IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE DYNAMICALLY OF INTEGERS (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
        <li><a href="#QUE12">Q-12:IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE DYNAMICALLY OF STRING (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
        <li><a href="#QUE13">Q-13: Find the first circular tour that visits all petrol pumps</a></li>
        <li><a href="#QUE14">Q-14:Length of the longest valid substring</a></li>
        <li><a href="#QUE15">Q-15:Find the Next Greater Element</a></li>
        <li><a href="#QUE16">Q-16:Find Next Smaller Element</a></li>
        <li><a href="#QUE17">Q-17:Queue based approach for first non-repeating character in a stream</a></li>
        <li><a href="#QUE18">Q-18:Reverse First K elements of Queue</a></li>
        <li><a href="#QUE19">Q-19:Queue Reversal</a></li>
        <li><a href="#QUE20">Q-20:Rotten Oranges</a></li>

        <section id="QUE1">
            <p>IMPLEMENT THE OPERATIONS OF SIMPLE QUEUE IN AN INTEGER ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</p>
            <pre>
            <code >
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 5

struct Queue {
    int* array;
    int front, rear;
    int capacity;
};

struct Queue* createQueue() {
    struct Queue* queue = (struct Queue*)malloc(sizeof(struct Queue));
    if (!queue) {
        return NULL;
    }
    queue->capacity = MAX_SIZE;
    queue->array = (int*)malloc(queue->capacity * sizeof(int));
    if (!queue->array) {
        return NULL;
    }
    queue->front = queue->rear = -1;
    return queue;
}

int isFull(struct Queue* queue) {
    return (queue->rear + 1) % queue->capacity == queue->front;
}

int isEmpty(struct Queue* queue) {
    return queue->front == -1;
}

void insert(struct Queue* queue, int value) {
    if (isFull(queue)) {
        printf("Queue is full. Insertion failed.\n");
        return;
    }
    if (isEmpty(queue)) {
        queue->front = queue->rear = 0;
    } else {
        queue->rear = (queue->rear + 1) % queue->capacity;
    }
    queue->array[queue->rear] = value;
}

int delete(struct Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Deletion failed.\n");
        return -1;
    }
    int value = queue->array[queue->front];
    if (queue->front == queue->rear) {
        queue->front = queue->rear = -1;
    } else {
        queue->front = (queue->front + 1) % queue->capacity;
    }
    return value;
}

int peek(struct Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Peek failed.\n");
        return -1;
    }
    return queue->array[queue->front];
}

int main() {
    struct Queue* queue = createQueue();
    int choice, value;

    do {
        printf("\n1. Insert");
        printf("\n2. Delete");
        printf("\n3. Peek");
        printf("\n0. Exit");
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%d", &value);
                insert(queue, value);
                break;
            case 2:
                printf("Deleted element: %d\n", delete(queue));
                break;
            case 3:
                printf("Element at front: %d\n", peek(queue));
                break;
            case 0:
                break;
            default:
                printf("Invalid choice! Please try again.\n");
        }
    } while (choice != 0);

    free(queue->array);
    free(queue);
    return 0;
}
            </code>
            <p>OUTPUT</p>
            <code>
Element at front: 10
Element at front: 30
            </code>
            </pre>

            </section>
            <section id="QUE2">
                <p>IMPLEMENT THE OPERATIONS OF SIMPLE QUEUE IN AN STRING ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</p>
                <pre>
                <code >
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SIZE 5
#define MAX_LENGTH 50

struct Queue {
    char** array;
    int front, rear;
    int capacity;
};

struct Queue* createQueue() {
    struct Queue* queue = (struct Queue*)malloc(sizeof(struct Queue));
    if (!queue) {
        return NULL;
    }
    queue->capacity = MAX_SIZE;
    queue->array = (char**)malloc(queue->capacity * sizeof(char*));
    for (int i = 0; i < queue->capacity; i++) {
        queue->array[i] = (char*)malloc(MAX_LENGTH * sizeof(char));
    }
    queue->front = queue->rear = -1;
    return queue;
}

int isFull(struct Queue* queue) {
    return (queue->rear + 1) % queue->capacity == queue->front;
}

int isEmpty(struct Queue* queue) {
    return queue->front == -1;
}

void insert(struct Queue* queue, char* value) {
    if (isFull(queue)) {
        printf("Queue is full. Insertion failed.\n");
        return;
    }
    if (isEmpty(queue)) {
        queue->front = queue->rear = 0;
    } else {
        queue->rear = (queue->rear + 1) % queue->capacity;
    }
    strcpy(queue->array[queue->rear], value);
}

char* delete(struct Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Deletion failed.\n");
        return "";
    }
    char* value = queue->array[queue->front];
    if (queue->front == queue->rear) {
        queue->front = queue->rear = -1;
    } else {
        queue->front = (queue->front + 1) % queue->capacity;
    }
    return value;
}

char* peek(struct Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Peek failed.\n");
        return "";
    }
    return queue->array[queue->front];
}

int main() {
    struct Queue* queue = createQueue();
    char value[MAX_LENGTH];
    int choice;

    do {
        printf("\n1. Insert");
        printf("\n2. Delete");
        printf("\n3. Peek");
        printf("\n0. Exit");
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%s", value);
                insert(queue, value);
                break;
            case 2:
                printf("Deleted element: %s\n", delete(queue));
                break;
            case 3:
                printf("Element at front: %s\n", peek(queue));
                break;
            case 0:
                break;
            default:
                printf("Invalid choice! Please try again.\n");
        }
    } while (choice != 0);

    for (int i = 0; i < queue->capacity; i++) {
        free(queue->array[i]);
    }
    free(queue->array);
    free(queue);
    return 0;
}
                </code>
                <p>OUTPUT</p>
                <code>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SIZE 5
#define MAX_LENGTH 50

struct Queue {
    char** array;
    int front, rear;
    int capacity;
};

struct Queue* createQueue() {
    struct Queue* queue = (struct Queue*)malloc(sizeof(struct Queue));
    if (!queue) {
        return NULL;
    }
    queue->capacity = MAX_SIZE;
    queue->array = (char**)malloc(queue->capacity * sizeof(char*));
    for (int i = 0; i < queue->capacity; i++) {
        queue->array[i] = (char*)malloc(MAX_LENGTH * sizeof(char));
    }
    queue->front = queue->rear = -1;
    return queue;
}

int isFull(struct Queue* queue) {
    return (queue->rear + 1) % queue->capacity == queue->front;
}

int isEmpty(struct Queue* queue) {
    return queue->front == -1;
}

void insert(struct Queue* queue, char* value) {
    if (isFull(queue)) {
        printf("Queue is full. Insertion failed.\n");
        return;
    }
    if (isEmpty(queue)) {
        queue->front = queue->rear = 0;
    } else {
        queue->rear = (queue->rear + 1) % queue->capacity;
    }
    strcpy(queue->array[queue->rear], value);
}

char* delete(struct Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Deletion failed.\n");
        return "";
    }
    char* value = queue->array[queue->front];
    if (queue->front == queue->rear) {
        queue->front = queue->rear = -1;
    } else {
        queue->front = (queue->front + 1) % queue->capacity;
    }
    return value;
}

char* peek(struct Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Peek failed.\n");
        return "";
    }
    return queue->array[queue->front];
}

int main() {
    struct Queue* queue = createQueue();
    char value[MAX_LENGTH];
    int choice;

    do {
        printf("\n1. Insert");
        printf("\n2. Delete");
        printf("\n3. Peek");
        printf("\n0. Exit");
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%s", value);
                insert(queue, value);
                break;
            case 2:
                printf("Deleted element: %s\n", delete(queue));
                break;
            case 3:
                printf("Element at front: %s\n", peek(queue));
                break;
            case 0:
                break;
            default:
                printf("Invalid choice! Please try again.\n");
        }
    } while (choice != 0);

    for (int i = 0; i < queue->capacity; i++) {
        free(queue->array[i]);
    }
    free(queue->array);
    free(queue);
    return 0;
}
                </code>
                </pre>

                </section>
                <section id="QUE3">
                    <p>IMPLEMENT THE OPERATIONS OF QUEUE DYNAMICALLY OF INTEGERS (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
};

struct Queue {
    struct Node *front, *rear;
};

struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    if (!newNode) {
        printf("Memory error\n");
        return NULL;
    }
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

struct Queue* createQueue() {
    struct Queue* queue = (struct Queue*)malloc(sizeof(struct Queue));
    if (!queue) {
        printf("Memory error\n");
        return NULL;
    }
    queue->front = queue->rear = NULL;
    return queue;
}

void insert(struct Queue* queue, int data) {
    struct Node* newNode = createNode(data);
    if (!newNode) {
        return;
    }
    if (!queue->rear) {
        queue->front = queue->rear = newNode;
        return;
    }
    queue->rear->next = newNode;
    queue->rear = newNode;
}

int delete(struct Queue* queue) {
    if (!queue->front) {
        printf("Queue is empty. Deletion failed.\n");
        return -1;
    }
    struct Node* temp = queue->front;
    int data = temp->data;
    queue->front = queue->front->next;
    if (!queue->front) {
        queue->rear = NULL;
    }
    free(temp);
    return data;
}

int peek(struct Queue* queue) {
    if (!queue->front) {
        printf("Queue is empty. Peek failed.\n");
        return -1;
    }
    return queue->front->data;
}

int main() {
    struct Queue* queue = createQueue();
    int data, choice;

    do {
        printf("\n1. Insert");
        printf("\n2. Delete");
        printf("\n3. Peek");
        printf("\n0. Exit");
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%d", &data);
                insert(queue, data);
                break;
            case 2:
                printf("Deleted element: %d\n", delete(queue));
                break;
            case 3:
                printf("Element at front: %d\n", peek(queue));
                break;
            case 0:
                break;
            default:
                printf("Invalid choice! Please try again.\n");
        }
    } while (choice != 0);

    // Free the memory
    struct Node* current = queue->front;
    struct Node* next;
    while (current != NULL) {
        next = current->next;
        free(current);
        current = next;
    }
    free(queue);
    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 1
Enter value to insert: 10

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 1
Enter value to insert: 20

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 1
Enter value to insert: 30

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 3
Element at front: 10

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Deleted element: 10

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Deleted element: 20

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 3
Element at front: 30

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Deleted element: 30

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Queue is empty. Deletion failed.

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 0
                    </code>
                    </pre>

                    </section>
                    <section id="QUE4">
                    <p>IMPLEMENT THE OPERATIONS OF QUEUE DYNAMICALLY OF STRING (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LENGTH 50

struct Node {
    char data[MAX_LENGTH];
    struct Node* next;
};

struct Queue {
    struct Node *front, *rear;
};

struct Node* createNode(char* data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    if (!newNode) {
        printf("Memory error\n");
        return NULL;
    }
    strcpy(newNode->data, data);
    newNode->next = NULL;
    return newNode;
}

struct Queue* createQueue() {
    struct Queue* queue = (struct Queue*)malloc(sizeof(struct Queue));
    if (!queue) {
        printf("Memory error\n");
        return NULL;
    }
    queue->front = queue->rear = NULL;
    return queue;
}

void insert(struct Queue* queue, char* data) {
    struct Node* newNode = createNode(data);
    if (!newNode) {
        return;
    }
    if (!queue->rear) {
        queue->front = queue->rear = newNode;
        return;
    }
    queue->rear->next = newNode;
    queue->rear = newNode;
}

char* delete(struct Queue* queue) {
    if (!queue->front) {
        printf("Queue is empty. Deletion failed.\n");
        return "";
    }
    struct Node* temp = queue->front;
    char* data = temp->data;
    queue->front = queue->front->next;
    if (!queue->front) {
        queue->rear = NULL;
    }
    free(temp);
    return data;
}

char* peek(struct Queue* queue) {
    if (!queue->front) {
        printf("Queue is empty. Peek failed.\n");
        return "";
    }
    return queue->front->data;
}

int isEmpty(struct Queue* queue) {
    return !queue->front;
}

int main() {
    struct Queue* queue = createQueue();
    char data[MAX_LENGTH];
    int choice;

    do {
        printf("\n1. Insert");
        printf("\n2. Delete");
        printf("\n3. Peek");
        printf("\n0. Exit");
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%s", data);
                insert(queue, data);
                break;
            case 2:
                printf("Deleted element: %s\n", delete(queue));
                break;
            case 3:
                printf("Element at front: %s\n", peek(queue));
                break;
            case 0:
                break;
            default:
                printf("Invalid choice! Please try again.\n");
        }
    } while (choice != 0);

    // Free the memory
    struct Node* current = queue->front;
    struct Node* next;
    while (current != NULL) {
        next = current->next;
        free(current);
        current = next;
    }
    free(queue);
    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 1
Enter value to insert: Hello

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 1
Enter value to insert: World

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 3
Element at front: Hello

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Deleted element: Hello

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Deleted element: World

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Queue is empty. Deletion failed.

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 0
                    </code>
                    </pre>

                    </section>                
                <section id="QUE5">
                    <p>IMPLEMENT THE OPERATIONS OF CIRCULAR QUEUE IN AN INTEGER ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 5

struct CircularQueue {
    int *arr;
    int front, rear;
};

struct CircularQueue *createQueue() {
    struct CircularQueue *queue = (struct CircularQueue *)malloc(sizeof(struct CircularQueue));
    if (!queue) {
        return NULL;
    }
    queue->arr = (int *)malloc(MAX_SIZE * sizeof(int));
    if (!(queue->arr)) {
        return NULL;
    }
    queue->front = queue->rear = -1;
    return queue;
}

int isEmpty(struct CircularQueue *queue) {
    return (queue->front == -1);
}

int isFull(struct CircularQueue *queue) {
    return ((queue->rear + 1) % MAX_SIZE == queue->front);
}

void insert(struct CircularQueue *queue, int data) {
    if (isFull(queue)) {
        printf("Queue is full. Insertion failed.\n");
        return;
    }
    if (isEmpty(queue)) {
        queue->front = queue->rear = 0;
    } else {
        queue->rear = (queue->rear + 1) % MAX_SIZE;
    }
    queue->arr[queue->rear] = data;
    printf("%d inserted successfully.\n", data);
}

int delete(struct CircularQueue *queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Deletion failed.\n");
        return -1;
    }
    int data = queue->arr[queue->front];
    if (queue->front == queue->rear) {
        queue->front = queue->rear = -1;
    } else {
        queue->front = (queue->front + 1) % MAX_SIZE;
    }
    return data;
}

int peek(struct CircularQueue *queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Peek failed.\n");
        return -1;
    }
    return queue->arr[queue->front];
}

int main() {
    struct CircularQueue *queue = createQueue();
    int data, choice;

    do {
        printf("\n1. Insert");
        printf("\n2. Delete");
        printf("\n3. Peek");
        printf("\n0. Exit");
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%d", &data);
                insert(queue, data);
                break;
            case 2:
                printf("Deleted element: %d\n", delete(queue));
                break;
            case 3:
                printf("Element at front: %d\n", peek(queue));
                break;
            case 0:
                break;
            default:
                printf("Invalid choice! Please try again.\n");
        }
    } while (choice != 0);

    free(queue->arr);
    free(queue);
    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
1 inserted successfully.
2 inserted successfully.
3 inserted successfully.
4 inserted successfully.
Queue is full. Insertion failed.
Deleted element: 1
Element at front: 2
                    </code>
                    </pre>

                    </section>                                                                
        <section id="QUE6">
                    <p>IMPLEMENT THE OPERATIONS OF CIRCULAR QUEUE IN AN STRING ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SIZE 5
#define MAX_LENGTH 50

struct CircularQueue {
    char **arr;
    int front, rear;
};

struct CircularQueue *createQueue() {
    struct CircularQueue *queue = (struct CircularQueue *)malloc(sizeof(struct CircularQueue));
    if (!queue) {
        return NULL;
    }
    queue->arr = (char **)malloc(MAX_SIZE * sizeof(char *));
    if (!(queue->arr)) {
        return NULL;
    }
    for (int i = 0; i < MAX_SIZE; i++) {
        queue->arr[i] = (char *)malloc(MAX_LENGTH * sizeof(char));
    }
    queue->front = queue->rear = -1;
    return queue;
}

int isEmpty(struct CircularQueue *queue) {
    return (queue->front == -1);
}

int isFull(struct CircularQueue *queue) {
    return ((queue->rear + 1) % MAX_SIZE == queue->front);
}

void insert(struct CircularQueue *queue, char *data) {
    if (isFull(queue)) {
        printf("Queue is full. Insertion failed.\n");
        return;
    }
    if (isEmpty(queue)) {
        queue->front = queue->rear = 0;
    } else {
        queue->rear = (queue->rear + 1) % MAX_SIZE;
    }
    strcpy(queue->arr[queue->rear], data);
    printf("%s inserted successfully.\n", data);
}

char *delete (struct CircularQueue *queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Deletion failed.\n");
        return "";
    }
    char *data = queue->arr[queue->front];
    if (queue->front == queue->rear) {
        queue->front = queue->rear = -1;
    } else {
        queue->front = (queue->front + 1) % MAX_SIZE;
    }
    return data;
}

char *peek(struct CircularQueue *queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Peek failed.\n");
        return "";
    }
    return queue->arr[queue->front];
}

int main() {
    struct CircularQueue *queue = createQueue();
    char data[MAX_LENGTH];
    int choice;

    do {
        printf("\n1. Insert");
        printf("\n2. Delete");
        printf("\n3. Peek");
        printf("\n0. Exit");
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%s", data);
                insert(queue, data);
                break;
            case 2:
                printf("Deleted element: %s\n", delete(queue));
                break;
            case 3:
                printf("Element at front: %s\n", peek(queue));
                break;
            case 0:
                break;
            default:
                printf("Invalid choice! Please try again.\n");
        }
    } while (choice != 0);

    for (int i = 0; i < MAX_SIZE; i++) {
        free(queue->arr[i]);
    }
    free(queue->arr);
    free(queue);
    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 1
Enter value to insert: Apple
Apple inserted successfully.

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 1
Enter value to insert: Banana
Banana inserted successfully.

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 3
Element at front: Apple

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Deleted element: Apple

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Deleted element: Banana

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Queue is empty. Deletion failed.

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 0
                    </code>
                    </pre>

                    </section>
        <section id="QUE7">
                    <p>IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE IN AN INTEGER ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 5

struct PriorityQueue {
    int *arr;
    int front, rear;
};

struct PriorityQueue *createQueue() {
    struct PriorityQueue *queue = (struct PriorityQueue *)malloc(sizeof(struct PriorityQueue));
    if (!queue) {
        return NULL;
    }
    queue->arr = (int *)malloc(MAX_SIZE * sizeof(int));
    if (!(queue->arr)) {
        return NULL;
    }
    queue->front = queue->rear = -1;
    return queue;
}

int isEmpty(struct PriorityQueue *queue) {
    return (queue->front == -1);
}

int isFull(struct PriorityQueue *queue) {
    return (queue->rear == MAX_SIZE - 1);
}

void insert(struct PriorityQueue *queue, int data) {
    if (isFull(queue)) {
        printf("Queue is full. Insertion failed.\n");
        return;
    }
    if (isEmpty(queue)) {
        queue->front = queue->rear = 0;
        queue->arr[queue->rear] = data;
    } else {
        int i, j;
        for (i = 0; i <= queue->rear; i++) {
            if (data >= queue->arr[i]) {
                for (j = queue->rear + 1; j > i; j--) {
                    queue->arr[j] = queue->arr[j - 1];
                }
                queue->arr[i] = data;
                break;
            }
        }
        if (i == queue->rear + 1) {
            queue->arr[i] = data;
        }
        queue->rear++;
    }
    printf("%d inserted successfully.\n", data);
}

int delete (struct PriorityQueue *queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Deletion failed.\n");
        return -1;
    }
    int data = queue->arr[queue->front];
    if (queue->front == queue->rear) {
        queue->front = queue->rear = -1;
    } else {
        queue->front++;
    }
    return data;
}

int peek(struct PriorityQueue *queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Peek failed.\n");
        return -1;
    }
    return queue->arr[queue->front];
}

int main() {
    struct PriorityQueue *queue = createQueue();

    insert(queue, 3);
    insert(queue, 5);
    insert(queue, 2);
    insert(queue, 1);
    insert(queue, 4);
    insert(queue, 6);

    printf("Deleted element: %d\n", delete(queue));
    printf("Element at front: %d\n", peek(queue));

    free(queue->arr);
    free(queue);
    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
3 inserted successfully.
5 inserted successfully.
2 inserted successfully.
1 inserted successfully.
4 inserted successfully.
Queue is full. Insertion failed.
Deleted element: 1
Element at front: 2

                    </code>
                    </pre>

                    </section>
<section id="QUE8">
                    <p>IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE IN AN STRING ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SIZE 5
#define MAX_LENGTH 50

struct PriorityQueue {
    char **arr;
    int front, rear;
};

struct PriorityQueue *createQueue() {
    struct PriorityQueue *queue = (struct PriorityQueue *)malloc(sizeof(struct PriorityQueue));
    if (!queue) {
        return NULL;
    }
    queue->arr = (char **)malloc(MAX_SIZE * sizeof(char *));
    if (!(queue->arr)) {
        return NULL;
    }
    for (int i = 0; i < MAX_SIZE; i++) {
        queue->arr[i] = (char *)malloc(MAX_LENGTH * sizeof(char));
    }
    queue->front = queue->rear = -1;
    return queue;
}

int isEmpty(struct PriorityQueue *queue) {
    return (queue->front == -1);
}

int isFull(struct PriorityQueue *queue) {
    return (queue->rear == MAX_SIZE - 1);
}

void insert(struct PriorityQueue *queue, char *data) {
    if (isFull(queue)) {
        printf("Queue is full. Insertion failed.\n");
        return;
    }
    if (isEmpty(queue)) {
        queue->front = queue->rear = 0;
        strcpy(queue->arr[queue->rear], data);
    } else {
        int i, j;
        for (i = 0; i <= queue->rear; i++) {
            if (strcmp(data, queue->arr[i]) >= 0) {
                for (j = queue->rear + 1; j > i; j--) {
                    strcpy(queue->arr[j], queue->arr[j - 1]);
                }
                strcpy(queue->arr[i], data);
                break;
            }
        }
        if (i == queue->rear + 1) {
            strcpy(queue->arr[i], data);
        }
        queue->rear++;
    }
    printf("%s inserted successfully.\n", data);
}

char *delete (struct PriorityQueue *queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Deletion failed.\n");
        return "";
    }
    char *data = queue->arr[queue->front];
    if (queue->front == queue->rear) {
        queue->front = queue->rear = -1;
    } else {
        queue->front++;
    }
    return data;
}

char *peek(struct PriorityQueue *queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Peek failed.\n");
        return "";
    }
    return queue->arr[queue->front];
}

int main() {
    struct PriorityQueue *queue = createQueue();

    insert(queue, "apple");
    insert(queue, "orange");
    insert(queue, "banana");
    insert(queue, "kiwi");
    insert(queue, "grapes");
    insert(queue, "cherry");

    printf("Deleted element: %s\n", delete(queue));
    printf("Element at front: %s\n", peek(queue));

    for (int i = 0; i < MAX_SIZE; i++) {
        free(queue->arr[i]);
    }
    free(queue->arr);
    free(queue);
    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
apple inserted successfully.
orange inserted successfully.
banana inserted successfully.
kiwi inserted successfully.
grapes inserted successfully.
Queue is full. Insertion failed.
Deleted element: apple
Element at front: banana
                    </code>
                    </pre>

                    </section>
<section id="QUE9">
                    <p>IMPLEMENT THE OPERATIONS OF DOUBLE ENDED QUEUE IN AN INTEGER ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 5

struct Deque {
    int *arr;
    int front, rear;
};

struct Deque *createDeque() {
    struct Deque *deque = (struct Deque *)malloc(sizeof(struct Deque));
    if (!deque) {
        return NULL;
    }
    deque->arr = (int *)malloc(MAX_SIZE * sizeof(int));
    if (!(deque->arr)) {
        return NULL;
    }
    deque->front = -1;
    deque->rear = 0;
    return deque;
}

int isEmpty(struct Deque *deque) {
    return (deque->front == -1);
}

int isFull(struct Deque *deque) {
    return ((deque->front == 0 && deque->rear == MAX_SIZE - 1) || deque->front == deque->rear + 1);
}

void insertFront(struct Deque *deque, int data) {
    if (isFull(deque)) {
        printf("Deque is full. Insertion at the front failed.\n");
        return;
    }
    if (deque->front == -1) {
        deque->front = deque->rear = 0;
    } else if (deque->front == 0) {
        deque->front = MAX_SIZE - 1;
    } else {
        deque->front--;
    }
    deque->arr[deque->front] = data;
    printf("%d inserted at the front successfully.\n", data);
}

void insertRear(struct Deque *deque, int data) {
    if (isFull(deque)) {
        printf("Deque is full. Insertion at the rear failed.\n");
        return;
    }
    if (deque->front == -1) {
        deque->front = deque->rear = 0;
    } else if (deque->rear == MAX_SIZE - 1) {
        deque->rear = 0;
    } else {
        deque->rear++;
    }
    deque->arr[deque->rear] = data;
    printf("%d inserted at the rear successfully.\n", data);
}

int deleteFront(struct Deque *deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty. Deletion from the front failed.\n");
        return -1;
    }
    int data = deque->arr[deque->front];
    if (deque->front == deque->rear) {
        deque->front = deque->rear = -1;
    } else if (deque->front == MAX_SIZE - 1) {
        deque->front = 0;
    } else {
        deque->front++;
    }
    return data;
}

int deleteRear(struct Deque *deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty. Deletion from the rear failed.\n");
        return -1;
    }
    int data = deque->arr[deque->rear];
    if (deque->front == deque->rear) {
        deque->front = deque->rear = -1;
    } else if (deque->rear == 0) {
        deque->rear = MAX_SIZE - 1;
    } else {
        deque->rear--;
    }
    return data;
}

int getFront(struct Deque *deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty. Peek from the front failed.\n");
        return -1;
    }
    return deque->arr[deque->front];
}

int getRear(struct Deque *deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty. Peek from the rear failed.\n");
        return -1;
    }
    return deque->arr[deque->rear];
}

int main() {
    struct Deque *deque = createDeque();

    insertFront(deque, 3);
    insertRear(deque, 5);
    insertFront(deque, 2);
    insertRear(deque, 4);

    printf("Deleted element from front: %d\n", deleteFront(deque));
    printf("Deleted element from rear: %d\n", deleteRear(deque));
    printf("Element at front: %d\n", getFront(deque));
    printf("Element at rear: %d\n", getRear(deque));

    free(deque->arr);
    free(deque);
    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
3 inserted at the front successfully.
5 inserted at the rear successfully.
2 inserted at the front successfully.
4 inserted at the rear successfully.
Deleted element from front: 2
Deleted element from rear: 4
Element at front: 3
Element at rear: 5
            
                    </code>
                    </pre>

                    </section>
<section id="QUE10">
                    <p>IMPLEMENT THE OPERATIONS OF DOUBLE ENDED QUEUE IN AN STRING ARRAY (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SIZE 5
#define MAX_LENGTH 50

struct Deque {
    char **arr;
    int front, rear;
};

struct Deque *createDeque() {
    struct Deque *deque = (struct Deque *)malloc(sizeof(struct Deque));
    if (!deque) {
        return NULL;
    }
    deque->arr = (char **)malloc(MAX_SIZE * sizeof(char *));
    if (!(deque->arr)) {
        return NULL;
    }
    for (int i = 0; i < MAX_SIZE; i++) {
        deque->arr[i] = (char *)malloc(MAX_LENGTH * sizeof(char));
    }
    deque->front = -1;
    deque->rear = 0;
    return deque;
}

int isEmpty(struct Deque *deque) {
    return (deque->front == -1);
}

int isFull(struct Deque *deque) {
    return ((deque->front == 0 && deque->rear == MAX_SIZE - 1) || deque->front == deque->rear + 1);
}

void insertFront(struct Deque *deque, char *data) {
    if (isFull(deque)) {
        printf("Deque is full. Insertion at the front failed.\n");
        return;
    }
    if (deque->front == -1) {
        deque->front = deque->rear = 0;
    } else if (deque->front == 0) {
        deque->front = MAX_SIZE - 1;
    } else {
        deque->front--;
    }
    strcpy(deque->arr[deque->front], data);
    printf("%s inserted at the front successfully.\n", data);
}

void insertRear(struct Deque *deque, char *data) {
    if (isFull(deque)) {
        printf("Deque is full. Insertion at the rear failed.\n");
        return;
    }
    if (deque->front == -1) {
        deque->front = deque->rear = 0;
    } else if (deque->rear == MAX_SIZE - 1) {
        deque->rear = 0;
    } else {
        deque->rear++;
    }
    strcpy(deque->arr[deque->rear], data);
    printf("%s inserted at the rear successfully.\n", data);
}

char *deleteFront(struct Deque *deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty. Deletion from the front failed.\n");
        return "";
    }
    char *data = deque->arr[deque->front];
    if (deque->front == deque->rear) {
        deque->front = deque->rear = -1;
    } else if (deque->front == MAX_SIZE - 1) {
        deque->front = 0;
    } else {
        deque->front++;
    }
    return data;
}

char *deleteRear(struct Deque *deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty. Deletion from the rear failed.\n");
        return "";
    }
    char *data = deque->arr[deque->rear];
    if (deque->front == deque->rear) {
        deque->front = deque->rear = -1;
    } else if (deque->rear == 0) {
        deque->rear = MAX_SIZE - 1;
    } else {
        deque->rear--;
    }
    return data;
}

char *getFront(struct Deque *deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty. Peek from the front failed.\n");
        return "";
    }
    return deque->arr[deque->front];
}

char *getRear(struct Deque *deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty. Peek from the rear failed.\n");
        return "";
    }
    return deque->arr[deque->rear];
}

int main() {
    struct Deque *deque = createDeque();

    insertFront(deque, "apple");
    insertRear(deque, "banana");
    insertFront(deque, "orange");
    insertRear(deque, "cherry");

    printf("Deleted element from front: %s\n", deleteFront(deque));
    printf("Deleted element from rear: %s\n", deleteRear(deque));
    printf("Element at front: %s\n", getFront(deque));
    printf("Element at rear: %s\n", getRear(deque));

    for (int i = 0; i < MAX_SIZE; i++) {
        free(deque->arr[i]);
    }
    free(deque->arr);
    free(deque);
    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
apple inserted at the front successfully.
banana inserted at the rear successfully.
orange inserted at the front successfully.
cherry inserted at the rear successfully.
Deleted element from front: orange
Deleted element from rear: cherry
Element at front: apple
Element at rear: banana
                    </code>
                    </pre>

                    </section>
<section id="QUE11">
                    <p>IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE DYNAMICALLY OF INTEGERS (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    int priority;
    struct Node *next;
};

struct Node *front = NULL;

void insert(int data, int priority) {
    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->priority = priority;
    if (front == NULL || priority < front->priority) {
        newNode->next = front;
        front = newNode;
    } else {
        struct Node *temp = front;
        while (temp->next != NULL && temp->next->priority <= priority) {
            temp = temp->next;
        }
        newNode->next = temp->next;
        temp->next = newNode;
    }
}

void delete() {
    if (front == NULL) {
        printf("Priority queue is empty. Deletion failed.\n");
        return;
    }
    struct Node *temp = front;
    front = front->next;
    free(temp);
}

int peek() {
    if (front == NULL) {
        printf("Priority queue is empty. Peek failed.\n");
        return -1;
    }
    return front->data;
}

int isEmpty() {
    return front == NULL;
}

int isFull() {
    return 0;
}

int main() {
    insert(5, 2);
    insert(10, 1);
    insert(15, 0);

    printf("Element at front: %d\n", peek());
    delete();
    printf("Element at front after deletion: %d\n", peek());

    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
Element at front: 15
Element at front after deletion: 10
                    </code>
                    </pre>

                    </section>
                    <section id="QUE12">
                    <p>IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE DYNAMICALLY OF STRING (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    char *data;
    int priority;
    struct Node *next;
};

struct Node *front = NULL;

void insert(char *data, int priority) {
    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));
    newNode->data = strdup(data);
    newNode->priority = priority;
    if (front == NULL || priority < front->priority) {
        newNode->next = front;
        front = newNode;
    } else {
        struct Node *temp = front;
        while (temp->next != NULL && temp->next->priority <= priority) {
            temp = temp->next;
        }
        newNode->next = temp->next;
        temp->next = newNode;
    }
}

void delete() {
    if (front == NULL) {
        printf("Priority queue is empty. Deletion failed.\n");
        return;
    }
    struct Node *temp = front;
    front = front->next;
    free(temp->data);
    free(temp);
}

char *peek() {
    if (front == NULL) {
        printf("Priority queue is empty. Peek failed.\n");
        return "";
    }
    return front->data;
}

int isEmpty() {
    return front == NULL;
}

int isFull() {
    return 0;
}

int main() {
    insert("apple", 2);
    insert("banana", 1);
    insert("cherry", 0);

    printf("Element at front: %s\n", peek());
    delete();
    printf("Element at front after deletion: %s\n", peek());

    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
Element at front: cherry
Element at front after deletion: banana
                    </code>
                    </pre>

                    </section>
                    <section id="QUE13">
                    <p>Find the first circular tour that visits all petrol pumps</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <stdlib.h>
#define MAX 100

int stations = 0;
int graph[MAX][MAX];
int visited[MAX] = {0};
int queue[MAX], front = -1, rear = -1;

void enqueue(int item) {
    if (rear == MAX - 1) {
        printf("Queue Overflow\n");
    } else {
        if (front == -1)
            front = 0;
        rear++;
        queue[rear] = item;
    }
}

int dequeue() {
    int item;
    if (front == -1 || front > rear) {
        printf("Queue Underflow\n");
        exit(1);
    }
    item = queue[front];
    front++;
    return item;
}

void findTour() {
    int i, current;
    enqueue(0);
    visited[0] = 1;

    while (front <= rear) {
        current = dequeue();
        printf("%d ", current);

        for (i = 0; i < stations; i++) {
            if (!visited[i] && graph[current][i] == 1) {
                enqueue(i);
                visited[i] = 1;
            }
        }
    }
}

int main() {
    int i, j;
    printf("Enter the number of stations: ");
    scanf("%d", &stations);

    printf("Enter the adjacency matrix for the stations (0/1):\n");
    for (i = 0; i < stations; i++) {
        for (j = 0; j < stations; j++) {
            scanf("%d", &graph[i][j]);
        }
    }

    printf("The tour is: ");
    findTour();
    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
Enter the number of stations: 4
Enter the adjacency matrix for the stations (0/1):
0 1 1 0
1 0 1 0
1 1 0 1
0 0 1 0
The tour is: 0 1 2 3
                    </code>
                    </pre>

                    </section>
<section id="QUE14">
                    <p>Length of the longest valid substring</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node* next;
} Node;

typedef struct Queue {
    Node *front, *rear;
} Queue;

Queue* createQueue() {
    Queue* queue = (Queue*)malloc(sizeof(Queue));
    queue->front = queue->rear = NULL;
    return queue;
}

void enqueue(Queue* queue, int data) {
    Node* temp = (Node*)malloc(sizeof(Node));
    temp->data = data;
    temp->next = NULL;

    if (queue->rear == NULL) {
        queue->front = queue->rear = temp;
        return;
    }

    queue->rear->next = temp;
    queue->rear = temp;
}

int dequeue(Queue* queue) {
    if (queue->front == NULL)
        return -1;

    Node* temp = queue->front;
    queue->front = queue->front->next;

    if (queue->front == NULL)
        queue->rear = NULL;

    int data = temp->data;
    free(temp);
    return data;
}

int longestValidSubstring(char* s) {
    int n = strlen(s);
    Queue* queue = createQueue();
    int result = 0;

    enqueue(queue, -1);

    for (int i = 0; i < n; i++) {
        if (s[i] == '(')
            enqueue(queue, i);
        else {
            dequeue(queue);
            if (!queue->front)
                enqueue(queue, i);
            else
                result = result > (i - queue->front->data) ? result : (i - queue->front->data);
        }
    }
    return result;
}

int main() {
    char s[] = "((())()";
    printf("The length of the longest valid substring is: %d", longestValidSubstring(s));
    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
The length of the longest valid substring is: 4
                    </code>
                    </pre>

                    </section>
                    <section id="QUE15">
                    <p>Find the Next Greater Element</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <stdlib.h>

#define SIZE 100

typedef struct Node {
    int data;
    struct Node *next;
} Node;

typedef struct Queue {
    Node *front, *rear;
} Queue;

Queue *createQueue() {
    Queue *queue = (Queue *)malloc(sizeof(Queue));
    queue->front = queue->rear = NULL;
    return queue;
}

void enqueue(Queue *queue, int data) {
    Node *temp = (Node *)malloc(sizeof(Node));
    temp->data = data;
    temp->next = NULL;

    if (queue->rear == NULL) {
        queue->front = queue->rear = temp;
        return;
    }

    queue->rear->next = temp;
    queue->rear = temp;
}

int dequeue(Queue *queue) {
    if (queue->front == NULL)
        return -1;

    Node *temp = queue->front;
    queue->front = queue->front->next;

    if (queue->front == NULL)
        queue->rear = NULL;

    int data = temp->data;
    free(temp);
    return data;
}

void nextLargerElement(int arr[], int n) {
    Queue *queue = createQueue();

    enqueue(queue, arr[0]);

    for (int i = 1; i < n; i++) {
        int next = arr[i];

        if (queue->front == NULL) {
            enqueue(queue, next);
            continue;
        }

        while (queue->front != NULL) {
            int element = dequeue(queue);

            if (element < next)
                printf("%d -- %d\n", element, next);
            else {
                enqueue(queue, element);
                break;
            }
        }
        enqueue(queue, next);
    }

    while (queue->front != NULL) {
        int element = dequeue(queue);
        printf("%d -- %d\n", element, -1);
    }
}

int main() {
    int arr[] = {11, 13, 21, 3};
    int n = sizeof(arr) / sizeof(arr[0]);

    nextLargerElement(arr, n);
    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
11 -- 13
13 -- 21
21 -- -1
3 -- -1
                    </code>
                    </pre>

                    </section>
<section id="QUE16">
                    <p>Find Next Smaller Element</p>
                    <pre>
                    <code >
#include <stdio.h>
#include <stdlib.h>

#define SIZE 100

typedef struct Node {
    int data;
    struct Node *next;
} Node;

typedef struct Queue {
    Node *front, *rear;
} Queue;

Queue *createQueue() {
    Queue *queue = (Queue *)malloc(sizeof(Queue));
    queue->front = queue->rear = NULL;
    return queue;
}

void enqueue(Queue *queue, int data) {
    Node *temp = (Node *)malloc(sizeof(Node));
    temp->data = data;
    temp->next = NULL;

    if (queue->rear == NULL) {
        queue->front = queue->rear = temp;
        return;
    }

    queue->rear->next = temp;
    queue->rear = temp;
}

int dequeue(Queue *queue) {
    if (queue->front == NULL)
        return -1;

    Node *temp = queue->front;
    queue->front = queue->front->next;

    if (queue->front == NULL)
        queue->rear = NULL;

    int data = temp->data;
    free(temp);
    return data;
}

void nextSmallerElement(int arr[], int n) {
    Queue *queue = createQueue();

    enqueue(queue, arr[0]);

    for (int i = 1; i < n; i++) {
        int next = arr[i];

        if (queue->front == NULL) {
            enqueue(queue, next);
            continue;
        }

        while (queue->front != NULL) {
            int element = dequeue(queue);

            if (element > next)
                printf("%d -- %d\n", element, next);
            else {
                enqueue(queue, element);
                break;
            }
        }
        enqueue(queue, next);
    }

    while (queue->front != NULL) {
        int element = dequeue(queue);
        printf("%d -- %d\n", element, -1);
    }
}

int main() {
    int arr[] = {4, 8, 5, 2, 25};
    int n = sizeof(arr) / sizeof(arr[0]);

    nextSmallerElement(arr, n);
    return 0;
}
                    </code>
                    <p>OUTPUT</p>
                    <code>
4 -- 2
8 -- 5
5 -- 2
2 -- -1
25 -- -1
                    </code>
                    </pre>

                    </section>     
                    <section id="QUE17">
                        <p>Queue based approach for first non repeating character in a stream</p>
                        <pre>
                        <code >
#include <stdio.h>
#include <stdlib.h>
#define MAX_CHAR 26

typedef struct Queue {
    int front, rear;
    unsigned capacity;
    char* array;
} Queue;

Queue* createQueue(unsigned capacity) {
    Queue* queue = (Queue*)malloc(sizeof(Queue));
    queue->capacity = capacity;
    queue->front = queue->rear = -1;
    queue->array = (char*)malloc(queue->capacity * sizeof(char));
    return queue;
}

int isFull(Queue* queue) {
    return (queue->rear + 1) % queue->capacity == queue->front;
}

int isEmpty(Queue* queue) {
    return queue->front == -1;
}

void enqueue(Queue* queue, char item) {
    if (isFull(queue))
        return;
    if (isEmpty(queue))
        queue->front = 0;
    queue->rear = (queue->rear + 1) % queue->capacity;
    queue->array[queue->rear] = item;
}

char dequeue(Queue* queue) {
    if (isEmpty(queue))
        return '\0';
    char item = queue->array[queue->front];
    if (queue->front == queue->rear)
        queue->front = queue->rear = -1;
    else
        queue->front = (queue->front + 1) % queue->capacity;
    return item;
}

void findFirstNonRepeating(char* stream) {
    Queue* queue = createQueue(MAX_CHAR);
    int charCount[MAX_CHAR] = {0};

    for (int i = 0; stream[i]; i++) {
        enqueue(queue, stream[i]);
        charCount[stream[i] - 'a']++;

        while (!isEmpty(queue)) {
            if (charCount[queue->array[queue->front] - 'a'] > 1)
                dequeue(queue);
            else {
                printf("First non-repeating character so far is %c\n", queue->array[queue->front]);
                break;
            }
        }
        if (isEmpty(queue))
            printf("No non-repeating character so far\n");
    }
}

int main() {
    char stream[] = "abacabad";
    findFirstNonRepeating(stream);
    return 0;
}   
                        </code>
                        <p>OUTPUT</p>
                        <code>
First non-repeating character so far is a
First non-repeating character so far is b
First non-repeating character so far is b
First non-repeating character so far is b
First non-repeating character so far is b
First non-repeating character so far is b
First non-repeating character so far is d   
                        </code>
                        </pre>
    
                        </section>                                  
    </section>
                    <section id="QUE18">
                        <p>Reverse First K elements of Queue</p>
                        <pre>
                        <code >
#include <stdio.h>
#include <stdlib.h>

typedef struct Queue {
    int front, rear, size;
    unsigned capacity;
    int* array;
} Queue;

Queue* createQueue(unsigned capacity) {
    Queue* queue = (Queue*)malloc(sizeof(Queue));
    queue->capacity = capacity;
    queue->front = queue->size = 0;
    queue->rear = capacity - 1;
    queue->array = (int*)malloc(queue->capacity * sizeof(int));
    return queue;
}

int isFull(Queue* queue) {
    return (queue->size == queue->capacity);
}

int isEmpty(Queue* queue) {
    return (queue->size == 0);
}

void enqueue(Queue* queue, int item) {
    if (isFull(queue))
        return;
    queue->rear = (queue->rear + 1) % queue->capacity;
    queue->array[queue->rear] = item;
    queue->size = queue->size + 1;
}

int dequeue(Queue* queue) {
    if (isEmpty(queue))
        return -1;
    int item = queue->array[queue->front];
    queue->front = (queue->front + 1) % queue->capacity;
    queue->size = queue->size - 1;
    return item;
}

void reverseKelements(Queue* queue, int k) {
    if (isEmpty(queue) || k > queue->size)
        return;

    int* temp = (int*)malloc(k * sizeof(int));

    for (int i = 0; i < k; i++)
        temp[i] = dequeue(queue);

    for (int i = k - 1; i >= 0; i--)
        enqueue(queue, temp[i]);

    for (int i = 0; i < queue->size - k; i++)
        enqueue(queue, dequeue(queue));

    free(temp);
}

void printQueue(Queue* queue) {
    for (int i = 0; i < queue->size; i++)
        printf("%d ", queue->array[(queue->front + i) % queue->capacity]);
    printf("\n");
}

int main() {
    Queue* queue = createQueue(10);
    for (int i = 1; i <= 10; i++)
        enqueue(queue, i);

    int k = 5;
    printf("Original queue: ");
    printQueue(queue);
    reverseKelements(queue, k);
    printf("Queue after reversing the first %d elements: ", k);
    printQueue(queue);

    return 0;
}    
                        </code>
                        <p>OUTPUT</p>
                        <code>
Original queue: 1 2 3 4 5 6 7 8 9 10
Queue after reversing the first 5 elements: 5 4 3 2 1 6 7 8 9 10   
                        </code>
                        </pre>
                        </section>                                  
    
                    <section id="QUE19">
                        <p>Queue Reversal</p>
                        <pre>
                        <code >
#include <stdio.h>
#include <stdlib.h>

#define SIZE 5

typedef struct Queue {
    int items[SIZE];
    int front;
    int rear;
} Queue;

void createQueue(Queue* q) {
    q->front = -1;
    q->rear = -1;
}

int isFull(Queue* q) {
    if ((q->front == q->rear + 1) || (q->front == 0 && q->rear == SIZE - 1))
        return 1;
    return 0;
}

int isEmpty(Queue* q) {
    if (q->front == -1)
        return 1;
    return 0;
}

void enQueue(Queue* q, int value) {
    if (isFull(q))
        printf("\nQueue is full!");
    else {
        if (q->front == -1)
            q->front = 0;
        q->rear = (q->rear + 1) % SIZE;
        q->items[q->rear] = value;
    }
}

int deQueue(Queue* q) {
    int item;
    if (isEmpty(q)) {
        printf("Queue is empty");
        item = -1;
    } else {
        item = q->items[q->front];
        if (q->front == q->rear) {
            q->front = -1;
            q->rear = -1;
        } else {
            q->front = (q->front + 1) % SIZE;
        }
    }
    return item;
}

void reverseQueue(Queue* q) {
    int temp;
    if (isEmpty(q)) {
        printf("Queue is empty");
        return;
    } else {
        while (q->front != q->rear) {
            temp = q->items[q->front];
            q->items[q->front] = q->items[q->rear];
            q->items[q->rear] = temp;
            q->front = (q->front + 1) % SIZE;
            q->rear = (q->rear - 1 + SIZE) % SIZE;
        }
    }
}

void printQueue(Queue* q) {
    int i;
    if (isEmpty(q)) {
        printf("Queue is empty");
    } else {
        printf("\nFront -> %d ", q->front);
        printf("\nItems -> ");
        for (i = q->front; i != q->rear; i = (i + 1) % SIZE) {
            printf("%d ", q->items[i]);
        }
        printf("%d ", q->items[i]);
        printf("\nRear -> %d", q->rear);
    }
}

int main() {
    Queue* q = (Queue*)malloc(sizeof(Queue));
    createQueue(q);
    enQueue(q, 1);
    enQueue(q, 2);
    enQueue(q, 3);
    enQueue(q, 4);
    enQueue(q, 5);
    printf("Original Queue: ");
    printQueue(q);
    reverseQueue(q);
    printf("\nReversed Queue: ");
    printQueue(q);

    return 0;
}   
                        </code>
                        <p>OUTPUT</p>
                        <code>
 Original Queue: 
Front -> 0 
Items -> 1 2 3 4 5 
Rear -> 4
Reversed Queue: 
Front -> 0 
Items -> 5 4 3 2 1 
Rear -> 4   
                        </code>
                        </pre>
    
                        </section>                                  
    
                    <section id="QUE20">
                        <p>Rotten Oranges</p>
                        <pre>
                        <code >
#include <stdio.h>

#define R 3
#define C 5

struct Node {
    int x;
    int y;
};

int isInsideGrid(int i, int j) {
    return (i >= 0 && i < R && j >= 0 && j < C);
}

int hasFreshOranges(int grid[R][C]) {
    int i, j;
    for (i = 0; i < R; i++) {
        for (j = 0; j < C; j++) {
            if (grid[i][j] == 1) {
                return 1;
            }
        }
    }
    return 0;
}

int findTime(int grid[R][C]) {
    struct Node queue[R * C];
    int front = 0, rear = 0;
    int row[] = {0, 0, 1, -1};
    int col[] = {1, -1, 0, 0};
    int timer = 0;

    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++) {
            if (grid[i][j] == 2) {
                queue[rear].x = i;
                queue[rear].y = j;
                rear++;
            }
        }
    }

    queue[rear].x = -1;
    queue[rear].y = -1;
    rear++;

    while (front < rear) {
        int flag = 0;
        while (queue[front].x != -1 && queue[front].y != -1) {
            for (int i = 0; i < 4; i++) {
                int newRow = queue[front].x + row[i];
                int newCol = queue[front].y + col[i];

                if (isInsideGrid(newRow, newCol) && grid[newRow][newCol] == 1) {
                    grid[newRow][newCol] = 2;
                    queue[rear].x = newRow;
                    queue[rear].y = newCol;
                    rear++;
                    if (flag == 0) {
                        flag = 1;
                        timer++;
                    }
                }
            }
            front++;
        }
        front++;
        if (flag == 1 && front < rear) {
            queue[rear].x = -1;
            queue[rear].y = -1;
            rear++;
        }
    }

    return hasFreshOranges(grid) ? -1 : timer;
}

int main() {
    int grid[R][C] = {{2, 1, 0, 2, 1},
                      {1, 0, 1, 2, 1},
                      {1, 0, 0, 2, 1}};

    int result = findTime(grid);
    if (result == -1) {
        printf("All oranges cannot rot");
    } else {
        printf("Time taken for all oranges to rot: %d", result);
    }
    return 0;
}    
                        </code>
                        <p>OUTPUT</p>
                        <code>
Time taken for all oranges to rot: 4  
                        </code>
                        </pre>
    
                        </section>                                  
    </section>

    <section id="linkedlist">
        <h2>LINKEDLIST PROBLEMS</h2>
        <ul>
            <li><a href="#ll1">Q-1:IMPLEMENT THE OPERATIONS OF SINGLE LINKED LIST STORING INTEGER VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</a></li>
            <li><a href="#ll2">Q-2:IMPLEMENT THE OPERATIONS OF SINGLE CIRCULAR LINKED LIST STORING INTEGER VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</a></li>
            <li><a href="#ll3">Q-3:IMPLEMENT THE OPERATIONS OF DOUBLY LINKED LIST STORING INTEGER VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</a></li>
            <li><a href="#ll4">Q-4:IMPLEMENT THE OPERATIONS OF DOUBLY CIRCULAR LINKED LIST STORING INTEGER VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</a></li>
            <li><a href="#ll5">Q-5:IMPLEMENT THE OPERATIONS OF SINGLE LINKED LIST STORING STRING VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</a></li>
            <li><a href="#ll6">Q-6:IMPLEMENT THE OPERATIONS OF SINGLE CIRCULAR LINKED LIST STORING STRING VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</a></li>
            <li><a href="#ll7">Q-7:IMPLEMENT THE OPERATIONS OF DOUBLY LINKED LIST STORING STRING VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</a></li>
            <li><a href="#ll8">Q-8:IMPLEMENT THE OPERATIONS OF DOUBLY CIRCULAR LINKED LIST STORING STRING VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</a></li>
            <li><a href="#ll9">Q-9:ENTER THE 2 POLYNOMIAL EQUATIONS DYNAMICALLY, ADD THEM AND DISPLAY THE ANSWER.</a></li>
            <li><a href="#ll10">Q-10:ENTER THE 2 POLYNOMIAL EQUATIONS DYNAMICALLY, SUBTRACT THEM AND DISPLAY THE ANSWER.</a></li>
            <li><a href="#ll11">Q-11:ENTER THE 2 POLYNOMIAL EQUATIONS DYNAMICALLY, MULTIPLY THEM AND DISPLAY THE ANSWER.</a></li>

            <section id="ll1">
                <p>Q-1:IMPLEMENT THE OPERATIONS OF SINGLE LINKED LIST STORING INTEGER VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="ll2">
                <p>Q-2:IMPLEMENT THE OPERATIONS OF SINGLE CIRCULAR LINKED LIST STORING INTEGER VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="ll3">
                <p>Q-3:IMPLEMENT THE OPERATIONS OF DOUBLY LINKED LIST STORING INTEGER VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="ll4">
                <p>Q-4:IMPLEMENT THE OPERATIONS OF DOUBLY CIRCULAR LINKED LIST STORING INTEGER VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="ll5">
                <p>Q-5:IMPLEMENT THE OPERATIONS OF SINGLE LINKED LIST STORING STRING VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="ll6">
                <p>Q-6:IMPLEMENT THE OPERATIONS OF SINGLE CIRCULAR LINKED LIST STORING STRING VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="ll7">
                <p>Q-7:IMPLEMENT THE OPERATIONS OF DOUBLY LINKED LIST STORING STRING VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="ll8">
                <p>Q-8:IMPLEMENT THE OPERATIONS OF DOUBLY CIRCULAR LINKED LIST STORING STRING VALUES (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="ll9">
                <p>Q-9:ENTER THE 2 POLYNOMIAL EQUATIONS DYNAMICALLY, ADD THEM AND DISPLAY THE ANSWER.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="ll10">
                <p>Q-10:ENTER THE 2 POLYNOMIAL EQUATIONS DYNAMICALLY, SUBTRACT THEM AND DISPLAY THE ANSWER.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="ll11">
                <p>Q-11:ENTER THE 2 POLYNOMIAL EQUATIONS DYNAMICALLY, MULTIPLY THEM AND DISPLAY THE ANSWER.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>

        </ul>
       
    </section>

    <section id="trees">
        <h2>TREE PROBLEMS</h2>
        <ul>
            <li><a href="#tree1">Q-1:CONSTRUCT BINARY TREE FROM PREORDER AND INORDER TRAVERSAL</a></li>
            <li><a href="#tree2">Q-2:BINARY TREE LEVEL ORDER TRAVERSAL</a></li>
            <li><a href="#tree3">Q-3:PRINT LEFT VIEW OF BINARY TREE</a></li>
            <li><a href="#tree4">Q-4:DISPLAY THE RIGHT VIEW OF BINARY TREE</a></li>
            <li><a href="#tree5">Q-5:CONSTRUCT BINARY TREE FROM POSTORDER AND INORDER TRAVERSAL</a></li>
            <li><a href="#tree6">Q-6:FIND THE MAXIMUM DEPTH OF BINARY TREE</a></li>
            <li><a href="#tree7">Q-7:CREATE BINARY SEARCH TREE USING ARRAYS (INSERT, DELETE, SEARCH, PREORDER, INORDER, POSTORDER, MINIMUM ELEMENT)</a></li>
            <li><a href="#tree8">Q-8:CREATE BINARY SEARCH TREE DYNAMICALLY (INSERT, DELETE, SEARCH, PREORDER, INORDER, POSTORDER, MINIMUM ELEMENT)</a></li>
            <li><a href="#tree9">Q-9:FIND INORDER PREDECESSOR AND INORDER SUCCESSOR OF BINARY SEARCH TREE (DYNAMICALLY REPRESENTED)</a></li>
            <li><a href="#tree10">Q-10:CHECK WHETHER BINARY SEARCH TREE CONTAINS DEAD END</a></li>
            <li><a href="#tree11">Q-11:CREATE BINARY TREE TO BINARY SEARCH TREE THROUGH ARRAY.</a></li>
            <li><a href="#tree12">Q-12:FIND KTH LARGEST ELEMENT IN BINARY SEARCH TREE THROUGH ARRAY</a></li>
            <li><a href="#tree13">Q-13:FIND KTH SMALLEST ELEMENT IN A BINARY SEARCH TREE THROUGH ARRAY</a></li>
            <li><a href="#tree14">Q-14:PRINT PREORDER TRAVERSAL TO POSTORDER TRAVERSAL OF BINARY SEARCH TREE</a></li>
            <li><a href="#tree15">Q-15:CONSTRUCT BINARY SEARCH TREE FROM GIVEN PREORDER TRAVERSAL THROUGH ARRAYS</a></li>
            <li><a href="#tree16">Q-16:CONSTRUCT BINARY SEARCH TREE FROM GIVEN POSTORDER TRAVERSAL THROUGH ARRAYS</a></li>
            <li><a href="#tree17">Q-17:CREATE STRICTLY BINARY TREE FROM THE GIVEN INPUT BY THE USER (DYNAMICALLY)</a></li>
            <li><a href="#tree18">Q-18:CREATE ALMOST COMPLETE BINARY TREE FROM THE GIVEN INPUT BY THE USER (DYNAMICALLY)</a></li>
            <li><a href="#tree19">Q-19:CREATE COMPLETE BINARY TREE FROM THE GIVEN INPUT BY THE USER (DYNAMICALLY)</a></li>
            <li><a href="#tree20">Q-20:COUNT THE NUMBER OF NODES IN BINARY SEARCH TREE CONSTRUCTED DYNAMICALLY</a></li>

            <section id="tree1">
                <p>Q-1:CONSTRUCT BINARY TREE FROM PREORDER AND INORDER TRAVERSAL</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="tree2">
                <p>Q-2:BINARY TREE LEVEL ORDER TRAVERSAL</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="tree3">
                <p>Q-3:PRINT LEFT VIEW OF BINARY TREE</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="tree4">
                <p>Q-4:DISPLAY THE RIGHT VIEW OF BINARY TREE</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="tree5">
                <p>Q-5:CONSTRUCT BINARY TREE FROM POSTORDER AND INORDER TRAVERSAL</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="tree6">
                <p>Q-6:FIND THE MAXIMUM DEPTH OF BINARY TREE</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="tree7">
                <p>Q-7:CREATE BINARY SEARCH TREE USING ARRAYS (INSERT, DELETE, SEARCH, PREORDER, INORDER, POSTORDER, MINIMUM ELEMENT)</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="tree8">
                <p>Q-8:CREATE BINARY SEARCH TREE DYNAMICALLY (INSERT, DELETE, SEARCH, PREORDER, INORDER, POSTORDER, MINIMUM ELEMENT)</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="tree9">
                <p>Q-9:FIND INORDER PREDECESSOR AND INORDER SUCCESSOR OF BINARY SEARCH TREE (DYNAMICALLY REPRESENTED)</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="tree10">
                <p>Q-10:CHECK WHETHER BINARY SEARCH TREE CONTAINS DEAD END</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="tree11">
                <p>Q-11:CREATE BINARY TREE TO BINARY SEARCH TREE THROUGH ARRAY.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="tree12">
                <p>Q-12:FIND KTH LARGEST ELEMENT IN BINARY SEARCH TREE THROUGH ARRAY</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="tree13">
                <p>Q-13:FIND KTH SMALLEST ELEMENT IN A BINARY SEARCH TREE THROUGH ARRAY</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="tree14">
                <p>Q-14:PRINT PREORDER TRAVERSAL TO POSTORDER TRAVERSAL OF BINARY SEARCH TREE</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="tree15">
                <p>Q-15:CONSTRUCT BINARY SEARCH TREE FROM GIVEN PREORDER TRAVERSAL THROUGH ARRAYS</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="tree16">
                <p>Q-16:CONSTRUCT BINARY SEARCH TREE FROM GIVEN POSTORDER TRAVERSAL THROUGH ARRAYS</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="tree17">
                <p>Q-17:CREATE STRICTLY BINARY TREE FROM THE GIVEN INPUT BY THE USER (DYNAMICALLY)</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="tree18">
                <p>Q-18:CREATE ALMOST COMPLETE BINARY TREE FROM THE GIVEN INPUT BY THE USER (DYNAMICALLY)</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="tree19">
                <p>Q-19:CREATE COMPLETE BINARY TREE FROM THE GIVEN INPUT BY THE USER (DYNAMICALLY)</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="tree20">
                <p>Q-20:COUNT THE NUMBER OF NODES IN BINARY SEARCH TREE CONSTRUCTED DYNAMICALLY</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
                
        </ul>
       
    </section>

    <section id="graphs">
        <h2>GRAPH PROBLEMS</h2>
        <ul>
            <li><a href="#graph1">Q-1:ENTER THE VERTICES AND EDGES AND REPRESENT IN ADJACENCY MATRIX AND PRINT IT.</a></li>
            <li><a href="#graph2">Q-2:CREATE THE GRAPH AS A ADJACENCY LIST WITH OPERATIONS SUCH AS INSERTION, DELETION</a></li>
            <li><a href="#graph3">Q-3:TRAVERSE THE ADJACENT MATRIX WITH DEPTH FIRST SEARCH</a></li>
            <li><a href="#graph4">Q-4:TRAVERSE THE ADJACENT LIST WITH DEPTH FIRST SEARCH</a></li>
            <li><a href="#graph5">Q-5:TRAVERSE THE ADJACENT MATRIX WITH BREADTH FIRST SEARCH</a></li>
            <li><a href="#graph6">Q-6:TRAVERSE THE ADJACENT LIST WITH BREADTH FIRST SEARCH</a></li>
            <section id="graph1">
                <p>Q-1:ENTER THE VERTICES AND EDGES AND REPRESENT IN ADJACENCY MATRIX AND PRINT IT.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="graph2">
                <p>Q-2:CREATE THE GRAPH AS A ADJACENCY LIST WITH OPERATIONS SUCH AS INSERTION, DELETION</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="graph3">
                <p>Q-3:TRAVERSE THE ADJACENT MATRIX WITH DEPTH FIRST SEARCH</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="graph4">
                <p>Q-4:TRAVERSE THE ADJACENT LIST WITH DEPTH FIRST SEARCH</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="graph5">
                <p>Q-5:TRAVERSE THE ADJACENT MATRIX WITH BREADTH FIRST SEARCH</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="graph6">
                <p>Q-6:TRAVERSE THE ADJACENT LIST WITH BREADTH FIRST SEARCH</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
    
        </ul>
    </section>

    <section id="searching">
        <h2>SEARCHING PROBLEMS</h2>
        <ul>
            <li><a href="#search1">Q-1:ENTER A INTEGER ARRAY FROM THE USER, ENTER AN INTEGER VALUE AND PERFORM LINEAR SEARCH ALGORITHM THROUGH ITERATION.</a></li>
            <li><a href="#search2">Q-2:ENTER A STRING FROM THE USER, ENTER A CHARACTER AND PERFORM LINEAR SEARCH ALGORITHM THROUGH RECURSION.</a></li>
            <li><a href="#search3">Q-3:ENTER A INTEGER ARRAY FROM THE USER, ENTER AN INTEGER VALUE AND PERFORM LINEAR SEARCH ALGORITHM THROUGH RECURSION.</a></li>
            <li><a href="#search4">Q-4:ENTER A STRING FROM THE USER, ENTER A CHARACTER AND PERFORM LINEAR SEARCH ALGORITHM THROUGH ITERATION.</a></li>
            <li><a href="#search5">Q-5:ENTER A INTEGER ARRAY FROM THE USER, ENTER AN INTEGER VALUE AND PERFORM BINARY SEARCH ALGORITHM THROUGH ITERATION.</a></li>
            <li><a href="#search6">Q-6:ENTER A STRING FROM THE USER, ENTER A CHARACTER AND PERFORM BINARY SEARCH ALGORITHM THROUGH RECURSION.</a></li>
            <li><a href="#search7">Q-7:ENTER A INTEGER ARRAY FROM THE USER, ENTER AN INTEGER VALUE AND PERFORM BINARY SEARCH ALGORITHM THROUGH RECURSION.</a></li>
            <li><a href="#search8">Q-8:ENTER A STRING FROM THE USER, ENTER A CHARACTER AND PERFORM BINARY SEARCH ALGORITHM THROUGH ITERATION.</a></li>
            <li><a href="#search9">Q-9:CALCULATE THE BEST AND WORST COMPLEXITY OF THE LINEAR SEARCHING ALGORITHM WITH EXACT TIME TAKEN BY THE ALGORITHM ON INTEGER ARRAY.</a></li>
            <li><a href="#search10">Q-10:CALCULATE THE BEST AND WORST COMPLEXITY OF THE BINARY SEARCHING ALGORITHM WITH EXACT TIME TAKEN BY THE ALGORITHM ON INTEGER ARRAY.</a></li>

            <section id="search1">
                <p>Q-1:ENTER A INTEGER ARRAY FROM THE USER, ENTER AN INTEGER VALUE AND PERFORM LINEAR SEARCH ALGORITHM THROUGH ITERATION.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="search2">
                <p>Q-2:ENTER A STRING FROM THE USER, ENTER A CHARACTER AND PERFORM LINEAR SEARCH ALGORITHM THROUGH RECURSION.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="search3">
                <p>Q-3:ENTER A INTEGER ARRAY FROM THE USER, ENTER AN INTEGER VALUE AND PERFORM LINEAR SEARCH ALGORITHM THROUGH RECURSION.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="search4">
                <p>Q-4:ENTER A STRING FROM THE USER, ENTER A CHARACTER AND PERFORM LINEAR SEARCH ALGORITHM THROUGH ITERATION.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="search5">
                <p>Q-5:ENTER A INTEGER ARRAY FROM THE USER, ENTER AN INTEGER VALUE AND PERFORM BINARY SEARCH ALGORITHM THROUGH ITERATION.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="search6">
                <p>Q-6:ENTER A STRING FROM THE USER, ENTER A CHARACTER AND PERFORM BINARY SEARCH ALGORITHM THROUGH RECURSION.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="search7">
                <p>Q-7:ENTER A INTEGER ARRAY FROM THE USER, ENTER AN INTEGER VALUE AND PERFORM BINARY SEARCH ALGORITHM THROUGH RECURSION.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="search8">
                <p>Q-8:ENTER A STRING FROM THE USER, ENTER A CHARACTER AND PERFORM BINARY SEARCH ALGORITHM THROUGH ITERATION.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="search9">
                <p>Q-9:CALCULATE THE BEST AND WORST COMPLEXITY OF THE LINEAR SEARCHING ALGORITHM WITH EXACT TIME TAKEN BY THE ALGORITHM ON INTEGER ARRAY.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="search10">
                <p>Q-10:CALCULATE THE BEST AND WORST COMPLEXITY OF THE BINARY SEARCHING ALGORITHM WITH EXACT TIME TAKEN BY THE ALGORITHM ON INTEGER ARRAY.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>





        </ul>
        
    </section>

    <section id="sorting">
        <h2>SORTING PROBLEMS</h2>
        <ul>
            <li><a href="#sort1">Q-1:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM SELECTION SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort2">Q-2:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM SELECTION SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort3">Q-3:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM BUBBLE SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort4">Q-4:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM BUBBLE SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort5">Q-5:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM INSERTION SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort6">Q-6:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM INSERTION SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort7">Q-7:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM MERGE SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort8">Q-8:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM MERGE SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort9">Q-9:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM QUICK SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort10">Q-10:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM QUICK SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort11">Q-11:ENTER A STRING ARRAY FROM THE USER AND PERFORM SELECTION SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort12">Q-12:ENTER A STRING ARRAY FROM THE USER AND PERFORM SELECTION SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort13">Q-13:ENTER A STRING ARRAY FROM THE USER AND PERFORM BUBBLE SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort14">Q-14:ENTER A STRING ARRAY FROM THE USER AND PERFORM BUBBLE SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort15">Q-15:ENTER A STRING ARRAY FROM THE USER AND PERFORM INSERTION SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort16">Q-16:ENTER A STRING ARRAY FROM THE USER AND PERFORM INSERTION SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort17">Q-17:ENTER A STRING ARRAY FROM THE USER AND PERFORM MERGE SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort18">Q-18:ENTER A STRING ARRAY FROM THE USER AND PERFORM MERGE SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort19">Q-19:ENTER A STRING ARRAY FROM THE USER AND PERFORM QUICK SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
            <li><a href="#sort20">Q-20:ENTER A STRING ARRAY FROM THE USER AND PERFORM QUICK SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>

            <section id="sort1">
                <p>Q-1:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM SELECTION SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort2">
                <p>Q-2:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM SELECTION SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort3">
                <p>Q-3:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM BUBBLE SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort4">
                <p>Q-4:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM BUBBLE SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort5">
                <p>Q-5:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM INSERTION SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort6">
                <p>Q-6:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM INSERTION SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort7">
                <p>Q-7:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM MERGE SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort8">
                <p>Q-8:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM MERGE SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort9">
                <p>Q-9:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM QUICK SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort10">
                <p>Q-10:ENTER A INTEGER ARRAY FROM THE USER AND PERFORM QUICK SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort11">
                <p>Q-11:ENTER A STRING ARRAY FROM THE USER AND PERFORM SELECTION SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort12">
                <p>Q-12:ENTER A STRING ARRAY FROM THE USER AND PERFORM SELECTION SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort13">
                <p>Q-13:ENTER A STRING ARRAY FROM THE USER AND PERFORM BUBBLE SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort14">
                <p>Q-14:ENTER A STRING ARRAY FROM THE USER AND PERFORM BUBBLE SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort15">
                <p>Q-15:ENTER A STRING ARRAY FROM THE USER AND PERFORM INSERTION SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort16">
                <p>Q-16:ENTER A STRING ARRAY FROM THE USER AND PERFORM INSERTION SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort17">
                <p>Q-17:ENTER A STRING ARRAY FROM THE USER AND PERFORM MERGE SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort18">
                <p>Q-18:ENTER A STRING ARRAY FROM THE USER AND PERFORM MERGE SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort19">
                <p>Q-19:ENTER A STRING ARRAY FROM THE USER AND PERFORM QUICK SORT ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>
            <section id="sort20">
                <p>Q-20:ENTER A STRING ARRAY FROM THE USER AND PERFORM QUICK SORT ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</a></li>
                </p>
                <pre>
                <code >

                </code>
                <p>OUTPUT</p>
                <code>

                </code>
                </pre>

                </section>



        </ul>
    </section>

    <!-- <footer>
        <p>&copy; 2023 StartupX. All rights reserved.</p>
    </footer> -->
</body>
</html>
